<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JUC线程池 - Fork/Join框架详解 | Cyan&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/e-logo-ico.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_3114978_qe0b39no76.css">
    <noscript><meta http-equiv="refresh" content="0; url=https://www.youngkbt.cn/noscript/"><style>.theme-vdoing-content { display:none }</noscript>
    <meta name="description" content="个人博客">
    <meta name="keywords" content="个人博客,技术,学习">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <link rel="preload" href="/assets/css/0.styles.c35b53db.css" as="style"><link rel="preload" href="/assets/js/app.e612eeea.js" as="script"><link rel="preload" href="/assets/js/2.55c43c56.js" as="script"><link rel="preload" href="/assets/js/70.9a186c3e.js" as="script"><link rel="preload" href="/assets/js/10.2e6611d1.js" as="script"><link rel="preload" href="/assets/js/4.093d7523.js" as="script"><link rel="prefetch" href="/assets/js/100.1f3f39e3.js"><link rel="prefetch" href="/assets/js/101.dd05f0c5.js"><link rel="prefetch" href="/assets/js/102.d5892977.js"><link rel="prefetch" href="/assets/js/103.17aa17c1.js"><link rel="prefetch" href="/assets/js/104.91d7ae3c.js"><link rel="prefetch" href="/assets/js/105.14af617a.js"><link rel="prefetch" href="/assets/js/106.1a22b2a5.js"><link rel="prefetch" href="/assets/js/107.d4d9fd57.js"><link rel="prefetch" href="/assets/js/108.9348971d.js"><link rel="prefetch" href="/assets/js/109.f3363bf9.js"><link rel="prefetch" href="/assets/js/11.09963219.js"><link rel="prefetch" href="/assets/js/110.12f7e029.js"><link rel="prefetch" href="/assets/js/111.75646d36.js"><link rel="prefetch" href="/assets/js/112.c5d2f642.js"><link rel="prefetch" href="/assets/js/113.2e43b663.js"><link rel="prefetch" href="/assets/js/114.3aa86913.js"><link rel="prefetch" href="/assets/js/115.b481fb05.js"><link rel="prefetch" href="/assets/js/116.c0120c0f.js"><link rel="prefetch" href="/assets/js/117.c82be6e2.js"><link rel="prefetch" href="/assets/js/118.0c073e55.js"><link rel="prefetch" href="/assets/js/119.582008bd.js"><link rel="prefetch" href="/assets/js/12.9ef79bba.js"><link rel="prefetch" href="/assets/js/120.c3f63f3c.js"><link rel="prefetch" href="/assets/js/121.0548d841.js"><link rel="prefetch" href="/assets/js/122.1510f132.js"><link rel="prefetch" href="/assets/js/123.36e5ed39.js"><link rel="prefetch" href="/assets/js/124.c198f599.js"><link rel="prefetch" href="/assets/js/125.3eed5cb9.js"><link rel="prefetch" href="/assets/js/126.844341a9.js"><link rel="prefetch" href="/assets/js/127.c1e5e155.js"><link rel="prefetch" href="/assets/js/128.8d10b1b1.js"><link rel="prefetch" href="/assets/js/129.cde069ba.js"><link rel="prefetch" href="/assets/js/13.2c53bc10.js"><link rel="prefetch" href="/assets/js/130.241ddede.js"><link rel="prefetch" href="/assets/js/131.9107c762.js"><link rel="prefetch" href="/assets/js/132.5b55dffc.js"><link rel="prefetch" href="/assets/js/133.b598a335.js"><link rel="prefetch" href="/assets/js/134.c08dae83.js"><link rel="prefetch" href="/assets/js/135.f86a519a.js"><link rel="prefetch" href="/assets/js/136.83b0d468.js"><link rel="prefetch" href="/assets/js/137.bb488d21.js"><link rel="prefetch" href="/assets/js/138.4d24e979.js"><link rel="prefetch" href="/assets/js/139.7a2144d1.js"><link rel="prefetch" href="/assets/js/14.09650984.js"><link rel="prefetch" href="/assets/js/140.9fa4f114.js"><link rel="prefetch" href="/assets/js/141.403e90f3.js"><link rel="prefetch" href="/assets/js/142.9c24e226.js"><link rel="prefetch" href="/assets/js/143.7bf9d72e.js"><link rel="prefetch" href="/assets/js/144.4e883dc4.js"><link rel="prefetch" href="/assets/js/145.47186915.js"><link rel="prefetch" href="/assets/js/146.7e25f1b2.js"><link rel="prefetch" href="/assets/js/147.886757de.js"><link rel="prefetch" href="/assets/js/148.98d8fe53.js"><link rel="prefetch" href="/assets/js/149.dda76669.js"><link rel="prefetch" href="/assets/js/15.bdff6609.js"><link rel="prefetch" href="/assets/js/150.9f4aafab.js"><link rel="prefetch" href="/assets/js/151.91ae4b65.js"><link rel="prefetch" href="/assets/js/152.cbb369e3.js"><link rel="prefetch" href="/assets/js/153.893e878f.js"><link rel="prefetch" href="/assets/js/154.9409523f.js"><link rel="prefetch" href="/assets/js/155.c70c2a8c.js"><link rel="prefetch" href="/assets/js/156.ee03e772.js"><link rel="prefetch" href="/assets/js/157.e7b7108c.js"><link rel="prefetch" href="/assets/js/158.3d36a3ae.js"><link rel="prefetch" href="/assets/js/159.c1864d30.js"><link rel="prefetch" href="/assets/js/16.80bce06b.js"><link rel="prefetch" href="/assets/js/160.235580d4.js"><link rel="prefetch" href="/assets/js/161.db3bf92d.js"><link rel="prefetch" href="/assets/js/162.79be4615.js"><link rel="prefetch" href="/assets/js/163.a61b5f03.js"><link rel="prefetch" href="/assets/js/164.89148d05.js"><link rel="prefetch" href="/assets/js/165.c26711af.js"><link rel="prefetch" href="/assets/js/166.b3939cf4.js"><link rel="prefetch" href="/assets/js/167.01296cbc.js"><link rel="prefetch" href="/assets/js/168.008aef66.js"><link rel="prefetch" href="/assets/js/169.7a8fd27b.js"><link rel="prefetch" href="/assets/js/17.acdc8bc0.js"><link rel="prefetch" href="/assets/js/170.cbef7c81.js"><link rel="prefetch" href="/assets/js/171.39a6027d.js"><link rel="prefetch" href="/assets/js/172.76a493fe.js"><link rel="prefetch" href="/assets/js/173.f071c4c2.js"><link rel="prefetch" href="/assets/js/174.5efcb55f.js"><link rel="prefetch" href="/assets/js/175.313d3f17.js"><link rel="prefetch" href="/assets/js/176.1e5266f7.js"><link rel="prefetch" href="/assets/js/177.c4186bde.js"><link rel="prefetch" href="/assets/js/178.738ba3dd.js"><link rel="prefetch" href="/assets/js/179.61a43d5f.js"><link rel="prefetch" href="/assets/js/18.237bc642.js"><link rel="prefetch" href="/assets/js/180.086484a4.js"><link rel="prefetch" href="/assets/js/181.5e23ae0d.js"><link rel="prefetch" href="/assets/js/182.c4f1ce87.js"><link rel="prefetch" href="/assets/js/183.350412c4.js"><link rel="prefetch" href="/assets/js/184.30a2b57a.js"><link rel="prefetch" href="/assets/js/185.3ff61bae.js"><link rel="prefetch" href="/assets/js/186.ef0dcb8b.js"><link rel="prefetch" href="/assets/js/187.17706f9e.js"><link rel="prefetch" href="/assets/js/188.da2df17e.js"><link rel="prefetch" href="/assets/js/189.73e658d6.js"><link rel="prefetch" href="/assets/js/19.c71d6006.js"><link rel="prefetch" href="/assets/js/190.2c684e8d.js"><link rel="prefetch" href="/assets/js/191.8e68d709.js"><link rel="prefetch" href="/assets/js/192.ba90159e.js"><link rel="prefetch" href="/assets/js/193.978eca75.js"><link rel="prefetch" href="/assets/js/194.65b974a5.js"><link rel="prefetch" href="/assets/js/195.35074c76.js"><link rel="prefetch" href="/assets/js/196.90a4a52a.js"><link rel="prefetch" href="/assets/js/197.71f1014c.js"><link rel="prefetch" href="/assets/js/198.3feaf0fc.js"><link rel="prefetch" href="/assets/js/199.79ef872e.js"><link rel="prefetch" href="/assets/js/20.282b2fbb.js"><link rel="prefetch" href="/assets/js/200.213888b8.js"><link rel="prefetch" href="/assets/js/201.69a45c4e.js"><link rel="prefetch" href="/assets/js/202.a0a9b374.js"><link rel="prefetch" href="/assets/js/203.359e5f82.js"><link rel="prefetch" href="/assets/js/204.eaaa3ae2.js"><link rel="prefetch" href="/assets/js/205.16378ace.js"><link rel="prefetch" href="/assets/js/206.99715a38.js"><link rel="prefetch" href="/assets/js/207.2f30344a.js"><link rel="prefetch" href="/assets/js/208.ce73a26c.js"><link rel="prefetch" href="/assets/js/209.f930ad7e.js"><link rel="prefetch" href="/assets/js/21.bd3e2ff5.js"><link rel="prefetch" href="/assets/js/210.0a8ee492.js"><link rel="prefetch" href="/assets/js/211.5e4a30d6.js"><link rel="prefetch" href="/assets/js/212.f4976f28.js"><link rel="prefetch" href="/assets/js/213.030bdb82.js"><link rel="prefetch" href="/assets/js/214.261ffafe.js"><link rel="prefetch" href="/assets/js/215.4358a00f.js"><link rel="prefetch" href="/assets/js/216.dd555e5e.js"><link rel="prefetch" href="/assets/js/217.fe5f87e4.js"><link rel="prefetch" href="/assets/js/218.809a8050.js"><link rel="prefetch" href="/assets/js/219.8629ec6e.js"><link rel="prefetch" href="/assets/js/22.61795a0e.js"><link rel="prefetch" href="/assets/js/220.c5258f7c.js"><link rel="prefetch" href="/assets/js/221.e46ad200.js"><link rel="prefetch" href="/assets/js/222.2a3a92b2.js"><link rel="prefetch" href="/assets/js/223.06371ad9.js"><link rel="prefetch" href="/assets/js/224.fdcbcc04.js"><link rel="prefetch" href="/assets/js/225.e4a32c97.js"><link rel="prefetch" href="/assets/js/226.9fbc01a1.js"><link rel="prefetch" href="/assets/js/227.e4b77417.js"><link rel="prefetch" href="/assets/js/228.8c4533c3.js"><link rel="prefetch" href="/assets/js/229.a84c65b0.js"><link rel="prefetch" href="/assets/js/23.0f1d518c.js"><link rel="prefetch" href="/assets/js/230.66b9f814.js"><link rel="prefetch" href="/assets/js/231.69f14474.js"><link rel="prefetch" href="/assets/js/232.938ae9c4.js"><link rel="prefetch" href="/assets/js/233.6360b54e.js"><link rel="prefetch" href="/assets/js/234.c7c820bc.js"><link rel="prefetch" href="/assets/js/235.655f3e8a.js"><link rel="prefetch" href="/assets/js/236.62540799.js"><link rel="prefetch" href="/assets/js/237.8cd1a558.js"><link rel="prefetch" href="/assets/js/238.c731000d.js"><link rel="prefetch" href="/assets/js/239.5f3f37c1.js"><link rel="prefetch" href="/assets/js/24.46066bb8.js"><link rel="prefetch" href="/assets/js/240.cca6e6b5.js"><link rel="prefetch" href="/assets/js/241.9d12248b.js"><link rel="prefetch" href="/assets/js/242.15355251.js"><link rel="prefetch" href="/assets/js/243.4b15b97b.js"><link rel="prefetch" href="/assets/js/244.c9a1c9d9.js"><link rel="prefetch" href="/assets/js/245.485f02be.js"><link rel="prefetch" href="/assets/js/246.91e755da.js"><link rel="prefetch" href="/assets/js/247.7175c4d5.js"><link rel="prefetch" href="/assets/js/248.e3cec6db.js"><link rel="prefetch" href="/assets/js/249.6f48ac1b.js"><link rel="prefetch" href="/assets/js/25.365c39a8.js"><link rel="prefetch" href="/assets/js/250.2a13411e.js"><link rel="prefetch" href="/assets/js/251.8c2269aa.js"><link rel="prefetch" href="/assets/js/252.074c6068.js"><link rel="prefetch" href="/assets/js/253.877d1643.js"><link rel="prefetch" href="/assets/js/254.d9bfb2ad.js"><link rel="prefetch" href="/assets/js/255.a0acc21d.js"><link rel="prefetch" href="/assets/js/256.66425b2c.js"><link rel="prefetch" href="/assets/js/257.17ce1298.js"><link rel="prefetch" href="/assets/js/258.6c1f12bf.js"><link rel="prefetch" href="/assets/js/259.c5235902.js"><link rel="prefetch" href="/assets/js/26.0d286c8b.js"><link rel="prefetch" href="/assets/js/260.c1ec431f.js"><link rel="prefetch" href="/assets/js/261.f86fef48.js"><link rel="prefetch" href="/assets/js/262.550c9d5c.js"><link rel="prefetch" href="/assets/js/263.2002d0d2.js"><link rel="prefetch" href="/assets/js/264.d7e30977.js"><link rel="prefetch" href="/assets/js/265.e7535ef4.js"><link rel="prefetch" href="/assets/js/266.de410e28.js"><link rel="prefetch" href="/assets/js/267.bbd5797e.js"><link rel="prefetch" href="/assets/js/268.f310989b.js"><link rel="prefetch" href="/assets/js/269.558494b6.js"><link rel="prefetch" href="/assets/js/27.d94b1e0e.js"><link rel="prefetch" href="/assets/js/270.cd6f9a9d.js"><link rel="prefetch" href="/assets/js/271.a8133725.js"><link rel="prefetch" href="/assets/js/272.408b8940.js"><link rel="prefetch" href="/assets/js/273.5ad5777a.js"><link rel="prefetch" href="/assets/js/274.5a53ce2e.js"><link rel="prefetch" href="/assets/js/275.ff8aca6e.js"><link rel="prefetch" href="/assets/js/276.23f82257.js"><link rel="prefetch" href="/assets/js/277.a0eb933d.js"><link rel="prefetch" href="/assets/js/278.04a2d8c2.js"><link rel="prefetch" href="/assets/js/279.dc03e139.js"><link rel="prefetch" href="/assets/js/28.5b3cc2d3.js"><link rel="prefetch" href="/assets/js/280.0624848a.js"><link rel="prefetch" href="/assets/js/281.75119cde.js"><link rel="prefetch" href="/assets/js/282.0f3430a9.js"><link rel="prefetch" href="/assets/js/283.65b4ae1e.js"><link rel="prefetch" href="/assets/js/284.6688e48c.js"><link rel="prefetch" href="/assets/js/285.2de4d629.js"><link rel="prefetch" href="/assets/js/286.f864aee9.js"><link rel="prefetch" href="/assets/js/287.03f1df0d.js"><link rel="prefetch" href="/assets/js/288.c99a4e5d.js"><link rel="prefetch" href="/assets/js/289.af454a6d.js"><link rel="prefetch" href="/assets/js/29.e07e4e44.js"><link rel="prefetch" href="/assets/js/290.c2f353f2.js"><link rel="prefetch" href="/assets/js/291.634264d5.js"><link rel="prefetch" href="/assets/js/292.5b8c4942.js"><link rel="prefetch" href="/assets/js/293.6b02164f.js"><link rel="prefetch" href="/assets/js/294.ea3d6875.js"><link rel="prefetch" href="/assets/js/295.220833fc.js"><link rel="prefetch" href="/assets/js/296.0f1eff37.js"><link rel="prefetch" href="/assets/js/297.14f7ecdc.js"><link rel="prefetch" href="/assets/js/298.e484b35d.js"><link rel="prefetch" href="/assets/js/299.e4c7a66f.js"><link rel="prefetch" href="/assets/js/3.9e4d21bb.js"><link rel="prefetch" href="/assets/js/30.d9faff95.js"><link rel="prefetch" href="/assets/js/300.8b437400.js"><link rel="prefetch" href="/assets/js/301.1c41ec25.js"><link rel="prefetch" href="/assets/js/302.7f2d005d.js"><link rel="prefetch" href="/assets/js/303.75474a83.js"><link rel="prefetch" href="/assets/js/304.cd84ad51.js"><link rel="prefetch" href="/assets/js/305.073255fe.js"><link rel="prefetch" href="/assets/js/306.6cbb7a27.js"><link rel="prefetch" href="/assets/js/307.53c53c4a.js"><link rel="prefetch" href="/assets/js/308.88db279c.js"><link rel="prefetch" href="/assets/js/309.ccb0c11e.js"><link rel="prefetch" href="/assets/js/31.52dfa52c.js"><link rel="prefetch" href="/assets/js/310.cc8039da.js"><link rel="prefetch" href="/assets/js/311.1c7444d7.js"><link rel="prefetch" href="/assets/js/312.33bc64c4.js"><link rel="prefetch" href="/assets/js/313.4b3bc559.js"><link rel="prefetch" href="/assets/js/314.9bbe0567.js"><link rel="prefetch" href="/assets/js/315.60402672.js"><link rel="prefetch" href="/assets/js/316.cca2e6ac.js"><link rel="prefetch" href="/assets/js/317.a1808c73.js"><link rel="prefetch" href="/assets/js/318.63bbb317.js"><link rel="prefetch" href="/assets/js/319.31eb25c9.js"><link rel="prefetch" href="/assets/js/32.565509bf.js"><link rel="prefetch" href="/assets/js/320.ce03e90a.js"><link rel="prefetch" href="/assets/js/321.c86395d4.js"><link rel="prefetch" href="/assets/js/322.823093f6.js"><link rel="prefetch" href="/assets/js/323.b1e51f5e.js"><link rel="prefetch" href="/assets/js/324.4d7a824a.js"><link rel="prefetch" href="/assets/js/325.4080729d.js"><link rel="prefetch" href="/assets/js/326.da5958b2.js"><link rel="prefetch" href="/assets/js/327.b88e855f.js"><link rel="prefetch" href="/assets/js/328.3436f902.js"><link rel="prefetch" href="/assets/js/329.49b6984b.js"><link rel="prefetch" href="/assets/js/33.15fc9ca2.js"><link rel="prefetch" href="/assets/js/330.8f9921ea.js"><link rel="prefetch" href="/assets/js/331.7ba37316.js"><link rel="prefetch" href="/assets/js/332.e9b97590.js"><link rel="prefetch" href="/assets/js/333.4069c94c.js"><link rel="prefetch" href="/assets/js/334.aafafbea.js"><link rel="prefetch" href="/assets/js/335.aa512953.js"><link rel="prefetch" href="/assets/js/336.8dc5280e.js"><link rel="prefetch" href="/assets/js/337.b7b9a211.js"><link rel="prefetch" href="/assets/js/338.37229595.js"><link rel="prefetch" href="/assets/js/339.a9a56253.js"><link rel="prefetch" href="/assets/js/34.ab6d16c3.js"><link rel="prefetch" href="/assets/js/340.db0b2213.js"><link rel="prefetch" href="/assets/js/341.5900ef49.js"><link rel="prefetch" href="/assets/js/342.0ef63649.js"><link rel="prefetch" href="/assets/js/343.a7b47ae4.js"><link rel="prefetch" href="/assets/js/344.02c1d734.js"><link rel="prefetch" href="/assets/js/345.6a91a3ae.js"><link rel="prefetch" href="/assets/js/346.ef110a52.js"><link rel="prefetch" href="/assets/js/347.c0065538.js"><link rel="prefetch" href="/assets/js/348.4b0775b8.js"><link rel="prefetch" href="/assets/js/349.bb752afb.js"><link rel="prefetch" href="/assets/js/35.78d234d1.js"><link rel="prefetch" href="/assets/js/350.8a0906a4.js"><link rel="prefetch" href="/assets/js/351.fa514e3c.js"><link rel="prefetch" href="/assets/js/352.9edc99f5.js"><link rel="prefetch" href="/assets/js/353.4e70a911.js"><link rel="prefetch" href="/assets/js/354.c65566ac.js"><link rel="prefetch" href="/assets/js/355.584df7ad.js"><link rel="prefetch" href="/assets/js/356.7deb0823.js"><link rel="prefetch" href="/assets/js/357.2dca3772.js"><link rel="prefetch" href="/assets/js/358.8e260b27.js"><link rel="prefetch" href="/assets/js/359.5981e033.js"><link rel="prefetch" href="/assets/js/36.cc79b582.js"><link rel="prefetch" href="/assets/js/360.d79930ec.js"><link rel="prefetch" href="/assets/js/361.3ed8285c.js"><link rel="prefetch" href="/assets/js/362.1af41471.js"><link rel="prefetch" href="/assets/js/363.8cf9782f.js"><link rel="prefetch" href="/assets/js/364.f49aa6b9.js"><link rel="prefetch" href="/assets/js/365.f2e12d52.js"><link rel="prefetch" href="/assets/js/366.184e36f3.js"><link rel="prefetch" href="/assets/js/367.c18df423.js"><link rel="prefetch" href="/assets/js/368.0caff6d9.js"><link rel="prefetch" href="/assets/js/369.4239ae80.js"><link rel="prefetch" href="/assets/js/37.622e9e4c.js"><link rel="prefetch" href="/assets/js/370.7f7aa61a.js"><link rel="prefetch" href="/assets/js/371.2abe7083.js"><link rel="prefetch" href="/assets/js/372.a7682a64.js"><link rel="prefetch" href="/assets/js/373.6d8f51a8.js"><link rel="prefetch" href="/assets/js/374.dbd745f8.js"><link rel="prefetch" href="/assets/js/375.9459c372.js"><link rel="prefetch" href="/assets/js/376.d8ced089.js"><link rel="prefetch" href="/assets/js/377.164a042e.js"><link rel="prefetch" href="/assets/js/378.3b7cc5b0.js"><link rel="prefetch" href="/assets/js/379.69f7461e.js"><link rel="prefetch" href="/assets/js/38.4a5a53a9.js"><link rel="prefetch" href="/assets/js/380.373ff316.js"><link rel="prefetch" href="/assets/js/381.1f6dd312.js"><link rel="prefetch" href="/assets/js/382.b4b0afed.js"><link rel="prefetch" href="/assets/js/383.b5f38632.js"><link rel="prefetch" href="/assets/js/384.73d8ecc6.js"><link rel="prefetch" href="/assets/js/385.d1bc87af.js"><link rel="prefetch" href="/assets/js/386.9afe0665.js"><link rel="prefetch" href="/assets/js/387.aeaaa586.js"><link rel="prefetch" href="/assets/js/388.a47b0fbe.js"><link rel="prefetch" href="/assets/js/389.881abf34.js"><link rel="prefetch" href="/assets/js/39.ad1cf374.js"><link rel="prefetch" href="/assets/js/390.44eb0522.js"><link rel="prefetch" href="/assets/js/391.96435346.js"><link rel="prefetch" href="/assets/js/392.91ef3f2d.js"><link rel="prefetch" href="/assets/js/393.c127164f.js"><link rel="prefetch" href="/assets/js/394.0405a585.js"><link rel="prefetch" href="/assets/js/395.20999c6b.js"><link rel="prefetch" href="/assets/js/396.7668f8dc.js"><link rel="prefetch" href="/assets/js/397.5cafd4fe.js"><link rel="prefetch" href="/assets/js/398.e0931952.js"><link rel="prefetch" href="/assets/js/399.023f9208.js"><link rel="prefetch" href="/assets/js/40.831bdcbc.js"><link rel="prefetch" href="/assets/js/400.f27c70c4.js"><link rel="prefetch" href="/assets/js/401.b1b58e3b.js"><link rel="prefetch" href="/assets/js/402.a3acfdeb.js"><link rel="prefetch" href="/assets/js/403.0f511c08.js"><link rel="prefetch" href="/assets/js/404.8a8e251a.js"><link rel="prefetch" href="/assets/js/405.eae0cdd2.js"><link rel="prefetch" href="/assets/js/406.dbe8c52a.js"><link rel="prefetch" href="/assets/js/407.8c3078dc.js"><link rel="prefetch" href="/assets/js/408.7f61a319.js"><link rel="prefetch" href="/assets/js/409.670d5052.js"><link rel="prefetch" href="/assets/js/41.2c51c6f9.js"><link rel="prefetch" href="/assets/js/410.a476bcfd.js"><link rel="prefetch" href="/assets/js/411.8b0c802e.js"><link rel="prefetch" href="/assets/js/412.486cfd8f.js"><link rel="prefetch" href="/assets/js/413.4bd9384d.js"><link rel="prefetch" href="/assets/js/414.8ddeec60.js"><link rel="prefetch" href="/assets/js/415.a96f4e4a.js"><link rel="prefetch" href="/assets/js/416.06471c31.js"><link rel="prefetch" href="/assets/js/417.139b995c.js"><link rel="prefetch" href="/assets/js/418.6204b644.js"><link rel="prefetch" href="/assets/js/419.e6db2c5c.js"><link rel="prefetch" href="/assets/js/42.760f33b8.js"><link rel="prefetch" href="/assets/js/420.b792a98e.js"><link rel="prefetch" href="/assets/js/421.81fe29fd.js"><link rel="prefetch" href="/assets/js/422.4935c9dc.js"><link rel="prefetch" href="/assets/js/423.a07e06c6.js"><link rel="prefetch" href="/assets/js/424.5964c39d.js"><link rel="prefetch" href="/assets/js/425.c609ee9a.js"><link rel="prefetch" href="/assets/js/426.3d47f2a7.js"><link rel="prefetch" href="/assets/js/427.7821525a.js"><link rel="prefetch" href="/assets/js/428.e8f1ba67.js"><link rel="prefetch" href="/assets/js/429.af4850a4.js"><link rel="prefetch" href="/assets/js/43.089c4733.js"><link rel="prefetch" href="/assets/js/430.e701d9e2.js"><link rel="prefetch" href="/assets/js/431.d4399ff6.js"><link rel="prefetch" href="/assets/js/432.082b3af1.js"><link rel="prefetch" href="/assets/js/433.7632e83d.js"><link rel="prefetch" href="/assets/js/434.b6296507.js"><link rel="prefetch" href="/assets/js/435.b396785b.js"><link rel="prefetch" href="/assets/js/436.683db437.js"><link rel="prefetch" href="/assets/js/437.380e4333.js"><link rel="prefetch" href="/assets/js/438.1e42d6e4.js"><link rel="prefetch" href="/assets/js/439.5d7c4786.js"><link rel="prefetch" href="/assets/js/44.368e502f.js"><link rel="prefetch" href="/assets/js/440.7814207d.js"><link rel="prefetch" href="/assets/js/441.982bd339.js"><link rel="prefetch" href="/assets/js/442.5460e010.js"><link rel="prefetch" href="/assets/js/443.cc090615.js"><link rel="prefetch" href="/assets/js/444.2a55fa7a.js"><link rel="prefetch" href="/assets/js/445.6ebaf974.js"><link rel="prefetch" href="/assets/js/446.0ffe264b.js"><link rel="prefetch" href="/assets/js/447.11ef5105.js"><link rel="prefetch" href="/assets/js/448.d3053241.js"><link rel="prefetch" href="/assets/js/449.beb52bf5.js"><link rel="prefetch" href="/assets/js/45.2df76db4.js"><link rel="prefetch" href="/assets/js/450.1ae2460d.js"><link rel="prefetch" href="/assets/js/451.a03c3e3f.js"><link rel="prefetch" href="/assets/js/452.65e8cfe5.js"><link rel="prefetch" href="/assets/js/453.7a08dae2.js"><link rel="prefetch" href="/assets/js/454.a4f170ee.js"><link rel="prefetch" href="/assets/js/455.619aa69d.js"><link rel="prefetch" href="/assets/js/456.5d38cb9b.js"><link rel="prefetch" href="/assets/js/457.0b64c543.js"><link rel="prefetch" href="/assets/js/458.70a0c99a.js"><link rel="prefetch" href="/assets/js/459.70c29327.js"><link rel="prefetch" href="/assets/js/46.15735614.js"><link rel="prefetch" href="/assets/js/460.7c77bf61.js"><link rel="prefetch" href="/assets/js/461.6256ff42.js"><link rel="prefetch" href="/assets/js/462.38b7f94c.js"><link rel="prefetch" href="/assets/js/463.a5125523.js"><link rel="prefetch" href="/assets/js/464.9e82d503.js"><link rel="prefetch" href="/assets/js/465.c4ccc75a.js"><link rel="prefetch" href="/assets/js/466.aacb72c6.js"><link rel="prefetch" href="/assets/js/467.31690185.js"><link rel="prefetch" href="/assets/js/468.c69adba1.js"><link rel="prefetch" href="/assets/js/469.0c9556de.js"><link rel="prefetch" href="/assets/js/47.4530f341.js"><link rel="prefetch" href="/assets/js/470.fe6df2e5.js"><link rel="prefetch" href="/assets/js/471.af38bd27.js"><link rel="prefetch" href="/assets/js/472.34b3df20.js"><link rel="prefetch" href="/assets/js/473.10a98e1f.js"><link rel="prefetch" href="/assets/js/474.905c6d52.js"><link rel="prefetch" href="/assets/js/475.fdb94b90.js"><link rel="prefetch" href="/assets/js/476.af982523.js"><link rel="prefetch" href="/assets/js/477.da55d793.js"><link rel="prefetch" href="/assets/js/478.d8d5ab59.js"><link rel="prefetch" href="/assets/js/479.e43edf35.js"><link rel="prefetch" href="/assets/js/48.4166b99b.js"><link rel="prefetch" href="/assets/js/480.557e9421.js"><link rel="prefetch" href="/assets/js/481.e118564a.js"><link rel="prefetch" href="/assets/js/482.a4e2b1de.js"><link rel="prefetch" href="/assets/js/483.3badc62a.js"><link rel="prefetch" href="/assets/js/484.8fec18bc.js"><link rel="prefetch" href="/assets/js/485.79bab9a0.js"><link rel="prefetch" href="/assets/js/486.eca5aeee.js"><link rel="prefetch" href="/assets/js/487.e7bf3d9d.js"><link rel="prefetch" href="/assets/js/488.7c5c7232.js"><link rel="prefetch" href="/assets/js/489.e0f1ef84.js"><link rel="prefetch" href="/assets/js/49.81d63496.js"><link rel="prefetch" href="/assets/js/490.a044acb5.js"><link rel="prefetch" href="/assets/js/491.ea5f1339.js"><link rel="prefetch" href="/assets/js/492.a62e97dc.js"><link rel="prefetch" href="/assets/js/493.ba6a404c.js"><link rel="prefetch" href="/assets/js/494.69184b76.js"><link rel="prefetch" href="/assets/js/495.84fe0612.js"><link rel="prefetch" href="/assets/js/496.5f8ef791.js"><link rel="prefetch" href="/assets/js/497.e4069581.js"><link rel="prefetch" href="/assets/js/498.eb7db104.js"><link rel="prefetch" href="/assets/js/499.2878e24b.js"><link rel="prefetch" href="/assets/js/5.76b503e1.js"><link rel="prefetch" href="/assets/js/50.04d165ff.js"><link rel="prefetch" href="/assets/js/500.02fcc410.js"><link rel="prefetch" href="/assets/js/501.5690525b.js"><link rel="prefetch" href="/assets/js/502.e37f8b48.js"><link rel="prefetch" href="/assets/js/503.207090e5.js"><link rel="prefetch" href="/assets/js/504.ff47c19a.js"><link rel="prefetch" href="/assets/js/505.674dee0a.js"><link rel="prefetch" href="/assets/js/506.5de150d7.js"><link rel="prefetch" href="/assets/js/507.84c9483a.js"><link rel="prefetch" href="/assets/js/508.a4b8cfca.js"><link rel="prefetch" href="/assets/js/509.5d5c228f.js"><link rel="prefetch" href="/assets/js/51.5195c7c2.js"><link rel="prefetch" href="/assets/js/510.cb47935d.js"><link rel="prefetch" href="/assets/js/511.f6e90ee3.js"><link rel="prefetch" href="/assets/js/512.2e0aedce.js"><link rel="prefetch" href="/assets/js/513.72c4f67c.js"><link rel="prefetch" href="/assets/js/514.0e0cb0cf.js"><link rel="prefetch" href="/assets/js/515.3c0e6761.js"><link rel="prefetch" href="/assets/js/516.21977521.js"><link rel="prefetch" href="/assets/js/517.b760c848.js"><link rel="prefetch" href="/assets/js/518.4103ffb6.js"><link rel="prefetch" href="/assets/js/519.d1888289.js"><link rel="prefetch" href="/assets/js/52.4e460982.js"><link rel="prefetch" href="/assets/js/520.2960881f.js"><link rel="prefetch" href="/assets/js/521.79c2a99f.js"><link rel="prefetch" href="/assets/js/522.5a9110b8.js"><link rel="prefetch" href="/assets/js/523.a06b1a9d.js"><link rel="prefetch" href="/assets/js/524.28a9b4f3.js"><link rel="prefetch" href="/assets/js/525.aa5f2d06.js"><link rel="prefetch" href="/assets/js/526.6b9be335.js"><link rel="prefetch" href="/assets/js/527.c5bb34e4.js"><link rel="prefetch" href="/assets/js/528.d5baf785.js"><link rel="prefetch" href="/assets/js/529.555ff182.js"><link rel="prefetch" href="/assets/js/53.eab5ba3c.js"><link rel="prefetch" href="/assets/js/530.90312751.js"><link rel="prefetch" href="/assets/js/531.ce0feeea.js"><link rel="prefetch" href="/assets/js/532.cb77be31.js"><link rel="prefetch" href="/assets/js/533.0b9ad72e.js"><link rel="prefetch" href="/assets/js/534.d078ce43.js"><link rel="prefetch" href="/assets/js/535.41cc8610.js"><link rel="prefetch" href="/assets/js/536.320c8ce4.js"><link rel="prefetch" href="/assets/js/537.986d5ef6.js"><link rel="prefetch" href="/assets/js/538.ecbc2f4f.js"><link rel="prefetch" href="/assets/js/539.62894144.js"><link rel="prefetch" href="/assets/js/54.127cf826.js"><link rel="prefetch" href="/assets/js/540.32367583.js"><link rel="prefetch" href="/assets/js/541.024aac9e.js"><link rel="prefetch" href="/assets/js/542.102286c0.js"><link rel="prefetch" href="/assets/js/543.630e7145.js"><link rel="prefetch" href="/assets/js/544.7fa29d66.js"><link rel="prefetch" href="/assets/js/545.8c7eb500.js"><link rel="prefetch" href="/assets/js/546.e85865fe.js"><link rel="prefetch" href="/assets/js/547.ceafba50.js"><link rel="prefetch" href="/assets/js/548.03098f64.js"><link rel="prefetch" href="/assets/js/549.ecbe6f6b.js"><link rel="prefetch" href="/assets/js/55.5b77e2ab.js"><link rel="prefetch" href="/assets/js/550.9a8ed462.js"><link rel="prefetch" href="/assets/js/551.63465532.js"><link rel="prefetch" href="/assets/js/552.a1c8bdb9.js"><link rel="prefetch" href="/assets/js/553.eb0217a1.js"><link rel="prefetch" href="/assets/js/554.324e2aed.js"><link rel="prefetch" href="/assets/js/555.dd3bc1f0.js"><link rel="prefetch" href="/assets/js/556.6b132cb6.js"><link rel="prefetch" href="/assets/js/557.3b283468.js"><link rel="prefetch" href="/assets/js/558.020850b6.js"><link rel="prefetch" href="/assets/js/559.c35f4fda.js"><link rel="prefetch" href="/assets/js/56.57a90f60.js"><link rel="prefetch" href="/assets/js/560.ceb8595e.js"><link rel="prefetch" href="/assets/js/561.ce8e82d1.js"><link rel="prefetch" href="/assets/js/562.f1e4dac3.js"><link rel="prefetch" href="/assets/js/563.2eae2a04.js"><link rel="prefetch" href="/assets/js/564.0033c677.js"><link rel="prefetch" href="/assets/js/565.7ed2f264.js"><link rel="prefetch" href="/assets/js/566.4a021563.js"><link rel="prefetch" href="/assets/js/567.ce33215e.js"><link rel="prefetch" href="/assets/js/568.512a4751.js"><link rel="prefetch" href="/assets/js/569.0809b0af.js"><link rel="prefetch" href="/assets/js/57.50aca8ae.js"><link rel="prefetch" href="/assets/js/570.ec876a82.js"><link rel="prefetch" href="/assets/js/571.8154bae6.js"><link rel="prefetch" href="/assets/js/572.a9594db9.js"><link rel="prefetch" href="/assets/js/573.823c7998.js"><link rel="prefetch" href="/assets/js/574.27090b44.js"><link rel="prefetch" href="/assets/js/575.d19c72b7.js"><link rel="prefetch" href="/assets/js/576.fdb40173.js"><link rel="prefetch" href="/assets/js/577.0bcd0232.js"><link rel="prefetch" href="/assets/js/578.7f7dbdd2.js"><link rel="prefetch" href="/assets/js/579.18c76171.js"><link rel="prefetch" href="/assets/js/58.e97ba415.js"><link rel="prefetch" href="/assets/js/580.f864dac6.js"><link rel="prefetch" href="/assets/js/581.dfbc336d.js"><link rel="prefetch" href="/assets/js/582.0cb0c5c8.js"><link rel="prefetch" href="/assets/js/583.048d9317.js"><link rel="prefetch" href="/assets/js/584.e26ee41a.js"><link rel="prefetch" href="/assets/js/585.cf856133.js"><link rel="prefetch" href="/assets/js/586.659a6441.js"><link rel="prefetch" href="/assets/js/587.95791f09.js"><link rel="prefetch" href="/assets/js/588.1ac9fea3.js"><link rel="prefetch" href="/assets/js/589.6cb2fc76.js"><link rel="prefetch" href="/assets/js/59.5d5a6113.js"><link rel="prefetch" href="/assets/js/590.31262cf1.js"><link rel="prefetch" href="/assets/js/591.8b718ff1.js"><link rel="prefetch" href="/assets/js/592.8e78c3fd.js"><link rel="prefetch" href="/assets/js/593.892fbec0.js"><link rel="prefetch" href="/assets/js/594.5560ec5c.js"><link rel="prefetch" href="/assets/js/595.df222b64.js"><link rel="prefetch" href="/assets/js/596.7d1025ae.js"><link rel="prefetch" href="/assets/js/597.63cc8434.js"><link rel="prefetch" href="/assets/js/598.0e145475.js"><link rel="prefetch" href="/assets/js/599.4a6bef64.js"><link rel="prefetch" href="/assets/js/6.12098075.js"><link rel="prefetch" href="/assets/js/60.01501a1c.js"><link rel="prefetch" href="/assets/js/600.351e527b.js"><link rel="prefetch" href="/assets/js/601.ba864b7d.js"><link rel="prefetch" href="/assets/js/602.b7245a2b.js"><link rel="prefetch" href="/assets/js/603.cc02fd24.js"><link rel="prefetch" href="/assets/js/604.7a36a384.js"><link rel="prefetch" href="/assets/js/605.5d0a7525.js"><link rel="prefetch" href="/assets/js/606.2ac5fdfc.js"><link rel="prefetch" href="/assets/js/607.eb07f64e.js"><link rel="prefetch" href="/assets/js/608.9af36980.js"><link rel="prefetch" href="/assets/js/609.286ef8a5.js"><link rel="prefetch" href="/assets/js/61.e2299498.js"><link rel="prefetch" href="/assets/js/610.8c2ee0c2.js"><link rel="prefetch" href="/assets/js/611.83eb0fbe.js"><link rel="prefetch" href="/assets/js/612.b20e3727.js"><link rel="prefetch" href="/assets/js/613.0d29d6b6.js"><link rel="prefetch" href="/assets/js/614.a24ceda4.js"><link rel="prefetch" href="/assets/js/615.fed3fde8.js"><link rel="prefetch" href="/assets/js/616.b3ababb3.js"><link rel="prefetch" href="/assets/js/617.30f0d2d1.js"><link rel="prefetch" href="/assets/js/618.972835c6.js"><link rel="prefetch" href="/assets/js/619.d245c522.js"><link rel="prefetch" href="/assets/js/62.4117a49e.js"><link rel="prefetch" href="/assets/js/620.72ad4151.js"><link rel="prefetch" href="/assets/js/621.a76e93e1.js"><link rel="prefetch" href="/assets/js/622.b3e34ee1.js"><link rel="prefetch" href="/assets/js/623.d86b1d32.js"><link rel="prefetch" href="/assets/js/624.d92b7f9c.js"><link rel="prefetch" href="/assets/js/625.76f4d040.js"><link rel="prefetch" href="/assets/js/626.aee965ff.js"><link rel="prefetch" href="/assets/js/627.22851b74.js"><link rel="prefetch" href="/assets/js/628.8ebc21af.js"><link rel="prefetch" href="/assets/js/629.586bed6b.js"><link rel="prefetch" href="/assets/js/63.f9fd30e1.js"><link rel="prefetch" href="/assets/js/630.93d4398e.js"><link rel="prefetch" href="/assets/js/631.b7930642.js"><link rel="prefetch" href="/assets/js/632.7d0006f2.js"><link rel="prefetch" href="/assets/js/633.764b0cfc.js"><link rel="prefetch" href="/assets/js/634.0380a119.js"><link rel="prefetch" href="/assets/js/635.32c7094f.js"><link rel="prefetch" href="/assets/js/636.f5956027.js"><link rel="prefetch" href="/assets/js/637.5488f6bd.js"><link rel="prefetch" href="/assets/js/638.969c2f24.js"><link rel="prefetch" href="/assets/js/639.e7e755b3.js"><link rel="prefetch" href="/assets/js/64.4ac90f05.js"><link rel="prefetch" href="/assets/js/640.407a9d09.js"><link rel="prefetch" href="/assets/js/641.70a4b071.js"><link rel="prefetch" href="/assets/js/642.31797c76.js"><link rel="prefetch" href="/assets/js/643.7b2df57d.js"><link rel="prefetch" href="/assets/js/644.2abc1cbb.js"><link rel="prefetch" href="/assets/js/645.854855ea.js"><link rel="prefetch" href="/assets/js/646.a578053d.js"><link rel="prefetch" href="/assets/js/647.a68a50ee.js"><link rel="prefetch" href="/assets/js/648.1adc9f90.js"><link rel="prefetch" href="/assets/js/649.4767e979.js"><link rel="prefetch" href="/assets/js/65.2922cd08.js"><link rel="prefetch" href="/assets/js/650.1ab9176e.js"><link rel="prefetch" href="/assets/js/651.ef13dc94.js"><link rel="prefetch" href="/assets/js/652.f07177e5.js"><link rel="prefetch" href="/assets/js/653.b6303e89.js"><link rel="prefetch" href="/assets/js/654.4b908815.js"><link rel="prefetch" href="/assets/js/655.424f9113.js"><link rel="prefetch" href="/assets/js/656.36b07e30.js"><link rel="prefetch" href="/assets/js/657.2d59d758.js"><link rel="prefetch" href="/assets/js/658.578b6524.js"><link rel="prefetch" href="/assets/js/659.766ec39b.js"><link rel="prefetch" href="/assets/js/66.66b1d279.js"><link rel="prefetch" href="/assets/js/660.b79e4dc1.js"><link rel="prefetch" href="/assets/js/661.a5f9cec2.js"><link rel="prefetch" href="/assets/js/662.6c9d8314.js"><link rel="prefetch" href="/assets/js/67.5ae6b218.js"><link rel="prefetch" href="/assets/js/68.795d79ad.js"><link rel="prefetch" href="/assets/js/69.5bdde135.js"><link rel="prefetch" href="/assets/js/7.3d0c5913.js"><link rel="prefetch" href="/assets/js/71.9e00953e.js"><link rel="prefetch" href="/assets/js/72.c0ddcce8.js"><link rel="prefetch" href="/assets/js/73.1e24f9f9.js"><link rel="prefetch" href="/assets/js/74.b028e062.js"><link rel="prefetch" href="/assets/js/75.c169b28f.js"><link rel="prefetch" href="/assets/js/76.84a849b5.js"><link rel="prefetch" href="/assets/js/77.5e6c0be8.js"><link rel="prefetch" href="/assets/js/78.a175cc25.js"><link rel="prefetch" href="/assets/js/79.c87c3d76.js"><link rel="prefetch" href="/assets/js/8.a85751f4.js"><link rel="prefetch" href="/assets/js/80.6be2eeb5.js"><link rel="prefetch" href="/assets/js/81.d559723e.js"><link rel="prefetch" href="/assets/js/82.939f3dce.js"><link rel="prefetch" href="/assets/js/83.3edb8c35.js"><link rel="prefetch" href="/assets/js/84.8736f15e.js"><link rel="prefetch" href="/assets/js/85.284b0482.js"><link rel="prefetch" href="/assets/js/86.65b2fadc.js"><link rel="prefetch" href="/assets/js/87.bfff11e1.js"><link rel="prefetch" href="/assets/js/88.5cc13175.js"><link rel="prefetch" href="/assets/js/89.0ce27864.js"><link rel="prefetch" href="/assets/js/9.6241637e.js"><link rel="prefetch" href="/assets/js/90.77514cbc.js"><link rel="prefetch" href="/assets/js/91.a1088239.js"><link rel="prefetch" href="/assets/js/92.008712ca.js"><link rel="prefetch" href="/assets/js/93.24476fa0.js"><link rel="prefetch" href="/assets/js/94.615db4ff.js"><link rel="prefetch" href="/assets/js/95.cfc893b1.js"><link rel="prefetch" href="/assets/js/96.998a3789.js"><link rel="prefetch" href="/assets/js/97.c03f2edd.js"><link rel="prefetch" href="/assets/js/98.c9d692dd.js"><link rel="prefetch" href="/assets/js/99.f6ecd156.js">
    <link rel="stylesheet" href="/assets/css/0.styles.c35b53db.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/e-logo-head.png" alt="Cyan's blog" class="logo"> <span class="site-name can-hide">Cyan's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/overview/" class="nav-link">导读</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><a href="/java/" class="link-title">Java</a> <span class="title" style="display:none;">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Java基础 - 基础知识</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/overview/#面向对象与java基础" class="nav-link">基础知识 - 导读</a></li><li class="dropdown-subitem"><a href="/pages/java-basic-oop/" class="nav-link">面向对象</a></li><li class="dropdown-subitem"><a href="/pages/java-basic-lan-basic/" class="nav-link">知识点</a></li></ul></li><li class="dropdown-item"><h4>Java进阶 - 集合框架</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/overview/#java进阶-集合框架" class="nav-link">集合框架 - 导读</a></li><li class="dropdown-subitem"><a href="/pages/java-collection-overview/" class="nav-link">Collection - 类关系图</a></li></ul></li><li class="dropdown-item"><h4>Java进阶 - 并发框架</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/java-thread-x-overview/" class="nav-link">并发框架 - 导读</a></li><li class="dropdown-subitem"><a href="/pages/java-thread-x-theorty/" class="nav-link">Java 并发 - 理论基础</a></li><li class="dropdown-subitem"><a href="/pages/java-thread-x-thread-basic/" class="nav-link">Java 并发 - 线程基础</a></li><li class="dropdown-subitem"><a href="/pages/java-thread-x-juc-overview/" class="nav-link">JUC - 类汇总</a></li></ul></li><li class="dropdown-item"><h4>Java进阶 - IO框架</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/java-io-overview/" class="nav-link">IO框架 - 导读</a></li><li class="dropdown-subitem"><a href="/pages/java-io-basic-usage/" class="nav-link">IO 基础</a></li><li class="dropdown-subitem"><a href="/pages/java-io-bio/" class="nav-link">BIO 基础</a></li><li class="dropdown-subitem"><a href="/pages/java-io-nio/" class="nav-link">NIO 基础</a></li><li class="dropdown-subitem"><a href="/pages/java-io-aio/" class="nav-link">AIO 基础</a></li></ul></li><li class="dropdown-item"><h4>Java进阶 - JVM相关</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/java-jvm-overview/" class="nav-link">JVM相关 - 导读</a></li><li class="dropdown-subitem"><a href="/pages/java-jvm-class/" class="nav-link">Java 类字节码</a></li><li class="dropdown-subitem"><a href="/pages/java-jvm-jmm/" class="nav-link">JVM 内存模型</a></li><li class="dropdown-subitem"><a href="/pages/java-jvm-gc/" class="nav-link">JVM 垃圾回收</a></li><li class="dropdown-subitem"><a href="/pages/java-jvm-param/" class="nav-link">Java 调试排错</a></li></ul></li><li class="dropdown-item"><h4>Java进阶 - 新版本特性</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/java8-overview/" class="nav-link">java 8 新特性 - 导读</a></li><li class="dropdown-subitem"><a href="/pages/java8+-overview/" class="nav-link">Java 8+ 特性 - 导读</a></li><li class="dropdown-subitem"><a href="/pages/java9-11/" class="nav-link">Java 8 升Java 11 重要特性 - 必读</a></li><li class="dropdown-subitem"><a href="/pages/java12-17/" class="nav-link">Java 11 升Java 17 重要特性 - 必读</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法" class="dropdown-title"><a href="/algorithm/" class="link-title">算法</a> <span class="title" style="display:none;">算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>基础算法</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/alg-basic-overview/" class="nav-link">数据结构基础 - 导读</a></li><li class="dropdown-subitem"><a href="/pages/ef847c/" class="nav-link">数据结构进阶 - 导读</a></li><li class="dropdown-subitem"><a href="/pages/alg-sort-overview/" class="nav-link">常见排序算法 - 导读</a></li><li class="dropdown-subitem"><a href="/pages/alg-core-overview/" class="nav-link">算法思想 - 导读</a></li></ul></li><li class="dropdown-item"><h4>领域算法</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/alg-domain-overview/" class="nav-link">领域算法 - 导读</a></li><li class="dropdown-subitem"><a href="/pages/alg-domain-security-degist/" class="nav-link">安全算法</a></li><li class="dropdown-subitem"><a href="/pages/alg-domain-char-match-overview/" class="nav-link">字符串匹配算法</a></li><li class="dropdown-subitem"><a href="/pages/alg-domain-bigdata-overview/" class="nav-link">大数据处理算法</a></li><li class="dropdown-subitem"><a href="/pages/alg-domain-distribute-overview/" class="nav-link">分布式系统算法</a></li><li class="dropdown-subitem"><a href="/pages/alg-other-mind/" class="nav-link">其它算法相关</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><a href="/database/" class="link-title">数据库</a> <span class="title" style="display:none;">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>数据库基础与原理</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/db-sql-overview/" class="nav-link">数据库基础和SQL - 导读</a></li></ul></li><li class="dropdown-item"><h4>SQL 数据库 </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/db-mysql-overview/" class="nav-link">MySQL - 导读</a></li></ul></li><li class="dropdown-item"><h4>NoSQL 数据库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/db-redis-overview/" class="nav-link">Redis - 导读</a></li><li class="dropdown-subitem"><a href="/pages/db-mongo-overview/" class="nav-link">MongoDB - 导读</a></li><li class="dropdown-subitem"><a href="/pages/db-es-overview/" class="nav-link">ElasticSearch - 导读</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="系统开发" class="dropdown-title"><a href="/devsys/" class="link-title">系统开发</a> <span class="title" style="display:none;">系统开发</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/dev-package-overview/" class="nav-link">常用类库 - 导读</a></li><li class="dropdown-item"><!----> <a href="/pages/dev-qt-overview/" class="nav-link">代码质量 - 导读</a></li><li class="dropdown-item"><!----> <a href="/pages/dev-protocol-overview/" class="nav-link">网络协议 - 导读</a></li><li class="dropdown-item"><!----> <a href="/pages/dev-security-overview/" class="nav-link">开发安全 - 导读</a></li><li class="dropdown-item"><!----> <a href="/pages/dev-regex-usage/" class="nav-link">常用技巧 - 正则表达式</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据开发" class="dropdown-title"><a href="/devdata/" class="link-title">数据开发</a> <span class="title" style="display:none;">数据开发</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/6de9b5/" class="nav-link">数据资产化及入表</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="架构" class="dropdown-title"><a href="/architecture/" class="link-title">架构</a> <span class="title" style="display:none;">架构</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/arch-overview/" class="nav-link">架构基础 导读</a></li><li class="dropdown-item"><!----> <a href="/pages/arch-d-overview/" class="nav-link">分布式系统 导读</a></li><li class="dropdown-item"><!----> <a href="/pages/arch-m-overview/" class="nav-link">微服务系统 导读</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="方法论" class="dropdown-title"><a href="/theory/" class="link-title">方法论</a> <span class="title" style="display:none;">方法论</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/dev-th-overview/" class="nav-link">开发理论 导读</a></li><li class="dropdown-item"><!----> <a href="/pages/dev-open-overview/" class="nav-link">开源协议 导读</a></li><li class="dropdown-item"><!----> <a href="/pages/dev-code-style-overview/" class="nav-link">代码规范 导读</a></li><li class="dropdown-item"><!----> <a href="/pages/dev-agile-overview/" class="nav-link">开发流程 导读</a></li><li class="dropdown-item"><!----> <a href="/pages/dev-pattern-overview/" class="nav-link">设计模式 导读</a></li><li class="dropdown-item"><!----> <a href="/pages/dev-cart-overview/" class="nav-link">系统认证 导读</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具箱" class="dropdown-title"><a href="/tools/" class="link-title">工具箱</a> <span class="title" style="display:none;">工具箱</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>百宝箱</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/tool-resource/" class="nav-link">百宝箱</a></li></ul></li><li class="dropdown-item"><h4>官方文档</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/tool-tech-doc/" class="nav-link">官方文档</a></li></ul></li><li class="dropdown-item"><h4>常用开发工具</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/tool-git/" class="nav-link">Git</a></li><li class="dropdown-subitem"><a href="/pages/tool-markdown/" class="nav-link">Markdown</a></li></ul></li><li class="dropdown-item"><h4>前端开发工具</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/tool-fe-com/" class="nav-link">常用前端工具</a></li><li class="dropdown-subitem"><a href="/pages/tool-npm/" class="nav-link">npm</a></li><li class="dropdown-subitem"><a href="/pages/tool-yaml/" class="nav-link">yaml</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目" class="dropdown-title"><a href="/project/" class="link-title">项目</a> <span class="title" style="display:none;">项目</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">他山之玉-研学</a></li><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">可以攻石-实战</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/pages/576b1f/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li></ul></div></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/willpast/willpast.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/e-logo.png"> <div class="blogger-info"><h3>Cyan</h3> <span>This too shall pass</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/overview/" class="nav-link">导读</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><a href="/java/" class="link-title">Java</a> <span class="title" style="display:none;">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Java基础 - 基础知识</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/overview/#面向对象与java基础" class="nav-link">基础知识 - 导读</a></li><li class="dropdown-subitem"><a href="/pages/java-basic-oop/" class="nav-link">面向对象</a></li><li class="dropdown-subitem"><a href="/pages/java-basic-lan-basic/" class="nav-link">知识点</a></li></ul></li><li class="dropdown-item"><h4>Java进阶 - 集合框架</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/overview/#java进阶-集合框架" class="nav-link">集合框架 - 导读</a></li><li class="dropdown-subitem"><a href="/pages/java-collection-overview/" class="nav-link">Collection - 类关系图</a></li></ul></li><li class="dropdown-item"><h4>Java进阶 - 并发框架</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/java-thread-x-overview/" class="nav-link">并发框架 - 导读</a></li><li class="dropdown-subitem"><a href="/pages/java-thread-x-theorty/" class="nav-link">Java 并发 - 理论基础</a></li><li class="dropdown-subitem"><a href="/pages/java-thread-x-thread-basic/" class="nav-link">Java 并发 - 线程基础</a></li><li class="dropdown-subitem"><a href="/pages/java-thread-x-juc-overview/" class="nav-link">JUC - 类汇总</a></li></ul></li><li class="dropdown-item"><h4>Java进阶 - IO框架</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/java-io-overview/" class="nav-link">IO框架 - 导读</a></li><li class="dropdown-subitem"><a href="/pages/java-io-basic-usage/" class="nav-link">IO 基础</a></li><li class="dropdown-subitem"><a href="/pages/java-io-bio/" class="nav-link">BIO 基础</a></li><li class="dropdown-subitem"><a href="/pages/java-io-nio/" class="nav-link">NIO 基础</a></li><li class="dropdown-subitem"><a href="/pages/java-io-aio/" class="nav-link">AIO 基础</a></li></ul></li><li class="dropdown-item"><h4>Java进阶 - JVM相关</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/java-jvm-overview/" class="nav-link">JVM相关 - 导读</a></li><li class="dropdown-subitem"><a href="/pages/java-jvm-class/" class="nav-link">Java 类字节码</a></li><li class="dropdown-subitem"><a href="/pages/java-jvm-jmm/" class="nav-link">JVM 内存模型</a></li><li class="dropdown-subitem"><a href="/pages/java-jvm-gc/" class="nav-link">JVM 垃圾回收</a></li><li class="dropdown-subitem"><a href="/pages/java-jvm-param/" class="nav-link">Java 调试排错</a></li></ul></li><li class="dropdown-item"><h4>Java进阶 - 新版本特性</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/java8-overview/" class="nav-link">java 8 新特性 - 导读</a></li><li class="dropdown-subitem"><a href="/pages/java8+-overview/" class="nav-link">Java 8+ 特性 - 导读</a></li><li class="dropdown-subitem"><a href="/pages/java9-11/" class="nav-link">Java 8 升Java 11 重要特性 - 必读</a></li><li class="dropdown-subitem"><a href="/pages/java12-17/" class="nav-link">Java 11 升Java 17 重要特性 - 必读</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法" class="dropdown-title"><a href="/algorithm/" class="link-title">算法</a> <span class="title" style="display:none;">算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>基础算法</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/alg-basic-overview/" class="nav-link">数据结构基础 - 导读</a></li><li class="dropdown-subitem"><a href="/pages/ef847c/" class="nav-link">数据结构进阶 - 导读</a></li><li class="dropdown-subitem"><a href="/pages/alg-sort-overview/" class="nav-link">常见排序算法 - 导读</a></li><li class="dropdown-subitem"><a href="/pages/alg-core-overview/" class="nav-link">算法思想 - 导读</a></li></ul></li><li class="dropdown-item"><h4>领域算法</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/alg-domain-overview/" class="nav-link">领域算法 - 导读</a></li><li class="dropdown-subitem"><a href="/pages/alg-domain-security-degist/" class="nav-link">安全算法</a></li><li class="dropdown-subitem"><a href="/pages/alg-domain-char-match-overview/" class="nav-link">字符串匹配算法</a></li><li class="dropdown-subitem"><a href="/pages/alg-domain-bigdata-overview/" class="nav-link">大数据处理算法</a></li><li class="dropdown-subitem"><a href="/pages/alg-domain-distribute-overview/" class="nav-link">分布式系统算法</a></li><li class="dropdown-subitem"><a href="/pages/alg-other-mind/" class="nav-link">其它算法相关</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><a href="/database/" class="link-title">数据库</a> <span class="title" style="display:none;">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>数据库基础与原理</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/db-sql-overview/" class="nav-link">数据库基础和SQL - 导读</a></li></ul></li><li class="dropdown-item"><h4>SQL 数据库 </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/db-mysql-overview/" class="nav-link">MySQL - 导读</a></li></ul></li><li class="dropdown-item"><h4>NoSQL 数据库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/db-redis-overview/" class="nav-link">Redis - 导读</a></li><li class="dropdown-subitem"><a href="/pages/db-mongo-overview/" class="nav-link">MongoDB - 导读</a></li><li class="dropdown-subitem"><a href="/pages/db-es-overview/" class="nav-link">ElasticSearch - 导读</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="系统开发" class="dropdown-title"><a href="/devsys/" class="link-title">系统开发</a> <span class="title" style="display:none;">系统开发</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/dev-package-overview/" class="nav-link">常用类库 - 导读</a></li><li class="dropdown-item"><!----> <a href="/pages/dev-qt-overview/" class="nav-link">代码质量 - 导读</a></li><li class="dropdown-item"><!----> <a href="/pages/dev-protocol-overview/" class="nav-link">网络协议 - 导读</a></li><li class="dropdown-item"><!----> <a href="/pages/dev-security-overview/" class="nav-link">开发安全 - 导读</a></li><li class="dropdown-item"><!----> <a href="/pages/dev-regex-usage/" class="nav-link">常用技巧 - 正则表达式</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据开发" class="dropdown-title"><a href="/devdata/" class="link-title">数据开发</a> <span class="title" style="display:none;">数据开发</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/6de9b5/" class="nav-link">数据资产化及入表</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="架构" class="dropdown-title"><a href="/architecture/" class="link-title">架构</a> <span class="title" style="display:none;">架构</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/arch-overview/" class="nav-link">架构基础 导读</a></li><li class="dropdown-item"><!----> <a href="/pages/arch-d-overview/" class="nav-link">分布式系统 导读</a></li><li class="dropdown-item"><!----> <a href="/pages/arch-m-overview/" class="nav-link">微服务系统 导读</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="方法论" class="dropdown-title"><a href="/theory/" class="link-title">方法论</a> <span class="title" style="display:none;">方法论</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/dev-th-overview/" class="nav-link">开发理论 导读</a></li><li class="dropdown-item"><!----> <a href="/pages/dev-open-overview/" class="nav-link">开源协议 导读</a></li><li class="dropdown-item"><!----> <a href="/pages/dev-code-style-overview/" class="nav-link">代码规范 导读</a></li><li class="dropdown-item"><!----> <a href="/pages/dev-agile-overview/" class="nav-link">开发流程 导读</a></li><li class="dropdown-item"><!----> <a href="/pages/dev-pattern-overview/" class="nav-link">设计模式 导读</a></li><li class="dropdown-item"><!----> <a href="/pages/dev-cart-overview/" class="nav-link">系统认证 导读</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具箱" class="dropdown-title"><a href="/tools/" class="link-title">工具箱</a> <span class="title" style="display:none;">工具箱</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>百宝箱</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/tool-resource/" class="nav-link">百宝箱</a></li></ul></li><li class="dropdown-item"><h4>官方文档</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/tool-tech-doc/" class="nav-link">官方文档</a></li></ul></li><li class="dropdown-item"><h4>常用开发工具</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/tool-git/" class="nav-link">Git</a></li><li class="dropdown-subitem"><a href="/pages/tool-markdown/" class="nav-link">Markdown</a></li></ul></li><li class="dropdown-item"><h4>前端开发工具</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/tool-fe-com/" class="nav-link">常用前端工具</a></li><li class="dropdown-subitem"><a href="/pages/tool-npm/" class="nav-link">npm</a></li><li class="dropdown-subitem"><a href="/pages/tool-yaml/" class="nav-link">yaml</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目" class="dropdown-title"><a href="/project/" class="link-title">项目</a> <span class="title" style="display:none;">项目</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">他山之玉-研学</a></li><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">可以攻石-实战</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/pages/576b1f/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li></ul></div></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/willpast/willpast.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java集合</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>多线程与并发</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/java-thread-x-overview/" class="sidebar-link">♥Java并发知识体系导读♥</a></li><li><a href="/pages/java-thread-x-theorty/" class="sidebar-link">Java并发 - 理论基础</a></li><li><a href="/pages/java-thread-x-thread-basic/" class="sidebar-link">Java并发 - 线程基础</a></li><li><a href="/pages/java-thread-x-lock-all/" class="sidebar-link">Java并发 - Java中所有的锁</a></li><li><a href="/pages/java-thread-x-threadlocal/" class="sidebar-link">Java并发 - ThreadLocal详解</a></li><li><a href="/pages/java-thread-y-threadlocal-interview/" class="sidebar-link">Java并发 - ThreadLocal面试场景</a></li><li><a href="/pages/java-thread-y-thread-communication/" class="sidebar-link">Java并发 - Java线程通信方式</a></li><li><a href="/pages/java-thread-y-async/" class="sidebar-link">Java并发 - 异步编程</a></li><li><a href="/pages/java-thread-x-key-synchronized/" class="sidebar-link">关键字 - synchronized详解</a></li><li><a href="/pages/java-thread-x-key-volatile/" class="sidebar-link">关键字 - volatile详解</a></li><li><a href="/pages/java-thread-x-key-final/" class="sidebar-link">关键字 - final详解</a></li><li><a href="/pages/java-thread-x-juc-overview/" class="sidebar-link">JUC - 类汇总和学习指南</a></li><li><a href="/pages/java-thread-x-juc-AtomicInteger/" class="sidebar-link">JUC原子类 - CAS,Unsafe和原子类</a></li><li><a href="/pages/java-thread-x-lock-LockSupport/" class="sidebar-link">JUC锁 - LockSupport详解</a></li><li><a href="/pages/java-thread-x-lock-AbstractQueuedSynchronizer/" class="sidebar-link">JUC锁 - 锁核心类AQS详解</a></li><li><a href="/pages/java-thread-x-lock-ReentrantLock/" class="sidebar-link">JUC锁 - ReentrantLock详解</a></li><li><a href="/pages/java-thread-x-lock-ReentrantReadWriteLock/" class="sidebar-link">JUC锁 - ReentrantReadWriteLock详解</a></li><li><a href="/pages/java-thread-x-juc-collection-ConcurrentHashMap/" class="sidebar-link">JUC集合 - ConcurrentHashMap详解</a></li><li><a href="/pages/java-thread-x-juc-collection-CopyOnWriteArrayList/" class="sidebar-link">JUC集合 - CopyOnWriteArrayList详解</a></li><li><a href="/pages/java-thread-x-juc-collection-ConcurrentLinkedQueue/" class="sidebar-link">JUC集合 - ConcurrentLinkedQueue详解</a></li><li><a href="/pages/java-thread-x-juc-collection-BlockingQueue/" class="sidebar-link">JUC集合 - BlockingQueue详解</a></li><li><a href="/pages/java-thread-x-juc-collection-ConcurrentHashMap-tryPresize/" class="sidebar-link">JUC集合 - ConcurrentHashMap扩容</a></li><li><a href="/pages/java-thread-x-juc-executor-FutureTask/" class="sidebar-link">JUC线程池 - FutureTask详解</a></li><li><a href="/pages/java-thread-x-juc-executor-ThreadPoolExecutor/" class="sidebar-link">JUC线程池 - ThreadPoolExecutor详解</a></li><li><a href="/pages/java-thread-x-juc-executor-ScheduledThreadPoolExecutor/" class="sidebar-link">JUC线程池 - ScheduledThreadPoolExecutor详解</a></li><li><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/" aria-current="page" class="active sidebar-link">JUC线程池 - Fork/Join框架详解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#思考" class="sidebar-link">思考</a></li><li class="sidebar-sub-header level2"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#fork-join框架简介" class="sidebar-link">Fork/Join框架简介</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#三个模块及关系" class="sidebar-link">三个模块及关系</a></li><li class="sidebar-sub-header level3"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#核心思想-分治算法-divide-and-conquer" class="sidebar-link">核心思想: 分治算法(Divide-and-Conquer)</a></li><li class="sidebar-sub-header level3"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#核心思想-work-stealing-工作窃取-算法" class="sidebar-link">核心思想: work-stealing(工作窃取)算法</a></li><li class="sidebar-sub-header level3"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#fork-join-框架的执行流程" class="sidebar-link">Fork/Join 框架的执行流程</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#fork-join类关系" class="sidebar-link">Fork/Join类关系</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#forkjoinpool继承关系" class="sidebar-link">ForkJoinPool继承关系</a></li><li class="sidebar-sub-header level3"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#forkjointask继承关系" class="sidebar-link">ForkJoinTask继承关系</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#fork-join框架源码解析" class="sidebar-link">Fork/Join框架源码解析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#forkjoinpool" class="sidebar-link">ForkJoinPool</a></li><li class="sidebar-sub-header level4"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#核心参数" class="sidebar-link">核心参数</a></li><li class="sidebar-sub-header level4"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#forkjoinpool-workqueue-中的相关属性" class="sidebar-link">ForkJoinPool.WorkQueue 中的相关属性:</a></li><li class="sidebar-sub-header level3"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#forkjointask" class="sidebar-link">ForkJoinTask</a></li><li class="sidebar-sub-header level4"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#核心参数-2" class="sidebar-link">核心参数</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#fork-join框架源码解析-2" class="sidebar-link">Fork/Join框架源码解析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#构造函数" class="sidebar-link">构造函数</a></li><li class="sidebar-sub-header level3"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#执行流程-外部任务-external-submissions-task-提交" class="sidebar-link">执行流程 - 外部任务(external/submissions task)提交</a></li><li class="sidebar-sub-header level4"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#externalpush-forkjointask-task" class="sidebar-link">externalPush(ForkJoinTask task)</a></li><li class="sidebar-sub-header level4"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#externalsubmit-forkjointask-task" class="sidebar-link">externalSubmit(ForkJoinTask task)</a></li><li class="sidebar-sub-header level4"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#signalwork-workqueue-ws-workqueue-q" class="sidebar-link">signalWork(WorkQueue[] ws, WorkQueue q)</a></li><li class="sidebar-sub-header level4"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#tryaddworker-long-c" class="sidebar-link">tryAddWorker(long c)</a></li><li class="sidebar-sub-header level4"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#createworker" class="sidebar-link">createWorker()</a></li><li class="sidebar-sub-header level4"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#registerworker" class="sidebar-link">registerWorker()</a></li><li class="sidebar-sub-header level4"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#小结" class="sidebar-link">小结</a></li><li class="sidebar-sub-header level3"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#执行流程-子任务-worker-task-提交" class="sidebar-link">执行流程: 子任务(Worker task)提交</a></li><li class="sidebar-sub-header level4"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#forkjointask-fork" class="sidebar-link">ForkJoinTask.fork()</a></li><li class="sidebar-sub-header level4"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#forkjoinpool-workqueue-push" class="sidebar-link">ForkJoinPool.WorkQueue.push()</a></li><li class="sidebar-sub-header level4"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#小结-2" class="sidebar-link">小结</a></li><li class="sidebar-sub-header level3"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#执行流程-任务执行" class="sidebar-link">执行流程: 任务执行</a></li><li class="sidebar-sub-header level4"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#forkjoinworkerthread-run" class="sidebar-link">ForkJoinWorkerThread.run()</a></li><li class="sidebar-sub-header level4"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#forkjoinpool-runworker-workqueue-w" class="sidebar-link">ForkJoinPool.runWorker(WorkQueue w)</a></li><li class="sidebar-sub-header level4"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#forkjoinpool-scan-workqueue-w-int-r" class="sidebar-link">ForkJoinPool.scan(WorkQueue w, int r)</a></li><li class="sidebar-sub-header level4"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#forkjoinpool-awaitwork-workqueue-w-int-r" class="sidebar-link">ForkJoinPool.awaitWork(WorkQueue w, int r)</a></li><li class="sidebar-sub-header level4"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#workqueue-runtask" class="sidebar-link">WorkQueue.runTask()</a></li><li class="sidebar-sub-header level4"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#forkjoinpool-deregisterworker-forkjoinworkerthread-wt-throwable-ex" class="sidebar-link">ForkJoinPool.deregisterWorker(ForkJoinWorkerThread wt, Throwable ex)</a></li><li class="sidebar-sub-header level4"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#小结-3" class="sidebar-link">小结</a></li><li class="sidebar-sub-header level3"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#获取任务结果-forkjointask-join-forkjointask-invoke" class="sidebar-link">获取任务结果 - ForkJoinTask.join() / ForkJoinTask.invoke()</a></li><li class="sidebar-sub-header level4"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#forkjointask-externalawaitdone" class="sidebar-link">ForkJoinTask.externalAwaitDone()</a></li><li class="sidebar-sub-header level4"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#forkjoinpool-awaitjoin" class="sidebar-link">ForkJoinPool.awaitJoin()</a></li><li class="sidebar-sub-header level4"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#workqueue-tryremoveandexec-forkjointask-task" class="sidebar-link">WorkQueue.tryRemoveAndExec(ForkJoinTask task)</a></li><li class="sidebar-sub-header level4"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#forkjoinpool-helpstealer-workqueue-w-forkjointask-task" class="sidebar-link">ForkJoinPool.helpStealer(WorkQueue w, ForkJoinTask task)</a></li><li class="sidebar-sub-header level4"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#forkjoinpool-trycompensate-workqueue-w" class="sidebar-link">ForkJoinPool.tryCompensate(WorkQueue w)</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#fork-join的陷阱与注意事项" class="sidebar-link">Fork/Join的陷阱与注意事项</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#避免不必要的fork" class="sidebar-link">避免不必要的fork()</a></li><li class="sidebar-sub-header level3"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#注意fork-、compute-、join-的顺序" class="sidebar-link">注意fork()、compute()、join()的顺序</a></li><li class="sidebar-sub-header level3"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#选择合适的子任务粒度" class="sidebar-link">选择合适的子任务粒度</a></li><li class="sidebar-sub-header level3"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#避免重量级任务划分与结果合并" class="sidebar-link">避免重量级任务划分与结果合并</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#再深入理解" class="sidebar-link">再深入理解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#有哪些jdk源码中使用了fork-join思想" class="sidebar-link">有哪些JDK源码中使用了Fork/Join思想?</a></li><li class="sidebar-sub-header level3"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#使用executors工具类创建forkjoinpool" class="sidebar-link">使用Executors工具类创建ForkJoinPool</a></li><li class="sidebar-sub-header level3"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#关于fork-join异常处理" class="sidebar-link">关于Fork/Join异常处理</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#一些fork-join例子" class="sidebar-link">一些Fork/Join例子</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#采用fork-join来异步计算1-2-3-10000的结果" class="sidebar-link">采用Fork/Join来异步计算1+2+3+…+10000的结果</a></li><li class="sidebar-sub-header level3"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#实现斐波那契数列" class="sidebar-link">实现斐波那契数列</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/java-thread-x-juc-executor-ForkJoinPool/#参考文章" class="sidebar-link">参考文章</a></li></ul></li><li><a href="/pages/java-thread-x-juc-tool-CountDownLatch/" class="sidebar-link">JUC工具类 - CountDownLatch详解</a></li><li><a href="/pages/java-thread-x-juc-tool-CyclicBarrier/" class="sidebar-link">JUC工具类 - CyclicBarrier详解</a></li><li><a href="/pages/java-thread-x-juc-tool-semaphore/" class="sidebar-link">JUC工具类 - Semaphore详解</a></li><li><a href="/pages/java-thread-x-juc-tool-phaser/" class="sidebar-link">JUC工具类 - Phaser详解</a></li><li><a href="/pages/java-thread-x-juc-tool-exchanger/" class="sidebar-link">JUC工具类 - Exchanger详解</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java IO</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JVM</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java8特性</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java8+特性</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/java/#Java" data-v-06225672>Java</a></li><li data-v-06225672><a href="/java/#多线程与并发" data-v-06225672>多线程与并发</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/willpast" target="_blank" title="作者" class="beLink" data-v-06225672>Cyan</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2024-05-24</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">JUC线程池 - Fork/Join框架详解<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="juc线程池-fork-join框架详解"><a href="#juc线程池-fork-join框架详解" class="header-anchor">#</a> JUC线程池: Fork/Join框架详解</h1> <blockquote><p>ForkJoinPool 是JDK 7加入的一个线程池类。Fork/Join 技术是分治算法(Divide-and-Conquer)的并行实现，它是一项可以获得良好的并行性能的简单且高效的设计技术。目的是为了帮助我们更好地利用多处理器带来的好处，使用所有可用的运算能力来提升应用的性能。</p></blockquote> <h2 id="思考"><a href="#思考" class="header-anchor">#</a> 思考</h2> <ul><li>Fork/Join主要用来解决什么样的问题?</li> <li>Fork/Join框架是在哪个JDK版本中引入的?</li> <li>Fork/Join框架主要包含哪三个模块? 模块之间的关系是怎么样的?</li> <li>ForkJoinPool类继承关系?</li> <li>ForkJoinTask抽象类继承关系? 在实际运用中，我们一般都会继承 RecursiveTask 、RecursiveAction 或 CountedCompleter 来实现我们的业务需求，而不会直接继承 ForkJoinTask 类。</li> <li>整个Fork/Join 框架的执行流程/运行机制是怎么样的?</li> <li>具体阐述Fork/Join的分治思想和work-stealing 实现方式?</li> <li>有哪些JDK源码中使用了Fork/Join思想?</li> <li>如何使用Executors工具类创建ForkJoinPool?</li> <li>写一个例子: 用ForkJoin方式实现1+2+3+...+100000?</li> <li>Fork/Join在使用时有哪些注意事项? 结合JDK中的斐波那契数列实例具体说明。</li></ul> <h2 id="fork-join框架简介"><a href="#fork-join框架简介" class="header-anchor">#</a> Fork/Join框架简介</h2> <p>Fork/Join框架是Java并发工具包中的一种可以将一个大任务拆分为很多小任务来异步执行的工具，自JDK1.7引入。</p> <h3 id="三个模块及关系"><a href="#三个模块及关系" class="header-anchor">#</a> 三个模块及关系</h3> <p>Fork/Join框架主要包含三个模块:</p> <ul><li>任务对象: <code>ForkJoinTask</code> (包括<code>RecursiveTask</code>、<code>RecursiveAction</code> 和 <code>CountedCompleter</code>)</li> <li>执行Fork/Join任务的线程: <code>ForkJoinWorkerThread</code></li> <li>线程池: <code>ForkJoinPool</code></li></ul> <p>这三者的关系是: ForkJoinPool可以通过池中的ForkJoinWorkerThread来处理ForkJoinTask任务。</p> <div class="language- extra-class"><pre><code>// from 《A Java Fork/Join Framework》Dong Lea
Result solve(Problem problem) {
    if (problem is small)
        directly solve problem
    else {
        split problem into independent parts
        fork new subtasks to solve each part
        join all subtasks
        compose result from subresults
    }
}
</code></pre></div><p>ForkJoinPool 只接收 ForkJoinTask 任务(在实际使用中，也可以接收 Runnable/Callable
任务，但在真正运行时，也会把这些任务封装成 ForkJoinTask 类型的任务)，RecursiveTask 是 ForkJoinTask
的子类，是一个可以递归执行的 ForkJoinTask，RecursiveAction 是一个无返回值的
RecursiveTask，CountedCompleter 在任务完成执行后会触发执行一个自定义的钩子函数。</p> <p>在实际运用中，我们一般都会继承 <code>RecursiveTask</code> 、<code>RecursiveAction</code> 或 <code>CountedCompleter</code>
来实现我们的业务需求，而不会直接继承 ForkJoinTask 类。</p> <h3 id="核心思想-分治算法-divide-and-conquer"><a href="#核心思想-分治算法-divide-and-conquer" class="header-anchor">#</a> 核心思想: 分治算法(Divide-and-Conquer)</h3> <p>分治算法(Divide-and-
Conquer)把任务递归的拆分为各个子任务，这样可以更好的利用系统资源，尽可能的使用所有可用的计算能力来提升应用性能。首先看一下 Fork/Join
框架的任务运行机制:</p> <p><img src="https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/java-thread-x-forkjoin-2.png" alt="img"></p> <ul><li>这里也可以一并看下: <a href="/md/algorithm/alg-core-divide-and-conquer.html">算法思想 - 分治算法</a></li></ul> <h3 id="核心思想-work-stealing-工作窃取-算法"><a href="#核心思想-work-stealing-工作窃取-算法" class="header-anchor">#</a> 核心思想: work-stealing(工作窃取)算法</h3> <p>work-stealing(工作窃取)算法:
线程池内的所有工作线程都尝试找到并执行已经提交的任务，或者是被其他活动任务创建的子任务(如果不存在就阻塞等待)。这种特性使得 ForkJoinPool
在运行多个可以产生子任务的任务，或者是提交的许多小任务时效率更高。尤其是构建异步模型的 ForkJoinPool
时，对不需要合并(join)的事件类型任务也非常适用。</p> <p>在 ForkJoinPool
中，线程池中每个工作线程(ForkJoinWorkerThread)都对应一个任务队列(WorkQueue)，工作线程优先处理来自自身队列的任务(LIFO或FIFO顺序，参数
mode 决定)，然后以FIFO的顺序随机窃取其他队列中的任务。</p> <p>具体思路如下:</p> <ul><li>每个线程都有自己的一个WorkQueue，该工作队列是一个双端队列。</li> <li>队列支持三个功能push、pop、poll</li> <li>push/pop只能被队列的所有者线程调用，而poll可以被其他线程调用。</li> <li>划分的子任务调用fork时，都会被push到自己的队列中。</li> <li>默认情况下，工作线程从自己的双端队列获出任务并执行。</li> <li>当自己的队列为空时，线程随机从另一个线程的队列末尾调用poll方法窃取任务。</li></ul> <p><img src="https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/java-thread-x-forkjoin-3.png" alt="img"></p> <h3 id="fork-join-框架的执行流程"><a href="#fork-join-框架的执行流程" class="header-anchor">#</a> Fork/Join 框架的执行流程</h3> <p>上图可以看出ForkJoinPool 中的任务执行分两种:</p> <ul><li>直接通过 FJP 提交的外部任务(external/submissions task)，存放在 workQueues 的偶数槽位；</li> <li>通过内部 fork 分割的子任务(Worker task)，存放在 workQueues 的奇数槽位。</li></ul> <p>那Fork/Join 框架的执行流程是什么样的?</p> <p><img src="https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/java-thread-x-forkjoin-5.png" alt="img"></p> <blockquote><p>后续的源码解析将围绕上图进行。</p></blockquote> <h2 id="fork-join类关系"><a href="#fork-join类关系" class="header-anchor">#</a> Fork/Join类关系</h2> <h3 id="forkjoinpool继承关系"><a href="#forkjoinpool继承关系" class="header-anchor">#</a> ForkJoinPool继承关系</h3> <p><img src="https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/java-thread-x-forkjoin-1.png" alt="img"></p> <p>内部类介绍:</p> <ul><li><p>ForkJoinWorkerThreadFactory: 内部线程工厂接口，用于创建工作线程ForkJoinWorkerThread</p></li> <li><p>DefaultForkJoinWorkerThreadFactory: ForkJoinWorkerThreadFactory 的默认实现类</p></li> <li><p>InnocuousForkJoinWorkerThreadFactory: 实现了 ForkJoinWorkerThreadFactory，无许可线程工厂，当系统变量中有系统安全管理相关属性时，默认使用这个工厂创建工作线程。</p></li> <li><p>EmptyTask: 内部占位类，用于替换队列中 join 的任务。</p></li> <li><p>ManagedBlocker: 为 ForkJoinPool 中的任务提供扩展管理并行数的接口，一般用在可能会阻塞的任务(如在 Phaser 中用于等待 phase 到下一个generation)。</p></li> <li><p>WorkQueue: ForkJoinPool 的核心数据结构，本质上是work-stealing 模式的双端任务队列，内部存放 ForkJoinTask 对象任务，使用 @Contented 注解修饰防止伪共享。</p> <ul><li>工作线程在运行中产生新的任务(通常是因为调用了 fork())时，此时可以把 WorkQueue 的数据结构视为一个栈，新的任务会放入栈顶(top 位)；工作线程在处理自己工作队列的任务时，按照 LIFO 的顺序。</li> <li>工作线程在处理自己的工作队列同时，会尝试窃取一个任务(可能是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的队列任务)，此时可以把 WorkQueue 的数据结构视为一个 FIFO 的队列，窃取的任务位于其他线程的工作队列的队首(base位)。</li></ul></li> <li><p>伪共享状态: 缓存系统中是以缓存行(cache line)为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。</p></li></ul> <h3 id="forkjointask继承关系"><a href="#forkjointask继承关系" class="header-anchor">#</a> ForkJoinTask继承关系</h3> <p><img src="https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/java-thread-x-forkjoin-4.png" alt="img"></p> <p>ForkJoinTask 实现了 Future 接口，说明它也是一个可取消的异步运算任务，实际上ForkJoinTask 是 Future
的轻量级实现，主要用在纯粹是计算的函数式任务或者操作完全独立的对象计算任务。fork 是主运行方法，用于异步执行；而 join
方法在任务结果计算完毕之后才会运行，用来合并或返回计算结果。 其内部类都比较简单，ExceptionNode
是用于存储任务执行期间的异常信息的单向链表；其余四个类是为 Runnable/Callable 任务提供的适配器类，用于把
Runnable/Callable 转化为 ForkJoinTask 类型的任务(因为 ForkJoinPool 只可以运行 ForkJoinTask
类型的任务)。</p> <h2 id="fork-join框架源码解析"><a href="#fork-join框架源码解析" class="header-anchor">#</a> Fork/Join框架源码解析</h2> <blockquote><p>分析思路: 在对类层次结构有了解以后，我们先看下内部核心参数，然后分析上述流程图。会分4个部分:</p></blockquote> <ul><li>首先介绍任务的提交流程 - 外部任务(external/submissions task)提交</li> <li>然后介绍任务的提交流程 - 子任务(Worker task)提交</li> <li>再分析任务的执行过程(ForkJoinWorkerThread.run()到ForkJoinTask.doExec()这一部分)；</li> <li>最后介绍任务的结果获取(ForkJoinTask.join()和ForkJoinTask.invoke())</li></ul> <h3 id="forkjoinpool"><a href="#forkjoinpool" class="header-anchor">#</a> ForkJoinPool</h3> <h4 id="核心参数"><a href="#核心参数" class="header-anchor">#</a> 核心参数</h4> <p>在后面的源码解析中，我们会看到大量的位运算，这些位运算都是通过我们接下来介绍的一些常量参数来计算的。</p> <p>例如，如果要更新活跃线程数，使用公式(UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; c)；c 代表当前 ctl，UC_MASK 和 SP_MASK 分别是高位和低位掩码，AC_UNIT 为活跃线程的增量数，使用(UC_MASK &amp; (c + AC_UNIT))就可以计算出高32位，然后再加上低32位(SP_MASK &amp; c)，就拼接成了一个新的ctl。</p> <p>这些运算的可读性很差，看起来有些复杂。在后面源码解析中有位运算的地方我都会加上注释，大家只需要了解它们的作用即可。</p> <p>ForkJoinPool 与 内部类 WorkQueue 共享的一些常量:</p> <div class="language- extra-class"><pre><code>// Constants shared across ForkJoinPool and WorkQueue

// 限定参数
static final int SMASK = 0xffff;        //  低位掩码，也是最大索引位
static final int MAX_CAP = 0x7fff;        //  工作线程最大容量
static final int EVENMASK = 0xfffe;        //  偶数低位掩码
static final int SQMASK = 0x007e;        //  workQueues 数组最多64个槽位

// ctl 子域和 WorkQueue.scanState 的掩码和标志位
static final int SCANNING = 1;             // 标记是否正在运行任务
static final int INACTIVE = 1 &lt;&lt; 31;       // 失活状态  负数
static final int SS_SEQ = 1 &lt;&lt; 16;       // 版本戳，防止ABA问题

// ForkJoinPool.config 和 WorkQueue.config 的配置信息标记
static final int MODE_MASK = 0xffff &lt;&lt; 16;  // 模式掩码
static final int LIFO_QUEUE = 0; //LIFO队列
static final int FIFO_QUEUE = 1 &lt;&lt; 16;//FIFO队列
static final int SHARED_QUEUE = 1 &lt;&lt; 31;       // 共享模式队列，负数
</code></pre></div><p>ForkJoinPool 中的相关常量和实例字段:</p> <div class="language- extra-class"><pre><code>//  低位和高位掩码
private static final long SP_MASK = 0xffffffffL;
private static final long UC_MASK = ~SP_MASK;

// 活跃线程数
private static final int AC_SHIFT = 48;
private static final long AC_UNIT = 0x0001L &lt;&lt; AC_SHIFT; //活跃线程数增量
private static final long AC_MASK = 0xffffL &lt;&lt; AC_SHIFT; //活跃线程数掩码

// 工作线程数
private static final int TC_SHIFT = 32;
private static final long TC_UNIT = 0x0001L &lt;&lt; TC_SHIFT; //工作线程数增量
private static final long TC_MASK = 0xffffL &lt;&lt; TC_SHIFT; //掩码
private static final long ADD_WORKER = 0x0001L &lt;&lt; (TC_SHIFT + 15);  // 创建工作线程标志

// 池状态
private static final int RSLOCK = 1;
private static final int RSIGNAL = 1 &lt;&lt; 1;
private static final int STARTED = 1 &lt;&lt; 2;
private static final int STOP = 1 &lt;&lt; 29;
private static final int TERMINATED = 1 &lt;&lt; 30;
private static final int SHUTDOWN = 1 &lt;&lt; 31;

// 实例字段
volatile long ctl;                   // 主控制参数
volatile int runState;               // 运行状态锁
final int config;                    // 并行度|模式
int indexSeed;                       // 用于生成工作线程索引
volatile WorkQueue[] workQueues;     // 主对象注册信息，workQueue
final ForkJoinWorkerThreadFactory factory;// 线程工厂
final UncaughtExceptionHandler ueh;  // 每个工作线程的异常信息
final String workerNamePrefix;       // 用于创建工作线程的名称
volatile AtomicLong stealCounter;    // 偷取任务总数，也可作为同步监视器

/** 静态初始化字段 */
//线程工厂
public static final ForkJoinWorkerThreadFactory defaultForkJoinWorkerThreadFactory;
//启动或杀死线程的方法调用者的权限
private static final RuntimePermission modifyThreadPermission;
// 公共静态pool
static final ForkJoinPool common;
//并行度，对应内部common池
static final int commonParallelism;
//备用线程数，在tryCompensate中使用
private static int commonMaxSpares;
//创建workerNamePrefix(工作线程名称前缀)时的序号
private static int poolNumberSequence;
//线程阻塞等待新的任务的超时值(以纳秒为单位)，默认2秒
private static final long IDLE_TIMEOUT = 2000L * 1000L * 1000L; // 2sec
//空闲超时时间，防止timer未命中
private static final long TIMEOUT_SLOP = 20L * 1000L * 1000L;  // 20ms
//默认备用线程数
private static final int DEFAULT_COMMON_MAX_SPARES = 256;
//阻塞前自旋的次数，用在在awaitRunStateLock和awaitWork中
private static final int SPINS  = 0;
//indexSeed的增量
private static final int SEED_INCREMENT = 0x9e3779b9;
</code></pre></div><p>说明: ForkJoinPool 的内部状态都是通过一个64位的 long 型 变量ctl来存储，它由四个16位的子域组成:</p> <ul><li>AC: 正在运行工作线程数减去目标并行度，高16位</li> <li>TC: 总工作线程数减去目标并行度，中高16位</li> <li>SS: 栈顶等待线程的版本计数和状态，中低16位</li> <li>ID: 栈顶 WorkQueue 在池中的索引(poolIndex)，低16位</li></ul> <p>在后面的源码解析中，某些地方也提取了ctl的低32位(sp=(int)ctl)来检查工作线程状态，例如，当sp不为0时说明当前还有空闲工作线程。</p> <h4 id="forkjoinpool-workqueue-中的相关属性"><a href="#forkjoinpool-workqueue-中的相关属性" class="header-anchor">#</a> ForkJoinPool.WorkQueue 中的相关属性:</h4> <div class="language- extra-class"><pre><code>//初始队列容量，2的幂
static final int INITIAL_QUEUE_CAPACITY = 1 &lt;&lt; 13;
//最大队列容量
static final int MAXIMUM_QUEUE_CAPACITY = 1 &lt;&lt; 26; // 64M

// 实例字段
volatile int scanState;    // Woker状态, &lt;0: inactive; odd:scanning
int stackPred;             // 记录前一个栈顶的ctl
int nsteals;               // 偷取任务数
int hint;                  // 记录偷取者索引，初始为随机索引
int config;                // 池索引和模式
volatile int qlock;        // 1: locked, &lt; 0: terminate; else 0
volatile int base;         //下一个poll操作的索引(栈底/队列头)
int top;                   //  下一个push操作的索引(栈顶/队列尾)
ForkJoinTask&lt;?&gt;[] array;   // 任务数组
final ForkJoinPool pool;   // the containing pool (may be null)
final ForkJoinWorkerThread owner; // 当前工作队列的工作线程，共享模式下为null
volatile Thread parker;    // 调用park阻塞期间为owner，其他情况为null
volatile ForkJoinTask&lt;?&gt; currentJoin;  // 记录被join过来的任务
volatile ForkJoinTask&lt;?&gt; currentSteal; // 记录从其他工作队列偷取过来的任务
</code></pre></div><h3 id="forkjointask"><a href="#forkjointask" class="header-anchor">#</a> ForkJoinTask</h3> <h4 id="核心参数-2"><a href="#核心参数-2" class="header-anchor">#</a> 核心参数</h4> <div class="language- extra-class"><pre><code>/** 任务运行状态 */
volatile int status; // 任务运行状态
static final int DONE_MASK   = 0xf0000000;  // 任务完成状态标志位
static final int NORMAL      = 0xf0000000;  // must be negative
static final int CANCELLED   = 0xc0000000;  // must be &lt; NORMAL
static final int EXCEPTIONAL = 0x80000000;  // must be &lt; CANCELLED
static final int SIGNAL      = 0x00010000;  // must be &gt;= 1 &lt;&lt; 16 等待信号
static final int SMASK       = 0x0000ffff;  //  低位掩码
</code></pre></div><h2 id="fork-join框架源码解析-2"><a href="#fork-join框架源码解析-2" class="header-anchor">#</a> Fork/Join框架源码解析</h2> <h3 id="构造函数"><a href="#构造函数" class="header-anchor">#</a> 构造函数</h3> <div class="language- extra-class"><pre><code>public ForkJoinPool(int parallelism,
                    ForkJoinWorkerThreadFactory factory,
                    UncaughtExceptionHandler handler,
                    boolean asyncMode) {
    this(checkParallelism(parallelism),
            checkFactory(factory),
            handler,
            asyncMode ? FIFO_QUEUE : LIFO_QUEUE,
            &quot;ForkJoinPool-&quot; + nextPoolId() + &quot;-worker-&quot;);
    checkPermission();
}
</code></pre></div><p>说明: 在 ForkJoinPool 中我们可以自定义四个参数:</p> <ul><li>parallelism: 并行度，默认为CPU数，最小为1</li> <li>factory: 工作线程工厂；</li> <li>handler: 处理工作线程运行任务时的异常情况类，默认为null；</li> <li>asyncMode: 是否为异步模式，默认为 false。如果为true，表示子任务的执行遵循 FIFO 顺序并且任务不能被合并(join)，这种模式适用于工作线程只运行事件类型的异步任务。</li></ul> <p>在多数场景使用时，如果没有太强的业务需求，我们一般直接使用 ForkJoinPool
中的common池，在JDK1.8之后提供了ForkJoinPool.commonPool()方法可以直接使用common池，来看一下它的构造:</p> <div class="language- extra-class"><pre><code>private static ForkJoinPool makeCommonPool() {
    int parallelism = -1;
    ForkJoinWorkerThreadFactory factory = null;
    UncaughtExceptionHandler handler = null;
    try {  // ignore exceptions in accessing/parsing
        String pp = System.getProperty
                (&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;);//并行度
        String fp = System.getProperty
                (&quot;java.util.concurrent.ForkJoinPool.common.threadFactory&quot;);//线程工厂
        String hp = System.getProperty
                (&quot;java.util.concurrent.ForkJoinPool.common.exceptionHandler&quot;);//异常处理类
        if (pp != null)
            parallelism = Integer.parseInt(pp);
        if (fp != null)
            factory = ((ForkJoinWorkerThreadFactory) ClassLoader.
                    getSystemClassLoader().loadClass(fp).newInstance());
        if (hp != null)
            handler = ((UncaughtExceptionHandler) ClassLoader.
                    getSystemClassLoader().loadClass(hp).newInstance());
    } catch (Exception ignore) {
    }
    if (factory == null) {
        if (System.getSecurityManager() == null)
            factory = defaultForkJoinWorkerThreadFactory;
        else // use security-managed default
            factory = new InnocuousForkJoinWorkerThreadFactory();
    }
    if (parallelism &lt; 0 &amp;&amp; // default 1 less than #cores
            (parallelism = Runtime.getRuntime().availableProcessors() - 1) &lt;= 0)
        parallelism = 1;//默认并行度为1
    if (parallelism &gt; MAX_CAP)
        parallelism = MAX_CAP;
    return new ForkJoinPool(parallelism, factory, handler, LIFO_QUEUE,
            &quot;ForkJoinPool.commonPool-worker-&quot;);
}
</code></pre></div><p>使用common
pool的优点就是我们可以通过指定系统参数的方式定义“并行度、线程工厂和异常处理类”；并且它使用的是同步模式，也就是说可以支持任务合并(join)。</p> <h3 id="执行流程-外部任务-external-submissions-task-提交"><a href="#执行流程-外部任务-external-submissions-task-提交" class="header-anchor">#</a> 执行流程 - 外部任务(external/submissions task)提交</h3> <p>向 ForkJoinPool 提交任务有三种方式:</p> <ul><li>invoke()会等待任务计算完毕并返回计算结果；</li> <li>execute()是直接向池提交一个任务来异步执行，无返回结果；</li> <li>submit()也是异步执行，但是会返回提交的任务，在适当的时候可通过task.get()获取执行结果。</li></ul> <p>这三种提交方式都都是调用externalPush()方法来完成，所以接下来我们将从externalPush()方法开始逐步分析外部任务的执行过程。</p> <h4 id="externalpush-forkjointask-task"><a href="#externalpush-forkjointask-task" class="header-anchor">#</a> externalPush(ForkJoinTask&lt;?&gt; task)</h4> <div class="language- extra-class"><pre><code>//添加给定任务到submission队列中
final void externalPush(ForkJoinTask&lt;?&gt; task) {
    WorkQueue[] ws;
    WorkQueue q;
    int m;
    int r = ThreadLocalRandom.getProbe();//探针值，用于计算WorkQueue槽位索引
    int rs = runState;
    if ((ws = workQueues) != null &amp;&amp; (m = (ws.length - 1)) &gt;= 0 &amp;&amp;
            (q = ws[m &amp; r &amp; SQMASK]) != null &amp;&amp; r != 0 &amp;&amp; rs &gt; 0 &amp;&amp; //获取随机偶数槽位的workQueue
            U.compareAndSwapInt(q, QLOCK, 0, 1)) {//锁定workQueue
        ForkJoinTask&lt;?&gt;[] a;
        int am, n, s;
        if ((a = q.array) != null &amp;&amp;
                (am = a.length - 1) &gt; (n = (s = q.top) - q.base)) {
            int j = ((am &amp; s) &lt;&lt; ASHIFT) + ABASE;//计算任务索引位置
            U.putOrderedObject(a, j, task);//任务入列
            U.putOrderedInt(q, QTOP, s + 1);//更新push slot
            U.putIntVolatile(q, QLOCK, 0);//解除锁定
            if (n &lt;= 1)
                signalWork(ws, q);//任务数小于1时尝试创建或激活一个工作线程
            return;
        }
        U.compareAndSwapInt(q, QLOCK, 1, 0);//解除锁定
    }
    externalSubmit(task);//初始化workQueues及相关属性
}
</code></pre></div><p>首先说明一下externalPush和externalSubmit两个方法的联系:
它们的作用都是把任务放到队列中等待执行。不同的是，externalSubmit可以说是完整版的externalPush，在任务首次提交时，需要初始化workQueues及其他相关属性，这个初始化操作就是externalSubmit来完成的；而后再向池中提交的任务都是通过简化版的externalSubmit-
externalPush来完成。</p> <p>externalPush的执行流程很简单: 首先找到一个随机偶数槽位的 workQueue，然后把任务放入这个 workQueue
的任务数组中，并更新top位。如果队列的剩余任务数小于1，则尝试创建或激活一个工作线程来运行任务(防止在externalSubmit初始化时发生异常导致工作线程创建失败)。</p> <h4 id="externalsubmit-forkjointask-task"><a href="#externalsubmit-forkjointask-task" class="header-anchor">#</a> externalSubmit(ForkJoinTask&lt;?&gt; task)</h4> <div class="language- extra-class"><pre><code>//任务提交
private void externalSubmit(ForkJoinTask&lt;?&gt; task) {
    //初始化调用线程的探针值，用于计算WorkQueue索引
    int r;                                    // initialize caller's probe
    if ((r = ThreadLocalRandom.getProbe()) == 0) {
        ThreadLocalRandom.localInit();
        r = ThreadLocalRandom.getProbe();
    }
    for (; ; ) {
        WorkQueue[] ws;
        WorkQueue q;
        int rs, m, k;
        boolean move = false;
        if ((rs = runState) &lt; 0) {// 池已关闭
            tryTerminate(false, false);     // help terminate
            throw new RejectedExecutionException();
        }
        //初始化workQueues
        else if ((rs &amp; STARTED) == 0 ||     // initialize
                ((ws = workQueues) == null || (m = ws.length - 1) &lt; 0)) {
            int ns = 0;
            rs = lockRunState();//锁定runState
            try {
                //初始化
                if ((rs &amp; STARTED) == 0) {
                    //初始化stealCounter
                    U.compareAndSwapObject(this, STEALCOUNTER, null,
                            new AtomicLong());
                    //创建workQueues，容量为2的幂次方
                    // create workQueues array with size a power of two
                    int p = config &amp; SMASK; // ensure at least 2 slots
                    int n = (p &gt; 1) ? p - 1 : 1;
                    n |= n &gt;&gt;&gt; 1;
                    n |= n &gt;&gt;&gt; 2;
                    n |= n &gt;&gt;&gt; 4;
                    n |= n &gt;&gt;&gt; 8;
                    n |= n &gt;&gt;&gt; 16;
                    n = (n + 1) &lt;&lt; 1;
                    workQueues = new WorkQueue[n];
                    ns = STARTED;
                }
            } finally {
                unlockRunState(rs, (rs &amp; ~RSLOCK) | ns);//解锁并更新runState
            }
        } else if ((q = ws[k = r &amp; m &amp; SQMASK]) != null) {//获取随机偶数槽位的workQueue
            if (q.qlock == 0 &amp;&amp; U.compareAndSwapInt(q, QLOCK, 0, 1)) {//锁定 workQueue
                ForkJoinTask&lt;?&gt;[] a = q.array;//当前workQueue的全部任务
                int s = q.top;
                boolean submitted = false; // initial submission or resizing
                try {                      // locked version of push
                    if ((a != null &amp;&amp; a.length &gt; s + 1 - q.base) ||
                            (a = q.growArray()) != null) {//扩容
                        int j = (((a.length - 1) &amp; s) &lt;&lt; ASHIFT) + ABASE;
                        U.putOrderedObject(a, j, task);//放入给定任务
                        U.putOrderedInt(q, QTOP, s + 1);//修改push slot
                        submitted = true;
                    }
                } finally {
                    U.compareAndSwapInt(q, QLOCK, 1, 0);//解除锁定
                }
                if (submitted) {//任务提交成功，创建或激活工作线程
                    signalWork(ws, q);//创建或激活一个工作线程来运行任务
                    return;
                }
            }
            move = true;                   // move on failure 操作失败，重新获取探针值
        } else if (((rs = runState) &amp; RSLOCK) == 0) { // create new queue
            q = new WorkQueue(this, null);
            q.hint = r;
            q.config = k | SHARED_QUEUE;
            q.scanState = INACTIVE;
            rs = lockRunState();           // publish index
            if (rs &gt; 0 &amp;&amp; (ws = workQueues) != null &amp;&amp;
                    k &lt; ws.length &amp;&amp; ws[k] == null)
                ws[k] = q;                 // 更新索引k位值的workQueue
            //else terminated
            unlockRunState(rs, rs &amp; ~RSLOCK);
        } else
            move = true;                   // move if busy
        if (move)
            r = ThreadLocalRandom.advanceProbe(r);//重新获取线程探针值
    }
}
</code></pre></div><p>说明:
externalSubmit是externalPush的完整版本，主要用于第一次提交任务时初始化workQueues及相关属性，并且提交给定任务到队列中。具体执行步骤如下:</p> <ul><li>如果池为终止状态(runState&lt;0)，调用tryTerminate来终止线程池，并抛出任务拒绝异常；</li> <li>如果尚未初始化，就为 FJP 执行初始化操作: 初始化stealCounter、创建workerQueues，然后继续自旋；</li> <li>初始化完成后，执行在externalPush中相同的操作: 获取 workQueue，放入指定任务。任务提交成功后调用signalWork方法创建或激活线程；</li> <li>如果在步骤3中获取到的 workQueue 为null，会在这一步中创建一个 workQueue，创建成功继续自旋执行第三步操作；</li> <li>如果非上述情况，或者有线程争用资源导致获取锁失败，就重新获取线程探针值继续自旋。</li></ul> <h4 id="signalwork-workqueue-ws-workqueue-q"><a href="#signalwork-workqueue-ws-workqueue-q" class="header-anchor">#</a> signalWork(WorkQueue[] ws, WorkQueue q)</h4> <div class="language- extra-class"><pre><code>final void signalWork(WorkQueue[] ws, WorkQueue q) {
    long c;
    int sp, i;
    WorkQueue v;
    Thread p;
    while ((c = ctl) &lt; 0L) {                       // too few active
        if ((sp = (int) c) == 0) {                  // no idle workers
            if ((c &amp; ADD_WORKER) != 0L)            // too few workers
                tryAddWorker(c);//工作线程太少，添加新的工作线程
            break;
        }
        if (ws == null)                            // unstarted/terminated
            break;
        if (ws.length &lt;= (i = sp &amp; SMASK))         // terminated
            break;
        if ((v = ws[i]) == null)                   // terminating
            break;
        //计算ctl，加上版本戳SS_SEQ避免ABA问题
        int vs = (sp + SS_SEQ) &amp; ~INACTIVE;        // next scanState
        int d = sp - v.scanState;                  // screen CAS
        //计算活跃线程数(高32位)并更新为下一个栈顶的scanState(低32位)
        long nc = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; v.stackPred);
        if (d == 0 &amp;&amp; U.compareAndSwapLong(this, CTL, c, nc)) {
            v.scanState = vs;                      // activate v
            if ((p = v.parker) != null)
                U.unpark(p);//唤醒阻塞线程
            break;
        }
        if (q != null &amp;&amp; q.base == q.top)          // no more work
            break;
    }
}
</code></pre></div><p>说明:
新建或唤醒一个工作线程，在externalPush、externalSubmit、workQueue.push、scan中调用。如果还有空闲线程，则尝试唤醒索引到的
WorkQueue 的parker线程；如果工作线程过少((ctl &amp; ADD_WORKER) !=
0L)，则调用tryAddWorker添加一个新的工作线程。</p> <h4 id="tryaddworker-long-c"><a href="#tryaddworker-long-c" class="header-anchor">#</a> tryAddWorker(long c)</h4> <div class="language- extra-class"><pre><code>private void tryAddWorker(long c) {
    boolean add = false;
    do {
        long nc = ((AC_MASK &amp; (c + AC_UNIT)) |
                   (TC_MASK &amp; (c + TC_UNIT)));
        if (ctl == c) {
            int rs, stop;                 // check if terminating
            if ((stop = (rs = lockRunState()) &amp; STOP) == 0)
                add = U.compareAndSwapLong(this, CTL, c, nc);
            unlockRunState(rs, rs &amp; ~RSLOCK);//释放锁
            if (stop != 0)
                break;
            if (add) {
                createWorker();//创建工作线程
                break;
            }
        }
    } while (((c = ctl) &amp; ADD_WORKER) != 0L &amp;&amp; (int)c == 0);
}
</code></pre></div><p>说明: 尝试添加一个新的工作线程，首先更新ctl中的工作线程数，然后调用createWorker()创建工作线程。</p> <h4 id="createworker"><a href="#createworker" class="header-anchor">#</a> createWorker()</h4> <div class="language- extra-class"><pre><code>private boolean createWorker() {
    ForkJoinWorkerThreadFactory fac = factory;
    Throwable ex = null;
    ForkJoinWorkerThread wt = null;
    try {
        if (fac != null &amp;&amp; (wt = fac.newThread(this)) != null) {
            wt.start();
            return true;
        }
    } catch (Throwable rex) {
        ex = rex;
    }
    deregisterWorker(wt, ex);//线程创建失败处理
    return false;
}
</code></pre></div><p>说明:
createWorker首先通过线程工厂创一个新的ForkJoinWorkerThread，然后启动这个工作线程(wt.start())。如果期间发生异常，调用deregisterWorker处理线程创建失败的逻辑(deregisterWorker在后面再详细说明)。</p> <p>ForkJoinWorkerThread 的构造函数如下:</p> <div class="language- extra-class"><pre><code>protected ForkJoinWorkerThread(ForkJoinPool pool) {
    // Use a placeholder until a useful name can be set in registerWorker
    super(&quot;aForkJoinWorkerThread&quot;);
    this.pool = pool;
    this.workQueue = pool.registerWorker(this);
}
</code></pre></div><p>可以看到 ForkJoinWorkerThread 在构造时首先调用父类 Thread
的方法，然后为工作线程注册pool和workQueue，而workQueue的注册任务由ForkJoinPool.registerWorker来完成。</p> <h4 id="registerworker"><a href="#registerworker" class="header-anchor">#</a> registerWorker()</h4> <div class="language- extra-class"><pre><code>final WorkQueue registerWorker(ForkJoinWorkerThread wt) {
    UncaughtExceptionHandler handler;
    //设置为守护线程
    wt.setDaemon(true);                           // configure thread
    if ((handler = ueh) != null)
        wt.setUncaughtExceptionHandler(handler);
    WorkQueue w = new WorkQueue(this, wt);//构造新的WorkQueue
    int i = 0;                                    // assign a pool index
    int mode = config &amp; MODE_MASK;
    int rs = lockRunState();
    try {
        WorkQueue[] ws;
        int n;                    // skip if no array
        if ((ws = workQueues) != null &amp;&amp; (n = ws.length) &gt; 0) {
            //生成新建WorkQueue的索引
            int s = indexSeed += SEED_INCREMENT;  // unlikely to collide
            int m = n - 1;
            i = ((s &lt;&lt; 1) | 1) &amp; m;               // Worker任务放在奇数索引位 odd-numbered indices
            if (ws[i] != null) {                  // collision 已存在，重新计算索引位
                int probes = 0;                   // step by approx half n
                int step = (n &lt;= 4) ? 2 : ((n &gt;&gt;&gt; 1) &amp; EVENMASK) + 2;
                //查找可用的索引位
                while (ws[i = (i + step) &amp; m] != null) {
                    if (++probes &gt;= n) {//所有索引位都被占用，对workQueues进行扩容
                        workQueues = ws = Arrays.copyOf(ws, n &lt;&lt;= 1);//workQueues 扩容
                        m = n - 1;
                        probes = 0;
                    }
                }
            }
            w.hint = s;                           // use as random seed
            w.config = i | mode;
            w.scanState = i;                      // publication fence
            ws[i] = w;
        }
    } finally {
        unlockRunState(rs, rs &amp; ~RSLOCK);
    }
    wt.setName(workerNamePrefix.concat(Integer.toString(i &gt;&gt;&gt; 1)));
    return w;
}
</code></pre></div><p>说明: registerWorker是 ForkJoinWorkerThread 构造器的回调函数，用于创建和记录工作线程的 WorkQueue。比较简单，就不多赘述了。注意在此为工作线程创建的 WorkQueue 是放在奇数索引的(代码行: i = ((s &lt;&lt; 1) | 1) &amp; m;)</p> <h4 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h4> <p>OK，外部任务的提交流程就先讲到这里。在createWorker()中启动工作线程后(wt.start())，当为线程分配到CPU执行时间片之后会运行
ForkJoinWorkerThread 的run方法开启线程来执行任务。工作线程执行任务的流程我们在讲完内部任务提交之后会统一讲解。</p> <h3 id="执行流程-子任务-worker-task-提交"><a href="#执行流程-子任务-worker-task-提交" class="header-anchor">#</a> 执行流程: 子任务(Worker task)提交</h3> <p>子任务的提交相对比较简单，由任务的fork()方法完成。通过上面的流程图可以看到任务被分割(fork)之后调用了ForkJoinPool.WorkQueue.push()方法直接把任务放到队列中等待被执行。</p> <h4 id="forkjointask-fork"><a href="#forkjointask-fork" class="header-anchor">#</a> ForkJoinTask.fork()</h4> <div class="language- extra-class"><pre><code>public final ForkJoinTask&lt;V&gt; fork() {
    Thread t;
    if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)
        ((ForkJoinWorkerThread)t).workQueue.push(this);
    else
        ForkJoinPool.common.externalPush(this);
    return this;
}
</code></pre></div><p>说明: 如果当前线程是 Worker
线程，说明当前任务是fork分割的子任务，通过ForkJoinPool.workQueue.push()方法直接把任务放到自己的等待队列中；否则调用ForkJoinPool.externalPush()提交到一个随机的等待队列中(外部任务)。</p> <h4 id="forkjoinpool-workqueue-push"><a href="#forkjoinpool-workqueue-push" class="header-anchor">#</a> ForkJoinPool.WorkQueue.push()</h4> <div class="language- extra-class"><pre><code>final void push(ForkJoinTask&lt;?&gt; task) {
    ForkJoinTask&lt;?&gt;[] a;
    ForkJoinPool p;
    int b = base, s = top, n;
    if ((a = array) != null) {    // ignore if queue removed
        int m = a.length - 1;     // fenced write for task visibility
        U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);
        U.putOrderedInt(this, QTOP, s + 1);
        if ((n = s - b) &lt;= 1) {//首次提交，创建或唤醒一个工作线程
            if ((p = pool) != null)
                p.signalWork(p.workQueues, this);
        } else if (n &gt;= m)
            growArray();
    }
}
</code></pre></div><p>说明: 首先把任务放入等待队列并更新top位；如果当前 WorkQueue 为新建的等待队列(top-base&lt;=1)，则调用signalWork方法为当前
WorkQueue 新建或唤醒一个工作线程；如果 WorkQueue
中的任务数组容量过小，则调用growArray()方法对其进行两倍扩容，growArray()方法源码如下:</p> <div class="language- extra-class"><pre><code>final ForkJoinTask&lt;?&gt;[] growArray() {
    ForkJoinTask&lt;?&gt;[] oldA = array;//获取内部任务列表
    int size = oldA != null ? oldA.length &lt;&lt; 1 : INITIAL_QUEUE_CAPACITY;
    if (size &gt; MAXIMUM_QUEUE_CAPACITY)
        throw new RejectedExecutionException(&quot;Queue capacity exceeded&quot;);
    int oldMask, t, b;
    //新建一个两倍容量的任务数组
    ForkJoinTask&lt;?&gt;[] a = array = new ForkJoinTask&lt;?&gt;[size];
    if (oldA != null &amp;&amp; (oldMask = oldA.length - 1) &gt;= 0 &amp;&amp;
            (t = top) - (b = base) &gt; 0) {
        int mask = size - 1;
        //从老数组中拿出数据，放到新的数组中
        do { // emulate poll from old array, push to new array
            ForkJoinTask&lt;?&gt; x;
            int oldj = ((b &amp; oldMask) &lt;&lt; ASHIFT) + ABASE;
            int j = ((b &amp; mask) &lt;&lt; ASHIFT) + ABASE;
            x = (ForkJoinTask&lt;?&gt;) U.getObjectVolatile(oldA, oldj);
            if (x != null &amp;&amp;
                    U.compareAndSwapObject(oldA, oldj, x, null))
                U.putObjectVolatile(a, j, x);
        } while (++b != t);
    }
    return a;
}
</code></pre></div><h4 id="小结-2"><a href="#小结-2" class="header-anchor">#</a> 小结</h4> <p>到此，两种任务的提交流程都已经解析完毕，下一节我们来一起看看任务提交之后是如何被运行的。</p> <h3 id="执行流程-任务执行"><a href="#执行流程-任务执行" class="header-anchor">#</a> 执行流程: 任务执行</h3> <p>回到我们开始时的流程图，在ForkJoinPool
.createWorker()方法中创建工作线程后，会启动工作线程，系统为工作线程分配到CPU执行时间片之后会执行 ForkJoinWorkerThread
的run()方法正式开始执行任务。</p> <h4 id="forkjoinworkerthread-run"><a href="#forkjoinworkerthread-run" class="header-anchor">#</a> ForkJoinWorkerThread.run()</h4> <div class="language- extra-class"><pre><code>public void run() {
    if (workQueue.array == null) { // only run once
        Throwable exception = null;
        try {
            onStart();//钩子方法，可自定义扩展
            pool.runWorker(workQueue);
        } catch (Throwable ex) {
            exception = ex;
        } finally {
            try {
                onTermination(exception);//钩子方法，可自定义扩展
            } catch (Throwable ex) {
                if (exception == null)
                    exception = ex;
            } finally {
                pool.deregisterWorker(this, exception);//处理异常
            }
        }
    }
}
</code></pre></div><p>说明:
方法很简单，在工作线程运行前后会调用自定义钩子函数(onStart和onTermination)，任务的运行则是调用了ForkJoinPool.runWorker()。如果全部任务执行完毕或者期间遭遇异常，则通过ForkJoinPool.deregisterWorker关闭工作线程并处理异常信息(deregisterWorker方法我们后面会详细讲解)。</p> <h4 id="forkjoinpool-runworker-workqueue-w"><a href="#forkjoinpool-runworker-workqueue-w" class="header-anchor">#</a> ForkJoinPool.runWorker(WorkQueue w)</h4> <div class="language- extra-class"><pre><code>final void runWorker(WorkQueue w) {
    w.growArray();                   // allocate queue
    int seed = w.hint;               // initially holds randomization hint
    int r = (seed == 0) ? 1 : seed;  // avoid 0 for xorShift
    for (ForkJoinTask&lt;?&gt; t; ; ) {
        if ((t = scan(w, r)) != null)//扫描任务执行
            w.runTask(t);
        else if (!awaitWork(w, r))
            break;
        r ^= r &lt;&lt; 13;
        r ^= r &gt;&gt;&gt; 17;
        r ^= r &lt;&lt; 5; // xorshift
    }
}
</code></pre></div><p>说明: runWorker是 ForkJoinWorkerThread 的主运行方法，用来依次执行当前工作线程中的任务。函数流程很简单:
调用scan方法依次获取任务，然后调用WorkQueue
.runTask运行任务；如果未扫描到任务，则调用awaitWork等待，直到工作线程/线程池终止或等待超时。</p> <h4 id="forkjoinpool-scan-workqueue-w-int-r"><a href="#forkjoinpool-scan-workqueue-w-int-r" class="header-anchor">#</a> ForkJoinPool.scan(WorkQueue w, int r)</h4> <div class="language- extra-class"><pre><code>private ForkJoinTask&lt;?&gt; scan(WorkQueue w, int r) {
    WorkQueue[] ws;
    int m;
    if ((ws = workQueues) != null &amp;&amp; (m = ws.length - 1) &gt; 0 &amp;&amp; w != null) {
        int ss = w.scanState;                     // initially non-negative
        //初始扫描起点，自旋扫描
        for (int origin = r &amp; m, k = origin, oldSum = 0, checkSum = 0; ; ) {
            WorkQueue q;
            ForkJoinTask&lt;?&gt;[] a;
            ForkJoinTask&lt;?&gt; t;
            int b, n;
            long c;
            if ((q = ws[k]) != null) {//获取workQueue
                if ((n = (b = q.base) - q.top) &lt; 0 &amp;&amp;
                        (a = q.array) != null) {      // non-empty
                    //计算偏移量
                    long i = (((a.length - 1) &amp; b) &lt;&lt; ASHIFT) + ABASE;
                    if ((t = ((ForkJoinTask&lt;?&gt;)
                            U.getObjectVolatile(a, i))) != null &amp;&amp; //取base位置任务
                            q.base == b) {//stable
                        if (ss &gt;= 0) {  //scanning
                            if (U.compareAndSwapObject(a, i, t, null)) {//
                                q.base = b + 1;//更新base位
                                if (n &lt; -1)       // signal others
                                    signalWork(ws, q);//创建或唤醒工作线程来运行任务
                                return t;
                            }
                        } else if (oldSum == 0 &amp;&amp;   // try to activate 尝试激活工作线程
                                w.scanState &lt; 0)
                            tryRelease(c = ctl, ws[m &amp; (int) c], AC_UNIT);//唤醒栈顶工作线程
                    }
                    //base位置任务为空或base位置偏移，随机移位重新扫描
                    if (ss &lt; 0)                   // refresh
                        ss = w.scanState;
                    r ^= r &lt;&lt; 1;
                    r ^= r &gt;&gt;&gt; 3;
                    r ^= r &lt;&lt; 10;
                    origin = k = r &amp; m;           // move and rescan
                    oldSum = checkSum = 0;
                    continue;
                }
                checkSum += b;//队列任务为空，记录base位
            }
            //更新索引k 继续向后查找
            if ((k = (k + 1) &amp; m) == origin) {    // continue until stable
                //运行到这里说明已经扫描了全部的 workQueues，但并未扫描到任务

                if ((ss &gt;= 0 || (ss == (ss = w.scanState))) &amp;&amp;
                        oldSum == (oldSum = checkSum)) {
                    if (ss &lt; 0 || w.qlock &lt; 0)    // already inactive
                        break;// 已经被灭活或终止,跳出循环

                    //对当前WorkQueue进行灭活操作
                    int ns = ss | INACTIVE;       // try to inactivate
                    long nc = ((SP_MASK &amp; ns) |
                            (UC_MASK &amp; ((c = ctl) - AC_UNIT)));//计算ctl为INACTIVE状态并减少活跃线程数
                    w.stackPred = (int) c;         // hold prev stack top
                    U.putInt(w, QSCANSTATE, ns);//修改scanState为inactive状态
                    if (U.compareAndSwapLong(this, CTL, c, nc))//更新scanState为灭活状态
                        ss = ns;
                    else
                        w.scanState = ss;         // back out
                }
                checkSum = 0;//重置checkSum，继续循环
            }
        }
    }
    return null;
}
</code></pre></div><p>说明: 扫描并尝试偷取一个任务。使用w.hint进行随机索引 WorkQueue，也就是说并不一定会执行当前 WorkQueue
中的任务，而是偷取别的Worker的任务来执行。</p> <p>函数的大概执行流程如下:</p> <ul><li><p>取随机位置的一个 WorkQueue；</p></li> <li><p>获取base位的 ForkJoinTask，成功取到后更新base位并返回任务；如果取到的 WorkQueue 中任务数大于1，则调用signalWork创建或唤醒其他工作线程；</p></li> <li><p>如果当前工作线程处于不活跃状态(INACTIVE)，则调用tryRelease尝试唤醒栈顶工作线程来执行。</p></li></ul> <p>tryRelease源码如下:</p> <div class="language- extra-class"><pre><code>    private boolean tryRelease(long c, WorkQueue v, long inc) {
    int sp = (int) c, vs = (sp + SS_SEQ) &amp; ~INACTIVE;
    Thread p;
    //ctl低32位等于scanState，说明可以唤醒parker线程
    if (v != null &amp;&amp; v.scanState == sp) {          // v is at top of stack
        //计算活跃线程数(高32位)并更新为下一个栈顶的scanState(低32位)
        long nc = (UC_MASK &amp; (c + inc)) | (SP_MASK &amp; v.stackPred);
        if (U.compareAndSwapLong(this, CTL, c, nc)) {
            v.scanState = vs;
            if ((p = v.parker) != null)
                U.unpark(p);//唤醒线程
            return true;
        }
    }
    return false;
}
</code></pre></div><ul><li><p>如果base位任务为空或发生偏移，则对索引位进行随机移位，然后重新扫描；</p></li> <li><p>如果扫描整个workQueues之后没有获取到任务，则设置当前工作线程为INACTIVE状态；然后重置checkSum，再次扫描一圈之后如果还没有任务则跳出循环返回null。</p></li></ul> <h4 id="forkjoinpool-awaitwork-workqueue-w-int-r"><a href="#forkjoinpool-awaitwork-workqueue-w-int-r" class="header-anchor">#</a> ForkJoinPool.awaitWork(WorkQueue w, int r)</h4> <div class="language- extra-class"><pre><code>private boolean awaitWork(WorkQueue w, int r) {
    if (w == null || w.qlock &lt; 0)                 // w is terminating
        return false;
    for (int pred = w.stackPred, spins = SPINS, ss; ; ) {
        if ((ss = w.scanState) &gt;= 0)//正在扫描，跳出循环
            break;
        else if (spins &gt; 0) {
            r ^= r &lt;&lt; 6;
            r ^= r &gt;&gt;&gt; 21;
            r ^= r &lt;&lt; 7;
            if (r &gt;= 0 &amp;&amp; --spins == 0) {         // randomize spins
                WorkQueue v;
                WorkQueue[] ws;
                int s, j;
                AtomicLong sc;
                if (pred != 0 &amp;&amp; (ws = workQueues) != null &amp;&amp;
                        (j = pred &amp; SMASK) &lt; ws.length &amp;&amp;
                        (v = ws[j]) != null &amp;&amp;        // see if pred parking
                        (v.parker == null || v.scanState &gt;= 0))
                    spins = SPINS;                // continue spinning
            }
        } else if (w.qlock &lt; 0)                     // 当前workQueue已经终止，返回false recheck after spins
            return false;
        else if (!Thread.interrupted()) {//判断线程是否被中断，并清除中断状态
            long c, prevctl, parkTime, deadline;
            int ac = (int) ((c = ctl) &gt;&gt; AC_SHIFT) + (config &amp; SMASK);//活跃线程数
            if ((ac &lt;= 0 &amp;&amp; tryTerminate(false, false)) || //无active线程，尝试终止
                    (runState &amp; STOP) != 0)           // pool terminating
                return false;
            if (ac &lt;= 0 &amp;&amp; ss == (int) c) {        // is last waiter
                //计算活跃线程数(高32位)并更新为下一个栈顶的scanState(低32位)
                prevctl = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; pred);
                int t = (short) (c &gt;&gt;&gt; TC_SHIFT);  // shrink excess spares
                if (t &gt; 2 &amp;&amp; U.compareAndSwapLong(this, CTL, c, prevctl))//总线程过量
                    return false;                 // else use timed wait
                //计算空闲超时时间
                parkTime = IDLE_TIMEOUT * ((t &gt;= 0) ? 1 : 1 - t);
                deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;
            } else
                prevctl = parkTime = deadline = 0L;
            Thread wt = Thread.currentThread();
            U.putObject(wt, PARKBLOCKER, this);   // emulate LockSupport
            w.parker = wt;//设置parker，准备阻塞
            if (w.scanState &lt; 0 &amp;&amp; ctl == c)      // recheck before park
                U.park(false, parkTime);//阻塞指定的时间

            U.putOrderedObject(w, QPARKER, null);
            U.putObject(wt, PARKBLOCKER, null);
            if (w.scanState &gt;= 0)//正在扫描，说明等到任务，跳出循环
                break;
            if (parkTime != 0L &amp;&amp; ctl == c &amp;&amp;
                    deadline - System.nanoTime() &lt;= 0L &amp;&amp;
                    U.compareAndSwapLong(this, CTL, c, prevctl))//未等到任务，更新ctl，返回false
                return false;                     // shrink pool
        }
    }
    return true;
}
</code></pre></div><p>说明: 回到runWorker方法，如果scan方法未扫描到任务，会调用awaitWork等待获取任务。函数的具体执行流程大家看源码，这里简单说一下:</p> <ul><li>在等待获取任务期间，如果工作线程或线程池已经终止则直接返回false。如果当前无 active 线程，尝试终止线程池并返回false，如果终止失败并且当前是最后一个等待的 Worker，就阻塞指定的时间(IDLE_TIMEOUT)；等到届期或被唤醒后如果发现自己是scanning(scanState &gt;= 0)状态，说明已经等到任务，跳出等待返回true继续 scan，否则的更新ctl并返回false。</li></ul> <h4 id="workqueue-runtask"><a href="#workqueue-runtask" class="header-anchor">#</a> WorkQueue.runTask()</h4> <div class="language- extra-class"><pre><code>final void runTask(ForkJoinTask&lt;?&gt; task) {
    if (task != null) {
        scanState &amp;= ~SCANNING; // mark as busy
        (currentSteal = task).doExec();//更新currentSteal并执行任务
        U.putOrderedObject(this, QCURRENTSTEAL, null); // release for GC
        execLocalTasks();//依次执行本地任务
        ForkJoinWorkerThread thread = owner;
        if (++nsteals &lt; 0)      // collect on overflow
            transferStealCount(pool);//增加偷取任务数
        scanState |= SCANNING;
        if (thread != null)
            thread.afterTopLevelExec();//执行钩子函数
    }
}
</code></pre></div><p>说明: 在scan方法扫描到任务之后，调用WorkQueue.runTask()来执行获取到的任务，大概流程如下:</p> <ul><li><p>标记scanState为正在执行状态；</p></li> <li><p>更新currentSteal为当前获取到的任务并执行它，任务的执行调用了ForkJoinTask.doExec()方法，源码如下:</p> <div class="language- extra-class"><pre><code>//ForkJoinTask.doExec()
</code></pre></div><p>final int doExec() {
int s; boolean completed;
if ((s = status) &gt;= 0) {
try {
completed = exec();//执行我们定义的任务
} catch (Throwable rex) {
return setExceptionalCompletion(rex);
}
if (completed)
s = setCompletion(NORMAL);
}
return s;
}</p></li> <li><p>调用execLocalTasks依次执行当前WorkerQueue中的任务，源码如下:</p> <div class="language- extra-class"><pre><code>//执行并移除所有本地任务
</code></pre></div><p>final void execLocalTasks() {
int b = base, m, s;
ForkJoinTask&lt;?&gt;[] a = array;
if (b - (s = top - 1) &lt;= 0 &amp;&amp; a != null &amp;&amp;
(m = a.length - 1) &gt;= 0) {
if ((config &amp; FIFO_QUEUE) == 0) {//FIFO模式
for (ForkJoinTask&lt;?&gt; t; ; ) {
if ((t = (ForkJoinTask&lt;?&gt;) U.getAndSetObject
(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, null)) == null)//FIFO执行，取top任务
break;
U.putOrderedInt(this, QTOP, s);
t.doExec();//执行
if (base - (s = top - 1) &gt; 0)
break;
}
} else
pollAndExecAll();//LIFO模式执行，取base任务
}
}</p></li> <li><p>更新偷取任务数；</p></li> <li><p>还原scanState并执行钩子函数。</p></li></ul> <h4 id="forkjoinpool-deregisterworker-forkjoinworkerthread-wt-throwable-ex"><a href="#forkjoinpool-deregisterworker-forkjoinworkerthread-wt-throwable-ex" class="header-anchor">#</a> ForkJoinPool.deregisterWorker(ForkJoinWorkerThread wt, Throwable ex)</h4> <div class="language- extra-class"><pre><code>final void deregisterWorker(ForkJoinWorkerThread wt, Throwable ex) {
    WorkQueue w = null;
    //1.移除workQueue
    if (wt != null &amp;&amp; (w = wt.workQueue) != null) {//获取ForkJoinWorkerThread的等待队列
        WorkQueue[] ws;                           // remove index from array
        int idx = w.config &amp; SMASK;//计算workQueue索引
        int rs = lockRunState();//获取runState锁和当前池运行状态
        if ((ws = workQueues) != null &amp;&amp; ws.length &gt; idx &amp;&amp; ws[idx] == w)
            ws[idx] = null;//移除workQueue
        unlockRunState(rs, rs &amp; ~RSLOCK);//解除runState锁
    }
    //2.减少CTL数
    long c;                                       // decrement counts
    do {} while (!U.compareAndSwapLong
                 (this, CTL, c = ctl, ((AC_MASK &amp; (c - AC_UNIT)) |
                                       (TC_MASK &amp; (c - TC_UNIT)) |
                                       (SP_MASK &amp; c))));
    //3.处理被移除workQueue内部相关参数
    if (w != null) {
        w.qlock = -1;                             // ensure set
        w.transferStealCount(this);
        w.cancelAll();                            // cancel remaining tasks
    }
    //4.如果线程未终止，替换被移除的workQueue并唤醒内部线程
    for (;;) {                                    // possibly replace
        WorkQueue[] ws; int m, sp;
        //尝试终止线程池
        if (tryTerminate(false, false) || w == null || w.array == null ||
            (runState &amp; STOP) != 0 || (ws = workQueues) == null ||
            (m = ws.length - 1) &lt; 0)              // already terminating
            break;
        //唤醒被替换的线程，依赖于下一步
        if ((sp = (int)(c = ctl)) != 0) {         // wake up replacement
            if (tryRelease(c, ws[sp &amp; m], AC_UNIT))
                break;
        }
        //创建工作线程替换
        else if (ex != null &amp;&amp; (c &amp; ADD_WORKER) != 0L) {
            tryAddWorker(c);                      // create replacement
            break;
        }
        else                                      // don't need replacement
            break;
    }
    //5.处理异常
    if (ex == null)                               // help clean on way out
        ForkJoinTask.helpExpungeStaleExceptions();
    else                                          // rethrow
        ForkJoinTask.rethrow(ex);
}
</code></pre></div><p>说明:
deregisterWorker方法用于工作线程运行完毕之后终止线程或处理工作线程异常，主要就是清除已关闭的工作线程或回滚创建线程之前的操作，并把传入的异常抛给
ForkJoinTask 来处理。具体步骤见源码注释。</p> <h4 id="小结-3"><a href="#小结-3" class="header-anchor">#</a> 小结</h4> <p>本节我们对任务的执行流程进行了说明，后面我们将继续介绍任务的结果获取(join/invoke)。</p> <h3 id="获取任务结果-forkjointask-join-forkjointask-invoke"><a href="#获取任务结果-forkjointask-join-forkjointask-invoke" class="header-anchor">#</a> 获取任务结果 - ForkJoinTask.join() / ForkJoinTask.invoke()</h3> <ul><li><p>join() :</p> <p>//合并任务结果
public final V join() {
int s;
if ((s = doJoin() &amp; DONE_MASK) != NORMAL)
reportException(s);
return getRawResult();
}</p> <p>//join, get, quietlyJoin的主实现方法
private int doJoin() {
int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;
return (s = status) &lt; 0 ? s :
((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?
(w = (wt = (ForkJoinWorkerThread)t).workQueue).
tryUnpush(this) &amp;&amp; (s = doExec()) &lt; 0 ? s :
wt.pool.awaitJoin(w, this, 0L) :
externalAwaitDone();
}</p></li> <li><p>invoke() :</p> <p>//执行任务，并等待任务完成并返回结果
public final V invoke() {
int s;
if ((s = doInvoke() &amp; DONE_MASK) != NORMAL)
reportException(s);
return getRawResult();
}</p> <p>//invoke, quietlyInvoke的主实现方法
private int doInvoke() {
int s; Thread t; ForkJoinWorkerThread wt;
return (s = doExec()) &lt; 0 ? s :
((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?
(wt = (ForkJoinWorkerThread)t).pool.
awaitJoin(wt.workQueue, this, 0L) :
externalAwaitDone();
}</p></li></ul> <p>说明: join()方法一把是在任务fork()之后调用，用来获取(或者叫“合并”)任务的执行结果。</p> <p>ForkJoinTask的join()和invoke()方法都可以用来获取任务的执行结果(另外还有get方法也是调用了doJoin来获取任务结果，但是会响应运行时异常)，它们对外部提交任务的执行方式一致，都是通过externalAwaitDone方法等待执行结果。不同的是invoke()方法会直接执行当前任务；而join()方法则是在当前任务在队列
top 位时(通过tryUnpush方法判断)才能执行，如果当前任务不在 top
位或者任务执行失败调用ForkJoinPool.awaitJoin方法帮助执行或阻塞当前 join
任务。(所以在官方文档中建议了我们对ForkJoinTask任务的调用顺序，一对 fork-join操作一般按照如下顺序调用: a.fork();
b.fork(); b.join(); a.join();。因为任务 b 是后面进入队列，也就是说它是在栈顶的(top
位)，在它fork()之后直接调用join()就可以直接执行而不会调用ForkJoinPool.awaitJoin方法去等待。)</p> <p>在这些方法中，join()相对比较全面，所以之后的讲解我们将从join()开始逐步向下分析，首先看一下join()的执行流程:</p> <p><img src="https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/java-thread-x-forkjoin-6.png" alt="img"></p> <p>后面的源码分析中，我们首先讲解比较简单的外部 join 任务(externalAwaitDone)，然后再讲解内部 join
任务(从ForkJoinPool.awaitJoin()开始)。</p> <h4 id="forkjointask-externalawaitdone"><a href="#forkjointask-externalawaitdone" class="header-anchor">#</a> ForkJoinTask.externalAwaitDone()</h4> <div class="language- extra-class"><pre><code>private int externalAwaitDone() {
    //执行任务
    int s = ((this instanceof CountedCompleter) ? // try helping
             ForkJoinPool.common.externalHelpComplete(  // CountedCompleter任务
                 (CountedCompleter&lt;?&gt;)this, 0) :
             ForkJoinPool.common.tryExternalUnpush(this) ? doExec() : 0);  // ForkJoinTask任务
    if (s &gt;= 0 &amp;&amp; (s = status) &gt;= 0) {//执行失败，进入等待
        boolean interrupted = false;
        do {
            if (U.compareAndSwapInt(this, STATUS, s, s | SIGNAL)) {  //更新state
                synchronized (this) {
                    if (status &gt;= 0) {//SIGNAL 等待信号
                        try {
                            wait(0L);
                        } catch (InterruptedException ie) {
                            interrupted = true;
                        }
                    }
                    else
                        notifyAll();
                }
            }
        } while ((s = status) &gt;= 0);
        if (interrupted)
            Thread.currentThread().interrupt();
    }
    return s;
}
</code></pre></div><p>说明: 如果当前join为外部调用，则调用此方法执行任务，如果任务执行失败就进入等待。方法本身是很简单的，需要注意的是对不同的任务类型分两种情况:</p> <ul><li><p>如果我们的任务为 CountedCompleter 类型的任务，则调用externalHelpComplete方法来执行任务。</p></li> <li><p>其他类型的 ForkJoinTask 任务调用tryExternalUnpush来执行，源码如下:</p> <div class="language- extra-class"><pre><code>//为外部提交者提供 tryUnpush 功能(给定任务在top位时弹出任务)
</code></pre></div><p>final boolean tryExternalUnpush(ForkJoinTask&lt;?&gt; task) {
WorkQueue[] ws;
WorkQueue w;
ForkJoinTask&lt;?&gt;[] a;
int m, s;
int r = ThreadLocalRandom.getProbe();
if ((ws = workQueues) != null &amp;&amp; (m = ws.length - 1) &gt;= 0 &amp;&amp;
(w = ws[m &amp; r &amp; SQMASK]) != null &amp;&amp;
(a = w.array) != null &amp;&amp; (s = w.top) != w.base) {
long j = (((a.length - 1) &amp; (s - 1)) &lt;&lt; ASHIFT) + ABASE;  //取top位任务
if (U.compareAndSwapInt(w, QLOCK, 0, 1)) {  //加锁
if (w.top == s &amp;&amp; w.array == a &amp;&amp;
U.getObject(a, j) == task &amp;&amp;
U.compareAndSwapObject(a, j, task, null)) {  //符合条件，弹出
U.putOrderedInt(w, QTOP, s - 1);  //更新top
U.putOrderedInt(w, QLOCK, 0); //解锁，返回true
return true;
}
U.compareAndSwapInt(w, QLOCK, 1, 0);  //当前任务不在top位，解锁返回false
}
}
return false;
}</p></li></ul> <p>tryExternalUnpush的作用就是判断当前任务是否在top位，如果是则弹出任务，然后在externalAwaitDone中调用doExec()执行任务。</p> <h4 id="forkjoinpool-awaitjoin"><a href="#forkjoinpool-awaitjoin" class="header-anchor">#</a> ForkJoinPool.awaitJoin()</h4> <div class="language- extra-class"><pre><code>final int awaitJoin(WorkQueue w, ForkJoinTask&lt;?&gt; task, long deadline) {
    int s = 0;
    if (task != null &amp;&amp; w != null) {
        ForkJoinTask&lt;?&gt; prevJoin = w.currentJoin;  //获取给定Worker的join任务
        U.putOrderedObject(w, QCURRENTJOIN, task);  //把currentJoin替换为给定任务
        //判断是否为CountedCompleter类型的任务
        CountedCompleter&lt;?&gt; cc = (task instanceof CountedCompleter) ?
                (CountedCompleter&lt;?&gt;) task : null;
        for (; ; ) {
            if ((s = task.status) &lt; 0)  //已经完成|取消|异常 跳出循环
                break;

            if (cc != null)//CountedCompleter任务由helpComplete来完成join
                helpComplete(w, cc, 0);
            else if (w.base == w.top || w.tryRemoveAndExec(task))  //尝试执行
                helpStealer(w, task);  //队列为空或执行失败，任务可能被偷，帮助偷取者执行该任务

            if ((s = task.status) &lt; 0) //已经完成|取消|异常，跳出循环
                break;
            //计算任务等待时间
            long ms, ns;
            if (deadline == 0L)
                ms = 0L;
            else if ((ns = deadline - System.nanoTime()) &lt;= 0L)
                break;
            else if ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) &lt;= 0L)
                ms = 1L;

            if (tryCompensate(w)) {//执行补偿操作
                task.internalWait(ms);//补偿执行成功，任务等待指定时间
                U.getAndAddLong(this, CTL, AC_UNIT);//更新活跃线程数
            }
        }
        U.putOrderedObject(w, QCURRENTJOIN, prevJoin);//循环结束，替换为原来的join任务
    }
    return s;
}
</code></pre></div><p>说明: 如果当前 join 任务不在Worker等待队列的top位，或者任务执行失败，调用此方法来帮助执行或阻塞当前 join 的任务。函数执行流程如下:</p> <ul><li>由于每次调用awaitJoin都会优先执行当前join的任务，所以首先会更新currentJoin为当前join任务；</li> <li>进入自旋:
<ul><li><p>首先检查任务是否已经完成(通过task.status &lt; 0判断)，如果给定任务执行完毕|取消|异常 则跳出循环返回执行状态s；</p></li> <li><p>如果是 CountedCompleter 任务类型，调用helpComplete方法来完成join操作(后面笔者会开新篇来专门讲解CountedCompleter，本篇暂时不做详细解析)；</p></li> <li><p>非 CountedCompleter 任务类型调用WorkQueue.tryRemoveAndExec尝试执行任务；</p></li> <li><p>如果给定 WorkQueue 的等待队列为空或任务执行失败，说明任务可能被偷，调用helpStealer帮助偷取者执行任务(也就是说，偷取者帮我执行任务，我去帮偷取者执行它的任务)；</p></li> <li><p>再次判断任务是否执行完毕(task.status &lt; 0)，如果任务执行失败，计算一个等待时间准备进行补偿操作；</p></li> <li><p>调用tryCompensate方法为给定 WorkQueue 尝试执行补偿操作。在执行补偿期间，如果发现 资源争用|池处于unstable状态|当前Worker已终止，则调用ForkJoinTask.internalWait()方法等待指定的时间，任务唤醒之后继续自旋，ForkJoinTask.internalWait()源码如下:</p> <p>final void internalWait(long timeout) {
int s;
if ((s = status) &gt;= 0 &amp;&amp; // force completer to issue notify
U.compareAndSwapInt(this, STATUS, s, s | SIGNAL)) {//更新任务状态为SIGNAL(等待唤醒)
synchronized (this) {
if (status &gt;= 0)
try { wait(timeout); } catch (InterruptedException ie) { }
else
notifyAll();
}
}
}</p></li></ul></li></ul> <p>在awaitJoin中，我们总共调用了三个比较复杂的方法:
tryRemoveAndExec、helpStealer和tryCompensate，下面我们依次讲解。</p> <h4 id="workqueue-tryremoveandexec-forkjointask-task"><a href="#workqueue-tryremoveandexec-forkjointask-task" class="header-anchor">#</a> WorkQueue.tryRemoveAndExec(ForkJoinTask&lt;?&gt; task)</h4> <div class="language- extra-class"><pre><code>final boolean tryRemoveAndExec(ForkJoinTask&lt;?&gt; task) {
    ForkJoinTask&lt;?&gt;[] a;
    int m, s, b, n;
    if ((a = array) != null &amp;&amp; (m = a.length - 1) &gt;= 0 &amp;&amp;
            task != null) {
        while ((n = (s = top) - (b = base)) &gt; 0) {
            //从top往下自旋查找
            for (ForkJoinTask&lt;?&gt; t; ; ) {      // traverse from s to b
                long j = ((--s &amp; m) &lt;&lt; ASHIFT) + ABASE;//计算任务索引
                if ((t = (ForkJoinTask&lt;?&gt;) U.getObject(a, j)) == null) //获取索引到的任务
                    return s + 1 == top;     // shorter than expected
                else if (t == task) { //给定任务为索引任务
                    boolean removed = false;
                    if (s + 1 == top) {      // pop
                        if (U.compareAndSwapObject(a, j, task, null)) { //弹出任务
                            U.putOrderedInt(this, QTOP, s); //更新top
                            removed = true;
                        }
                    } else if (base == b)      // replace with proxy
                        removed = U.compareAndSwapObject(
                                a, j, task, new EmptyTask()); //join任务已经被移除，替换为一个占位任务
                    if (removed)
                        task.doExec(); //执行
                    break;
                } else if (t.status &lt; 0 &amp;&amp; s + 1 == top) { //给定任务不是top任务
                    if (U.compareAndSwapObject(a, j, t, null)) //弹出任务
                        U.putOrderedInt(this, QTOP, s);//更新top
                    break;                  // was cancelled
                }
                if (--n == 0) //遍历结束
                    return false;
            }
            if (task.status &lt; 0) //任务执行完毕
                return false;
        }
    }
    return true;
}
</code></pre></div><p>说明: 从top位开始自旋向下找到给定任务，如果找到把它从当前 Worker 的任务队列中移除并执行它。注意返回的参数:
如果任务队列为空或者任务未执行完毕返回true；任务执行完毕返回false。</p> <h4 id="forkjoinpool-helpstealer-workqueue-w-forkjointask-task"><a href="#forkjoinpool-helpstealer-workqueue-w-forkjointask-task" class="header-anchor">#</a> ForkJoinPool.helpStealer(WorkQueue w, ForkJoinTask&lt;?&gt; task)</h4> <div class="language- extra-class"><pre><code>private void helpStealer(WorkQueue w, ForkJoinTask&lt;?&gt; task) {
    WorkQueue[] ws = workQueues;
    int oldSum = 0, checkSum, m;
    if (ws != null &amp;&amp; (m = ws.length - 1) &gt;= 0 &amp;&amp; w != null &amp;&amp;
            task != null) {
        do {                                       // restart point
            checkSum = 0;                          // for stability check
            ForkJoinTask&lt;?&gt; subtask;
            WorkQueue j = w, v;                    // v is subtask stealer
            descent:
            for (subtask = task; subtask.status &gt;= 0; ) {
                //1. 找到给定WorkQueue的偷取者v
                for (int h = j.hint | 1, k = 0, i; ; k += 2) {//跳两个索引，因为Worker在奇数索引位
                    if (k &gt; m)                     // can't find stealer
                        break descent;
                    if ((v = ws[i = (h + k) &amp; m]) != null) {
                        if (v.currentSteal == subtask) {//定位到偷取者
                            j.hint = i;//更新stealer索引
                            break;
                        }
                        checkSum += v.base;
                    }
                }
                //2. 帮助偷取者v执行任务
                for (; ; ) {                         // help v or descend
                    ForkJoinTask&lt;?&gt;[] a;            //偷取者内部的任务
                    int b;
                    checkSum += (b = v.base);
                    ForkJoinTask&lt;?&gt; next = v.currentJoin;//获取偷取者的join任务
                    if (subtask.status &lt; 0 || j.currentJoin != subtask ||
                            v.currentSteal != subtask) // stale
                        break descent; // stale，跳出descent循环重来
                    if (b - v.top &gt;= 0 || (a = v.array) == null) {
                        if ((subtask = next) == null)   //偷取者的join任务为null，跳出descent循环
                            break descent;
                        j = v;
                        break; //偷取者内部任务为空，可能任务也被偷走了；跳出本次循环，查找偷取者的偷取者
                    }
                    int i = (((a.length - 1) &amp; b) &lt;&lt; ASHIFT) + ABASE;//获取base偏移地址
                    ForkJoinTask&lt;?&gt; t = ((ForkJoinTask&lt;?&gt;)
                            U.getObjectVolatile(a, i));//获取偷取者的base任务
                    if (v.base == b) {
                        if (t == null)             // stale
                            break descent; // stale，跳出descent循环重来
                        if (U.compareAndSwapObject(a, i, t, null)) {//弹出任务
                            v.base = b + 1;         //更新偷取者的base位
                            ForkJoinTask&lt;?&gt; ps = w.currentSteal;//获取调用者偷来的任务
                            int top = w.top;
                            //首先更新给定workQueue的currentSteal为偷取者的base任务，然后执行该任务
                            //然后通过检查top来判断给定workQueue是否有自己的任务，如果有，
                            // 则依次弹出任务(LIFO)-&gt;更新currentSteal-&gt;执行该任务(注意这里是自己偷自己的任务执行)
                            do {
                                U.putOrderedObject(w, QCURRENTSTEAL, t);
                                t.doExec();        // clear local tasks too
                            } while (task.status &gt;= 0 &amp;&amp;
                                    w.top != top &amp;&amp; //内部有自己的任务，依次弹出执行
                                    (t = w.pop()) != null);
                            U.putOrderedObject(w, QCURRENTSTEAL, ps);//还原给定workQueue的currentSteal
                            if (w.base != w.top)//给定workQueue有自己的任务了，帮助结束，返回
                                return;            // can't further help
                        }
                    }
                }
            }
        } while (task.status &gt;= 0 &amp;&amp; oldSum != (oldSum = checkSum));
    }
}
</code></pre></div><p>说明: 如果队列为空或任务执行失败，说明任务可能被偷，调用此方法来帮助偷取者执行任务。基本思想是: 偷取者帮助我执行任务，我去帮助偷取者执行它的任务。
函数执行流程如下:</p> <p>循环定位偷取者，由于Worker是在奇数索引位，所以每次会跳两个索引位。定位到偷取者之后，更新调用者 WorkQueue
的hint为偷取者的索引，方便下次定位；
定位到偷取者后，开始帮助偷取者执行任务。从偷取者的base索引开始，每次偷取一个任务执行。在帮助偷取者执行任务后，如果调用者发现本身已经有任务(w.top
!= top)，则依次弹出自己的任务(LIFO顺序)并执行(也就是说自己偷自己的任务执行)。</p> <h4 id="forkjoinpool-trycompensate-workqueue-w"><a href="#forkjoinpool-trycompensate-workqueue-w" class="header-anchor">#</a> ForkJoinPool.tryCompensate(WorkQueue w)</h4> <div class="language- extra-class"><pre><code>//执行补偿操作: 尝试缩减活动线程量，可能释放或创建一个补偿线程来准备阻塞
private boolean tryCompensate(WorkQueue w) {
    boolean canBlock;
    WorkQueue[] ws;
    long c;
    int m, pc, sp;
    if (w == null || w.qlock &lt; 0 ||           // caller terminating
            (ws = workQueues) == null || (m = ws.length - 1) &lt;= 0 ||
            (pc = config &amp; SMASK) == 0)           // parallelism disabled
        canBlock = false; //调用者已终止
    else if ((sp = (int) (c = ctl)) != 0)      // release idle worker
        canBlock = tryRelease(c, ws[sp &amp; m], 0L);//唤醒等待的工作线程
    else {//没有空闲线程
        int ac = (int) (c &gt;&gt; AC_SHIFT) + pc; //活跃线程数
        int tc = (short) (c &gt;&gt; TC_SHIFT) + pc;//总线程数
        int nbusy = 0;                        // validate saturation
        for (int i = 0; i &lt;= m; ++i) {        // two passes of odd indices
            WorkQueue v;
            if ((v = ws[((i &lt;&lt; 1) | 1) &amp; m]) != null) {//取奇数索引位
                if ((v.scanState &amp; SCANNING) != 0)//没有正在运行任务，跳出
                    break;
                ++nbusy;//正在运行任务，添加标记
            }
        }
        if (nbusy != (tc &lt;&lt; 1) || ctl != c)
            canBlock = false;                 // unstable or stale
        else if (tc &gt;= pc &amp;&amp; ac &gt; 1 &amp;&amp; w.isEmpty()) {//总线程数大于并行度 &amp;&amp; 活动线程数大于1 &amp;&amp; 调用者任务队列为空，不需要补偿
            long nc = ((AC_MASK &amp; (c - AC_UNIT)) |
                    (~AC_MASK &amp; c));       // uncompensated
            canBlock = U.compareAndSwapLong(this, CTL, c, nc);//更新活跃线程数
        } else if (tc &gt;= MAX_CAP ||
                (this == common &amp;&amp; tc &gt;= pc + commonMaxSpares))//超出最大线程数
            throw new RejectedExecutionException(
                    &quot;Thread limit exceeded replacing blocked worker&quot;);
        else {                                // similar to tryAddWorker
            boolean add = false;
            int rs;      // CAS within lock
            long nc = ((AC_MASK &amp; c) |
                    (TC_MASK &amp; (c + TC_UNIT)));//计算总线程数
            if (((rs = lockRunState()) &amp; STOP) == 0)
                add = U.compareAndSwapLong(this, CTL, c, nc);//更新总线程数
            unlockRunState(rs, rs &amp; ~RSLOCK);
            //运行到这里说明活跃工作线程数不足，需要创建一个新的工作线程来补偿
            canBlock = add &amp;&amp; createWorker(); // throws on exception
        }
    }
    return canBlock;
}
</code></pre></div><p>说明: 具体的执行看源码及注释，这里我们简单总结一下需要和不需要补偿的几种情况:</p> <p><strong>需要补偿</strong> :</p> <ul><li>调用者队列不为空，并且有空闲工作线程，这种情况会唤醒空闲线程(调用tryRelease方法)</li> <li>池尚未停止，活跃线程数不足，这时会新建一个工作线程(调用createWorker方法)</li></ul> <p><strong>不需要补偿</strong> :</p> <ul><li>调用者已终止或池处于不稳定状态</li> <li>总线程数大于并行度 &amp;&amp; 活动线程数大于1 &amp;&amp; 调用者任务队列为空</li></ul> <h2 id="fork-join的陷阱与注意事项"><a href="#fork-join的陷阱与注意事项" class="header-anchor">#</a> Fork/Join的陷阱与注意事项</h2> <p>使用Fork/Join框架时，需要注意一些陷阱, 在下面 <code>斐波那契数列</code>例子中你将看到示例:</p> <h3 id="避免不必要的fork"><a href="#避免不必要的fork" class="header-anchor">#</a> 避免不必要的fork()</h3> <p>划分成两个子任务后，不要同时调用两个子任务的fork()方法。</p> <p>表面上看上去两个子任务都fork()，然后join()两次似乎更自然。但事实证明，直接调用compute()效率更高。因为直接调用子任务的compute()方法实际上就是在当前的工作线程进行了计算(线程重用)，这比“将子任务提交到工作队列，线程又从工作队列中拿任务”快得多。</p> <blockquote><p>当一个大任务被划分成两个以上的子任务时，尽可能使用前面说到的三个衍生的invokeAll方法，因为使用它们能避免不必要的fork()。</p></blockquote> <h3 id="注意fork-、compute-、join-的顺序"><a href="#注意fork-、compute-、join-的顺序" class="header-anchor">#</a> 注意fork()、compute()、join()的顺序</h3> <p>为了两个任务并行，三个方法的调用顺序需要万分注意。</p> <div class="language- extra-class"><pre><code>right.fork(); // 计算右边的任务
long leftAns = left.compute(); // 计算左边的任务(同时右边任务也在计算)
long rightAns = right.join(); // 等待右边的结果
return leftAns + rightAns;
</code></pre></div><p>如果我们写成:</p> <div class="language- extra-class"><pre><code>left.fork(); // 计算完左边的任务
long leftAns = left.join(); // 等待左边的计算结果
long rightAns = right.compute(); // 再计算右边的任务
return leftAns + rightAns;
</code></pre></div><p>或者</p> <div class="language- extra-class"><pre><code>long rightAns = right.compute(); // 计算完右边的任务
left.fork(); // 再计算左边的任务
long leftAns = left.join(); // 等待左边的计算结果
return leftAns + rightAns;
</code></pre></div><p>这两种实际上都没有并行。</p> <h3 id="选择合适的子任务粒度"><a href="#选择合适的子任务粒度" class="header-anchor">#</a> 选择合适的子任务粒度</h3> <p>选择划分子任务的粒度(顺序执行的阈值)很重要，因为使用Fork/Join框架并不一定比顺序执行任务的效率高:
如果任务太大，则无法提高并行的吞吐量；如果任务太小，子任务的调度开销可能会大于并行计算的性能提升，我们还要考虑创建子任务、fork()子任务、线程调度以及合并子任务处理结果的耗时以及相应的内存消耗。</p> <p>官方文档给出的粗略经验是:
任务应该执行<code>100~10000</code>个基本的计算步骤。决定子任务的粒度的最好办法是实践，通过实际测试结果来确定这个阈值才是“上上策”。</p> <blockquote><p>和其他Java代码一样，Fork/Join框架测试时需要“预热”或者说执行几遍才会被JIT(Just-in-
time)编译器优化，所以测试性能之前跑几遍程序很重要。</p></blockquote> <h3 id="避免重量级任务划分与结果合并"><a href="#避免重量级任务划分与结果合并" class="header-anchor">#</a> 避免重量级任务划分与结果合并</h3> <p>Fork/Join的很多使用场景都用到数组或者List等数据结构，子任务在某个分区中运行，最典型的例子如并行排序和并行查找。拆分子任务以及合并处理结果的时候，应该尽量避免System.arraycopy这样耗时耗空间的操作，从而最小化任务的处理开销。</p> <h2 id="再深入理解"><a href="#再深入理解" class="header-anchor">#</a> 再深入理解</h2> <h3 id="有哪些jdk源码中使用了fork-join思想"><a href="#有哪些jdk源码中使用了fork-join思想" class="header-anchor">#</a> 有哪些JDK源码中使用了Fork/Join思想?</h3> <p>我们常用的数组工具类 Arrays 在JDK 8之后新增的并行排序方法(parallelSort)就运用了 ForkJoinPool 的特性，还有
ConcurrentHashMap 在JDK 8之后添加的函数式方法(如forEach等)也有运用。</p> <h3 id="使用executors工具类创建forkjoinpool"><a href="#使用executors工具类创建forkjoinpool" class="header-anchor">#</a> 使用Executors工具类创建ForkJoinPool</h3> <p>Java8在Executors工具类中新增了两个工厂方法:</p> <div class="language- extra-class"><pre><code>// parallelism定义并行级别
public static ExecutorService newWorkStealingPool(int parallelism);
// 默认并行级别为JVM可用的处理器个数
// Runtime.getRuntime().availableProcessors()
public static ExecutorService newWorkStealingPool();
</code></pre></div><h3 id="关于fork-join异常处理"><a href="#关于fork-join异常处理" class="header-anchor">#</a> 关于Fork/Join异常处理</h3> <p>Java的受检异常机制一直饱受诟病，所以在ForkJoinTask的invoke()、join()方法及其衍生方法中都没有像get()方法那样抛出个ExecutionException的受检异常。</p> <p>所以你可以在ForkJoinTask中看到内部把受检异常转换成了运行时异常。</p> <div class="language- extra-class"><pre><code>static void rethrow(Throwable ex) {
    if (ex != null)
        ForkJoinTask.&lt;RuntimeException&gt;uncheckedThrow(ex);
}

@SuppressWarnings(&quot;unchecked&quot;)
static &lt;T extends Throwable&gt; void uncheckedThrow(Throwable t) throws T {
    throw (T)t; // rely on vacuous cast
}
</code></pre></div><p>关于Java你不知道的10件事中已经指出，JVM实际并不关心这个异常是受检异常还是运行时异常，受检异常这东西完全是给Java编译器用的:
用于警告程序员这里有个异常没有处理。</p> <p>但不可否认的是invoke、join()仍可能会抛出运行时异常，所以ForkJoinTask还提供了两个不提取结果和异常的方法quietlyInvoke()、quietlyJoin()，这两个方法允许你在所有任务完成后对结果和异常进行处理。</p> <p>使用quitelyInvoke()和quietlyJoin()时可以配合isCompletedAbnormally()和isCompletedNormally()方法使用。</p> <h2 id="一些fork-join例子"><a href="#一些fork-join例子" class="header-anchor">#</a> 一些Fork/Join例子</h2> <h3 id="采用fork-join来异步计算1-2-3-10000的结果"><a href="#采用fork-join来异步计算1-2-3-10000的结果" class="header-anchor">#</a> 采用Fork/Join来异步计算1+2+3+…+10000的结果</h3> <div class="language- extra-class"><pre><code>public class Test {
    static final class SumTask extends RecursiveTask&lt;Integer&gt; {
        private static final long serialVersionUID = 1L;
        
        final int start; //开始计算的数
        final int end; //最后计算的数
        
        SumTask(int start, int end) {
            this.start = start;
            this.end = end;
        }

        @Override
        protected Integer compute() {
            //如果计算量小于1000，那么分配一个线程执行if中的代码块，并返回执行结果
            if(end - start &lt; 1000) {
                System.out.println(Thread.currentThread().getName() + &quot; 开始执行: &quot; + start + &quot;-&quot; + end);
                int sum = 0;
                for(int i = start; i &lt;= end; i++)
                    sum += i;
                return sum;
            }
            //如果计算量大于1000，那么拆分为两个任务
            SumTask task1 = new SumTask(start, (start + end) / 2);
            SumTask task2 = new SumTask((start + end) / 2 + 1, end);
            //执行任务
            task1.fork();
            task2.fork();
            //获取任务执行的结果
            return task1.join() + task2.join();
        }
    }
    
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ForkJoinPool pool = new ForkJoinPool();
        ForkJoinTask&lt;Integer&gt; task = new SumTask(1, 10000);
        pool.submit(task);
        System.out.println(task.get());
    }
}
</code></pre></div><ul><li><p>执行结果</p> <p>ForkJoinPool-1-worker-1 开始执行: 1-625
ForkJoinPool-1-worker-7 开始执行: 6251-6875
ForkJoinPool-1-worker-6 开始执行: 5626-6250
ForkJoinPool-1-worker-10 开始执行: 3751-4375
ForkJoinPool-1-worker-13 开始执行: 2501-3125
ForkJoinPool-1-worker-8 开始执行: 626-1250
ForkJoinPool-1-worker-11 开始执行: 5001-5625
ForkJoinPool-1-worker-3 开始执行: 7501-8125
ForkJoinPool-1-worker-14 开始执行: 1251-1875
ForkJoinPool-1-worker-4 开始执行: 9376-10000
ForkJoinPool-1-worker-8 开始执行: 8126-8750
ForkJoinPool-1-worker-0 开始执行: 1876-2500
ForkJoinPool-1-worker-12 开始执行: 4376-5000
ForkJoinPool-1-worker-5 开始执行: 8751-9375
ForkJoinPool-1-worker-7 开始执行: 6876-7500
ForkJoinPool-1-worker-1 开始执行: 3126-3750
50005000</p></li></ul> <h3 id="实现斐波那契数列"><a href="#实现斐波那契数列" class="header-anchor">#</a> 实现斐波那契数列</h3> <blockquote><p>斐波那契数列: 1、1、2、3、5、8、13、21、34、…… 公式 : F(1)=1，F(2)=1,
F(n)=F(n-1)+F(n-2)(n&gt;=3，n∈N*)</p></blockquote> <div class="language- extra-class"><pre><code>public static void main(String[] args) {
    ForkJoinPool forkJoinPool = new ForkJoinPool(4); // 最大并发数4
    Fibonacci fibonacci = new Fibonacci(20);
    long startTime = System.currentTimeMillis();
    Integer result = forkJoinPool.invoke(fibonacci);
    long endTime = System.currentTimeMillis();
    System.out.println(&quot;Fork/join sum: &quot; + result + &quot; in &quot; + (endTime - startTime) + &quot; ms.&quot;);
}
//以下为官方API文档示例
static  class Fibonacci extends RecursiveTask&lt;Integer&gt; {
    final int n;
    Fibonacci(int n) {
        this.n = n;
    }
    @Override
    protected Integer compute() {
        if (n &lt;= 1) {
            return n;
        }
        Fibonacci f1 = new Fibonacci(n - 1);
        f1.fork(); 
        Fibonacci f2 = new Fibonacci(n - 2);
        return f2.compute() + f1.join(); 
    }
}
</code></pre></div><p>当然你也可以两个任务都fork，要注意的是两个任务都fork的情况，必须按照f1.fork()，f2.fork()，
f2.join()，f1.join()这样的顺序，不然有性能问题，详见上面注意事项中的说明。</p> <p>官方API文档是这样写到的，所以平日用invokeAll就好了。invokeAll会把传入的任务的第一个交给当前线程来执行，其他的任务都fork加入工作队列，这样等于利用当前线程也执行任务了。</p> <div class="language- extra-class"><pre><code>{
    // ...
    Fibonacci f1 = new Fibonacci(n - 1);
    Fibonacci f2 = new Fibonacci(n - 2);
    invokeAll(f1,f2);
    return f2.join() + f1.join();
}

public static void invokeAll(ForkJoinTask&lt;?&gt;... tasks) {
    Throwable ex = null;
    int last = tasks.length - 1;
    for (int i = last; i &gt;= 0; --i) {
        ForkJoinTask&lt;?&gt; t = tasks[i];
        if (t == null) {
            if (ex == null)
                ex = new NullPointerException();
        }
        else if (i != 0)   //除了第一个都fork
            t.fork();
        else if (t.doInvoke() &lt; NORMAL &amp;&amp; ex == null)  //留一个自己执行
            ex = t.getException();
    }
    for (int i = 1; i &lt;= last; ++i) {
        ForkJoinTask&lt;?&gt; t = tasks[i];
        if (t != null) {
            if (ex != null)
                t.cancel(false);
            else if (t.doJoin() &lt; NORMAL)
                ex = t.getException();
        }
    }
    if (ex != null)
        rethrow(ex);
}
</code></pre></div><h2 id="参考文章"><a href="#参考文章" class="header-anchor">#</a> 参考文章</h2> <ul><li>首先推荐阅读ForkJoinPool的作者Doug Lea的一篇文章《A Java Fork/Join Framework》<a href="http://gee.cs.oswego.edu/dl/papers/fj.pdf" target="_blank" rel="noopener noreferrer">英文原文地址在新窗口打开<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>本文主要参考自泰迪的bagwell的https://www.jianshu.com/p/32a15ef2f1bf和https://www.jianshu.com/p/6a14d0b54b8d，在此基础上参考了如下文章</li> <li>https://blog.csdn.net/u010841296/article/details/83963637</li> <li>https://blog.csdn.net/Holmofy/article/details/82714665</li> <li>https://blog.csdn.net/abc123lzf/article/details/82873181</li> <li>https://blog.csdn.net/yinwenjie/article/details/71524140</li> <li>https://blog.csdn.net/cowbin2012/article/details/89791757</li></ul></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/willpast/willpast.github.io/edit/master/docs/02.Java/03.多线程与并发/25.java-thread-x-juc-executor-ForkJoinPool.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2024/05/29, 16:16:45</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/java-thread-x-juc-executor-ScheduledThreadPoolExecutor/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">JUC线程池 - ScheduledThreadPoolExecutor详解</div></a> <a href="/pages/java-thread-x-juc-tool-CountDownLatch/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">JUC工具类 - CountDownLatch详解</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/java-thread-x-juc-executor-ScheduledThreadPoolExecutor/" class="prev">JUC线程池 - ScheduledThreadPoolExecutor详解</a></span> <span class="next"><a href="/pages/java-thread-x-juc-tool-CountDownLatch/">JUC工具类 - CountDownLatch详解</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/612ae6/"><div>
            数据开发面试
            <!----></div></a> <span class="date">06-19</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/6de9b5/"><div>
            数据资产化及入表白皮书
            <!----></div></a> <span class="date">06-19</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/tool-tech-doc/"><div>
            官方文档
            <!----></div></a> <span class="date">06-07</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:lhhd_llz@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/willpast" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2024-2024
    <span>Cyan | <a href="https://github.com/willpast/willpast.github.io/blob/master/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div><div></div><div></div></div></div>
    <script src="/assets/js/app.e612eeea.js" defer></script><script src="/assets/js/2.55c43c56.js" defer></script><script src="/assets/js/70.9a186c3e.js" defer></script><script src="/assets/js/10.2e6611d1.js" defer></script><script src="/assets/js/4.093d7523.js" defer></script>
  </body>
</html>
