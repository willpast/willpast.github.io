(window.webpackJsonp=window.webpackJsonp||[]).push([[184],{516:function(t,s,a){"use strict";a.r(s);var n=a(4),r=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"字符串匹配-模式预处理-朴素算法-naive-暴力破解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#字符串匹配-模式预处理-朴素算法-naive-暴力破解"}},[t._v("#")]),t._v(" 字符串匹配 - 模式预处理：朴素算法（Naive)(暴力破解)")]),t._v(" "),s("blockquote",[s("p",[t._v("朴素的字符串匹配算法（Naive)又称为"),s("strong",[t._v("暴力匹配算法")]),t._v(" （Brute Force Algorithm），最为简单的字符串匹配算法。")])]),t._v(" "),s("h2",{attrs:{id:"算法简介"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#算法简介"}},[t._v("#")]),t._v(" 算法简介")]),t._v(" "),s("blockquote",[s("p",[t._v("朴素的字符串匹配算法又称为暴力匹配算法（Brute Force Algorithm），它的主要特点是：")])]),t._v(" "),s("ul",[s("li",[t._v("没有预处理阶段；")]),t._v(" "),s("li",[t._v("滑动窗口总是后移 1 位；")]),t._v(" "),s("li",[t._v("对模式中的字符的比较顺序不限定，可以从前到后，也可以从后到前；")]),t._v(" "),s("li",[t._v("匹配阶段需要 O((n - m + 1)m) 的时间复杂度；")]),t._v(" "),s("li",[t._v("需要 2n 次的字符比较；")])]),t._v(" "),s("p",[t._v("很显然，朴素的字符串匹配算法 NAIVE-STRING-MATCHER 是最原始的算法，它通过使用循环来检查是否在范围 n-m+1 中存在满足条件\nP[1..m] = T [s + 1..s + m] 的有效位移 s。")]),t._v(" "),s("p",[t._v("伪代码如下：")]),t._v(" "),s("div",{staticClass:"language-sh line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[t._v("NAIVE-STRING-MATCHER"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("T, P"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  n ← length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("T"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  m ← length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("P"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" s ← "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" to n - m\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" P"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(" m"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" T"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("s + "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(" s + m"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("then")]),t._v(" print "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Pattern occurs with shift"')]),t._v(" s\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/alg-domain-char-bf-2.png",alt:"img"}})]),t._v(" "),s("p",[t._v("如上图中，对于模式 P = aab 和文本 T = acaabc，将模式 P 沿着 T 从左到右滑动，逐个比较字符以判断模式 P 在文本 T 中是否存在。")]),t._v(" "),s("p",[t._v("可以看出，NAIVE-STRING-MATCHER 没有对模式 P 进行预处理，所以预处理的时间为 0。而匹配的时间在最坏情况下为\nΘ((n-m+1)m)，如果 m = [n/2]，则为 Θ(n2)。")]),t._v(" "),s("h2",{attrs:{id:"图例分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#图例分析"}},[t._v("#")]),t._v(" 图例分析")]),t._v(" "),s("p",[t._v("假设有两个字符串：")]),t._v(" "),s("ul",[s("li",[t._v('M="abcdefabcdx";')]),t._v(" "),s("li",[t._v('T="abcdx";')])]),t._v(" "),s("p",[t._v("想要找到T串在M串中的位置，要怎么找呢？")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/alg-domain-char-bf-1.png",alt:"img"}})]),t._v(" "),s("p",[t._v("也就是说，从主串M的第一个字符开始分别与子串从开头进行比较，当发现不匹配时，主串回到这一轮开始的下一个字符，子串从头开始比较。直到子串所有的字符都匹配，返回所在主串中的下标。")]),t._v(" "),s("h2",{attrs:{id:"算法复杂度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#算法复杂度"}},[t._v("#")]),t._v(" 算法复杂度")]),t._v(" "),s("p",[t._v("假设S的长度是m，T的长度是n，暂不考虑pos，从字符串S的开头开始比较。")]),t._v(" "),s("ul",[s("li",[t._v("最好的情况是第一次就匹配了，需要比较的次数是n.")]),t._v(" "),s("li",[t._v("最坏的情况下，就是上面举的这种例子，需要把整个字符串都比较完，从下面的代码中就体现为把两层循环都跑了一遍。这时候，比较的次数就是t*(s-t+1).")])]),t._v(" "),s("p",[t._v("所以这个算法的(最坏)时间复杂度就是o(t(s-t+1))，近似为o(n2).")]),t._v(" "),s("h2",{attrs:{id:"参考文章"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[t._v("#")]),t._v(" 参考文章")]),t._v(" "),s("ul",[s("li",[t._v("https://www.cnblogs.com/gaochundong/p/string_matching#kmp_string_matching_algorithm")]),t._v(" "),s("li",[t._v("https://blog.csdn.net/u013301192/article/details/48507695")])])])}),[],!1,null,null,null);s.default=r.exports}}]);