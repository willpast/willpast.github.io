(window.webpackJsonp=window.webpackJsonp||[]).push([[330],{659:function(e,t,n){"use strict";n.r(t);var r=n(4),s=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"开发安全-csrf-详解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#开发安全-csrf-详解"}},[e._v("#")]),e._v(" 开发安全 - CSRF 详解")]),e._v(" "),t("blockquote",[t("p",[e._v("CSRF(Cross-site request forgery跨站请求伪造，也被称成为“one click attack”或者session\nriding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。")])]),e._v(" "),t("h2",{attrs:{id:"csrf-简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#csrf-简介"}},[e._v("#")]),e._v(" CSRF 简介")]),e._v(" "),t("p",[e._v("CSRF（Cross Site Request Forgery, 跨站域请求伪造）是一种网络的攻击方式，它在 2007 年曾被列为互联网 20\n大安全隐患之一。其他安全隐患，比如 SQL\n脚本注入，跨站域脚本攻击等在近年来已经逐渐为众人熟知，很多网站也都针对他们进行了防御。然而，对于大多数人来说，CSRF\n却依然是一个陌生的概念。即便是大名鼎鼎的 Gmail, 在 2007 年底也存在着 CSRF 漏洞，从而被黑客攻击而使 Gmail 的用户造成巨大的损失。")]),e._v(" "),t("h2",{attrs:{id:"csrf-如何攻击"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#csrf-如何攻击"}},[e._v("#")]),e._v(" CSRF 如何攻击")]),e._v(" "),t("p",[t("strong",[e._v("先看图")]),e._v(" ：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/dev-security-csrf-1.jpg",alt:"img"}})]),e._v(" "),t("p",[e._v("从上图可以看出，A网站通过cookie来识别用户（C），当用户成功进行身份验证之后浏览器就会得到一个标识其身份的cookie，只要不关闭浏览器或者退出登录，以后访问A网站会一直带上这个cookie。如果这期间浏览器被人控制着向A网站发起请求去执行一些用户不想做的功能（比如添加账号），这就是会话劫持了。因为这个不是用户真正想发出的请求，这就是所谓的“请求伪造”。此外，由于请求可以从第三方网站提交，所以前缀跨站二字，即从B网站发起。")]),e._v(" "),t("p",[t("strong",[e._v("具体到银行转账为例（这是网上的一个例子，一大坨...)")]),e._v(" ：")]),e._v(" "),t("p",[e._v("CSRF 攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在并未授权的情况下执行在权限保护之下的操作。比如说，受害者 Bob\n在银行有一笔存款，通过对银行的网站发送请求\nhttp://bank.example/withdraw?account=bob&amount=1000000&for=bob2 可以使 Bob 把\n1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该\nsession 的用户 Bob 已经成功登陆。黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory\n可以自己发送一个请求给银行：http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory。但是这个请求来自\nMallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。这时，Mallory 想到使用 CSRF\n的攻击方式，他先自己做一个网站，在网站中放入如下代码：\nsrc=”http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory\n”，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob\n浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob\n当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob\n的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob\n发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory\n则可以拿到钱后逍遥法外。")]),e._v(" "),t("h2",{attrs:{id:"csrf-理解的注意点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#csrf-理解的注意点"}},[e._v("#")]),e._v(" CSRF 理解的注意点")]),e._v(" "),t("blockquote",[t("p",[e._v("要理解CSRF，我认为你需要理解如下几个问题：")])]),e._v(" "),t("h3",{attrs:{id:"黑客能拿到cookie吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#黑客能拿到cookie吗"}},[e._v("#")]),e._v(" 黑客能拿到Cookie吗?")]),e._v(" "),t("blockquote",[t("p",[e._v("CSRF 攻击是黑客借助受害者的 cookie 骗取服务器的信任，但是黑客并不能拿到 cookie，也看不到 cookie 的内容。")])]),e._v(" "),t("p",[e._v("对于服务器返回的结果，由于浏览器同源策略的限制，黑客也无法进行解析。因此，黑客无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。")]),e._v(" "),t("h3",{attrs:{id:"什么样的请求是要csrf保护的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么样的请求是要csrf保护的"}},[e._v("#")]),e._v(" 什么样的请求是要CSRF保护的?")]),e._v(" "),t("blockquote",[t("p",[e._v("为什么有些框架（比如Spring Security)里防护CSRF的filter限定的Method是POST/PUT/DELETE等，而没有限定GET\nMethod?")])]),e._v(" "),t("p",[e._v("我们要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务，则不需要进行 CSRF\n的保护。通常而言GET请作为请求数据，不作为修改数据，所以这些框架没有拦截Get等方式请求。比如银行系统中转账的请求会直接改变账户的金额，会遭到 CSRF\n攻击，需要保护。而查询余额是对金额的读取操作，不会改变数据，CSRF 攻击无法解析服务器返回的结果，无需保护。")]),e._v(" "),t("h3",{attrs:{id:"为什么对请求做了csrf拦截-但还是会报crsf漏洞"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么对请求做了csrf拦截-但还是会报crsf漏洞"}},[e._v("#")]),e._v(" 为什么对请求做了CSRF拦截，但还是会报CRSF漏洞?")]),e._v(" "),t("blockquote",[t("p",[e._v("为什么我在前端已经采用POST+CSRF Token请求，后端也对POST请求做了CSRF Filter，但是渗透测试中还有CSRF漏洞?")])]),e._v(" "),t("p",[e._v("直接看下面代码。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('// 这里没有限制POST Method，导致用户可以不通过POST请求提交数据。\n@RequestMapping("/url")\npublic ReponseData saveSomething(XXParam param){\n    // 数据保存操作...\n}\n')])])]),t("p",[e._v("PS：这一点是很容易被忽视的，在笔者经历过的几个项目的渗透测试中，多次出现。")]),e._v(" "),t("h2",{attrs:{id:"csrf-防御常规思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#csrf-防御常规思路"}},[e._v("#")]),e._v(" CSRF 防御常规思路")]),e._v(" "),t("blockquote",[t("p",[e._v("一定要注意，下面只是给你提供常规思路而已（以下文字摘自"),t("a",{attrs:{href:"https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/index.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("CSRF\n攻击的应对之道在新窗口打开"),t("OutboundLink")],1),e._v("，具体实现请看下一个章节。")])]),e._v(" "),t("h3",{attrs:{id:"验证-http-referer-字段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#验证-http-referer-字段"}},[e._v("#")]),e._v(" 验证 HTTP Referer 字段")]),e._v(" "),t("p",[e._v("根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP\n请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问\nhttp://bank.example/withdraw?account=bob&amount=1000000&for=Mallory，用户必须先登陆\nbank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以\nbank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF\n攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF\n攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example\n开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。")]),e._v(" "),t("h3",{attrs:{id:"在请求地址中添加-token-并验证"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#在请求地址中添加-token-并验证"}},[e._v("#")]),e._v(" 在请求地址中添加 token 并验证")]),e._v(" "),t("p",[e._v("CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie\n中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御\nCSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的\ntoken，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF\n攻击而拒绝该请求。")]),e._v(" "),t("p",[e._v("这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从\nsession 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token\n将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form\n的最后加上 "),t("code",[e._v("<input type=”hidden” name=”csrftoken” value=”tokenvalue”/>")]),e._v("，这样就把 token\n以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token\n是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form\n标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加\ntoken。")]),e._v(" "),t("p",[e._v("该方法还有一个缺点是难以保证 token\n本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上\ntoken，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token\n的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken\n不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器\nReferer 功能的原因。")]),e._v(" "),t("h3",{attrs:{id:"在-http-头中自定义属性并验证"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#在-http-头中自定义属性并验证"}},[e._v("#")]),e._v(" 在 HTTP 头中自定义属性并验证")]),e._v(" "),t("p",[e._v("这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP\n头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token\n值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心\ntoken 会透过 Referer 泄露到其他网站中去。")]),e._v(" "),t("p",[e._v("然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax\n方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行\nCSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest\n请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。")]),e._v(" "),t("h2",{attrs:{id:"csrf-防御实战"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#csrf-防御实战"}},[e._v("#")]),e._v(" CSRF 防御实战")]),e._v(" "),t("blockquote",[t("p",[e._v("主流的框架一般都包含了CSRF的拦截。")])]),e._v(" "),t("h3",{attrs:{id:"非框架型-自定义xxxcsrffilter"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#非框架型-自定义xxxcsrffilter"}},[e._v("#")]),e._v(" 非框架型 - 自定义XXXCsrfFilter")]),e._v(" "),t("p",[e._v("可以通过自定义xxxCsrfFilter去拦截实现， 这里建议你参考 Spring Security -\norg.springframework.security.web.csrf.CsrfFilter.java。")]),e._v(" "),t("h3",{attrs:{id:"spring-security-什么时候禁用csrf"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-security-什么时候禁用csrf"}},[e._v("#")]),e._v(" Spring Security - 什么时候禁用CSRF")]),e._v(" "),t("blockquote",[t("p",[e._v("你开发的应用在何时，会考虑禁用CSRF呢? 这时候需要考虑CSRF本质是盗用cookie, 无cookie方案就可以禁用。")])]),e._v(" "),t("ul",[t("li",[e._v("如果你只是创建一个非浏览器客户端使用的服务,你可能会想要禁用CSRF保护")])]),e._v(" "),t("p",[t("strong",[e._v("Spring Security中禁用CSRF")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(" @EnableWebSecurity\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n \n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.csrf().disable();// 默认是启用的，需要禁用CSRF保护\n    }\n}\n")])])]),t("h3",{attrs:{id:"spring-security-cookiecsrftokenrepository-withhttponlyfalse"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-security-cookiecsrftokenrepository-withhttponlyfalse"}},[e._v("#")]),e._v(" Spring Security - CookieCsrfTokenRepository.withHttpOnlyFalse()")]),e._v(" "),t("blockquote",[t("p",[e._v("存Cookie，比如前后端分离方案：Spring Security CookieCsrfTokenRepository + 前端路由统一设置")])]),e._v(" "),t("p",[t("strong",[e._v("Spring Security依赖包")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(" <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n")])])]),t("p",[t("strong",[e._v("Spring Security - CookieCsrfTokenRepository.withHttpOnlyFalse()")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(' @Override\nprotected void configure(HttpSecurity http) throws Exception {\n    // 本例子给个范例而已，对于xxx的部分，自己根据业务定义\n    http\n        .authorizeRequests()\n            /* allow */\n            .antMatchers("/plugins/**", "/api-docs/**") .permitAll()\n            .antMatchers("/login", "/logout").permitAll()\n            \n            /* auth control */\n            .antMatchers("/xxx/user", "/xxx/user/**").access("hasAuthority(\'xxx:user\')")\n            .antMatchers("/xxx/role", "/xxx/role/**").access("hasAuthority(\'xxx:role\')")\n\n            /* others */\n            .anyRequest().authenticated()\n           \n        /* other Filters */\n        .and()\n            .addFilterBefore(xxxFilter(), UsernamePasswordAuthenticationFilter.class)\n        \n        /* iframe */\n        .headers()\n            .frameOptions()\n            .sameOrigin()\n        \n        /* form login & logout */\n        .and().formLogin()\n            .loginPage("/login")\n            .usernameParameter("username")\n            .passwordParameter("password")\n            .defaultSuccessUrl("/admin/", true)\n        .and().rememberMe()\n            .rememberMeParameter("remember")\n            .rememberMeCookieName("remember")\n        .and().logout()\n            .deleteCookies("JSESSIONID")\n            .invalidateHttpSession(true)\n            .logoutSuccessHandler(new XXXLogoutSuccessHandler(localeResolver()))\n            .logoutRequestMatcher(new AntPathRequestMatcher("/logout"))\n            .permitAll()\n        \n        /* csrf */\n        .and().csrf()\n            .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse());\n//      .and().cors()\n    \n}\n')])])]),t("p",[t("strong",[e._v('后端thymeleaf登录页面"/login"')]),e._v(" ：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('<!DOCTYPE html>\n<html lang="en" xmlns:th="http://www.thymeleaf.org">\n<head>\n    <meta charset="UTF-8">\n    <title>登录页面</title>\n</head>\n<body>\n<form id="form" method="post">\n    <label>用户名：</label><input name="username" type="text" value="" />\n    <label>密码：</label><input name="password" type="text" value="" />\n    \x3c!--csrf验证需要--\x3e\n    <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}"/>\n    <br/>\n    <input type="submit" value="登录">\n</form>\n</body>\n</html>\n')])])]),t("p",[t("strong",[e._v("前端调用后端API: 方式一 （前后端分离的）")]),e._v(" ：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("//  将Cookie转换为JS Object\nfunction initCookies() {\n    var cookie = document.cookie,\n        items = cookie.split(\";\"),\n        keys = {};\n    items.forEach(function(item) {\n        var kv = item.split('=');\n        keys[$.trim(kv[0])] = $.trim(kv[1]);\n    });\n    return keys;\n}\n//  提交数据\n$.post(url, {\n    userId : code,\n    _csrf : initCookies()['X-XSRF-TOKEN'];\n}, function(datas) {\n    //  TODO something\n})\n")])])]),t("p",[t("strong",[e._v("前端调用后端API: 方式二 （后端写前端，用的后端模板）")]),e._v(" ：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('<meta name="_csrf" content="${_csrf.token}"/>\n<meta name="_csrf_header" content="${_csrf.headerName}"/>\n \n<script>\n \n    var token = $("meta[name=\'_csrf\']").attr("content");\n    var header = $("meta[name=\'_csrf_header\']").attr("content");\n    $.ajaxSetup({\n        beforeSend: function (xhr) {\n            if(header && token ){\n                xhr.setRequestHeader(header, token);\n            }\n        }}\n    );\n<\/script>\n')])])]),t("h3",{attrs:{id:"spring-security-new-cookiecsrftokenrepository"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-security-new-cookiecsrftokenrepository"}},[e._v("#")]),e._v(" Spring Security - new CookieCsrfTokenRepository()")]),e._v(" "),t("p",[e._v("可以通过"),t("code",[e._v("new CookieCsrfTokenRepository()")]),e._v("自定义拦截的逻辑，大概意思：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('@Configuration\npublic class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.csrf().csrfTokenRepository(new CookieCsrfTokenRepository())\n                .requireCsrfProtectionMatcher(\n                        /**\n                         * 拦截“/login”开头的访问路径，不让访问\n                         * 拦截所有“POST”请求，不让访问\n                         */\n//                        httpServletRequest -> httpServletRequest.getRequestURI().startsWith("/login")\n//                                && httpServletRequest.getMethod().equals("POST")\n                        httpServletRequest -> httpServletRequest.getMethod().equals("POST")\n                );\n    }\n}\n')])])]),t("p",[e._v("当然也可以这么写，可以看后续对默认的"),t("code",[e._v("DefaultRequiresCsrfMatcher")]),e._v("的源码")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('public class CsrfSecurityRequestMatcher implements RequestMatcher {\n    private Pattern allowedMethods = Pattern.compile("^(GET|HEAD|TRACE|OPTIONS)$");\n    private RegexRequestMatcher unprotectedMatcher = new RegexRequestMatcher("^/rest/.*", null);\n \n    @Override\n    public boolean matches(HttpServletRequest request) {\n        if(allowedMethods.matcher(request.getMethod()).matches()){\n            return false;\n        }\n \n        return !unprotectedMatcher.matches(request);\n    }\n}\n')])])]),t("h3",{attrs:{id:"spring-security-cookiecsrftokenrepository如何工作的呢"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-security-cookiecsrftokenrepository如何工作的呢"}},[e._v("#")]),e._v(" Spring Security - CookieCsrfTokenRepository如何工作的呢?")]),e._v(" "),t("p",[t("code",[e._v("CookieCsrfTokenRepository.withHttpOnlyFalse()")]),e._v(" 本质就是"),t("code",[e._v("new CookieCsrfTokenRepository()")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public static CookieCsrfTokenRepository withHttpOnlyFalse() {\n    CookieCsrfTokenRepository result = new CookieCsrfTokenRepository();\n    result.setCookieHttpOnly(false);\n    return result;\n}\n")])])]),t("p",[t("strong",[e._v("为何默认的存放CSRFToken的cookie是httpOnly呢？")])]),e._v(" "),t("p",[e._v("如果cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击，窃取cookie内容，这样就增加了cookie的安全性，即便是这样，也不要将重要信息存入cookie。XSS全称Cross\nSiteScript，跨站脚本攻击，是Web程序中常见的漏洞，XSS属于被动式且用于客户端的攻击方式，所以容易被忽略其危害性。其原理是攻击者向有XSS漏洞的网站中输入(传入)恶意的HTML代码，当其它用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如，盗取用户Cookie、破坏页面结构、重定向到其它网站等。这里请看[开发安全")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("XSS 详解](/pages/dev-protocol-xss.html)")]),e._v(" "),t("p",[e._v('// 比如，设置https的cookie\nresponse.addHeader("Set-Cookie", "uid=112; Path=/; Secure; HttpOnly");')])])]),e._v(" "),t("p",[t("strong",[e._v("Cookie CsrfToken 默认的封装")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(' static final String DEFAULT_CSRF_COOKIE_NAME = "XSRF-TOKEN";\n\nstatic final String DEFAULT_CSRF_PARAMETER_NAME = "_csrf";\n\nstatic final String DEFAULT_CSRF_HEADER_NAME = "X-XSRF-TOKEN";\n\nprivate String parameterName = DEFAULT_CSRF_PARAMETER_NAME;\n\nprivate String headerName = DEFAULT_CSRF_HEADER_NAME;\n\nprivate String cookieName = DEFAULT_CSRF_COOKIE_NAME;\n\n@Override\npublic CsrfToken generateToken(HttpServletRequest request) {\n    return new DefaultCsrfToken(this.headerName, this.parameterName,\n            createNewToken());\n}\n')])])]),t("p",[t("strong",[e._v("CsrfToken的保存")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(' @Override\npublic void saveToken(CsrfToken token, HttpServletRequest request,\n        HttpServletResponse response) {\n    String tokenValue = token == null ? "" : token.getToken();\n    Cookie cookie = new Cookie(this.cookieName, tokenValue);\n    cookie.setSecure(request.isSecure());\n    if (this.cookiePath != null && !this.cookiePath.isEmpty()) {\n            cookie.setPath(this.cookiePath);\n    } else {\n            cookie.setPath(this.getRequestContext(request));\n    }\n    if (token == null) {\n        cookie.setMaxAge(0);\n    }\n    else {\n        cookie.setMaxAge(-1);\n    }\n    if (cookieHttpOnly && setHttpOnlyMethod != null) {\n        ReflectionUtils.invokeMethod(setHttpOnlyMethod, cookie, Boolean.TRUE);\n    }\n\n    response.addCookie(cookie);\n}\n')])])]),t("p",[t("strong",[e._v("CsrfToken的加载")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(" @Override\npublic CsrfToken loadToken(HttpServletRequest request) {\n    Cookie cookie = WebUtils.getCookie(request, this.cookieName);\n    if (cookie == null) {\n        return null;\n    }\n    String token = cookie.getValue();\n    if (!StringUtils.hasLength(token)) {\n        return null;\n    }\n    return new DefaultCsrfToken(this.headerName, this.parameterName, token);\n}\n")])])]),t("h3",{attrs:{id:"spring-security-csrffilter是如何完成拦截和校验的呢"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-security-csrffilter是如何完成拦截和校验的呢"}},[e._v("#")]),e._v(" Spring Security - CsrfFilter是如何完成拦截和校验的呢?")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('public final class CsrfFilter extends OncePerRequestFilter {\n    // 负责CsrfToken生成，加载等\n    private final CsrfTokenRepository tokenRepository;\n    \n    // 负责拦截Csrf的匹配\n    private RequestMatcher requireCsrfProtectionMatcher = DEFAULT_CSRF_MATCHER;\n    \n    // 被拦截后的拒绝策略\n    private AccessDeniedHandler accessDeniedHandler = new AccessDeniedHandlerImpl();\n\n    // CsrfFilter的过滤逻辑\n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n            HttpServletResponse response, FilterChain filterChain)\n                    throws ServletException, IOException {\n        request.setAttribute(HttpServletResponse.class.getName(), response);\n\n        // 加载token,没有的自动生成一个\n        CsrfToken csrfToken = this.tokenRepository.loadToken(request);\n        final boolean missingToken = csrfToken == null;\n        if (missingToken) {\n            csrfToken = this.tokenRepository.generateToken(request);\n            this.tokenRepository.saveToken(csrfToken, request, response);\n        }\n        request.setAttribute(CsrfToken.class.getName(), csrfToken);\n        request.setAttribute(csrfToken.getParameterName(), csrfToken);\n\n        // 拦截请求\n        if (!this.requireCsrfProtectionMatcher.matches(request)) {\n            filterChain.doFilter(request, response);\n            return;\n        }\n\n        // 校验token\n        String actualToken = request.getHeader(csrfToken.getHeaderName());\n        if (actualToken == null) {\n            actualToken = request.getParameter(csrfToken.getParameterName());\n        }\n        if (!csrfToken.getToken().equals(actualToken)) {\n            if (this.logger.isDebugEnabled()) {\n                this.logger.debug("Invalid CSRF token found for "\n                        + UrlUtils.buildFullRequestUrl(request));\n            }\n            if (missingToken) {\n                this.accessDeniedHandler.handle(request, response,\n                        new MissingCsrfTokenException(actualToken));\n            }\n            else {\n                this.accessDeniedHandler.handle(request, response,\n                        new InvalidCsrfTokenException(csrfToken, actualToken));\n            }\n            return;\n        }\n\n        filterChain.doFilter(request, response);\n    }\n}\n')])])]),t("h3",{attrs:{id:"spring-security-默认对哪些method拦截呢"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-security-默认对哪些method拦截呢"}},[e._v("#")]),e._v(" Spring Security - 默认对哪些Method拦截呢?")]),e._v(" "),t("p",[e._v('"GET", "HEAD", "TRACE", "OPTIONS" 不会拦截：')]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('private static final class DefaultRequiresCsrfMatcher implements RequestMatcher {\n    private final HashSet<String> allowedMethods = new HashSet<String>(\n            Arrays.asList("GET", "HEAD", "TRACE", "OPTIONS"));\n\n    /*\n        * (non-Javadoc)\n        *\n        * @see\n        * org.springframework.security.web.util.matcher.RequestMatcher#matches(javax.\n        * servlet.http.HttpServletRequest)\n        */\n    @Override\n    public boolean matches(HttpServletRequest request) {\n        return !this.allowedMethods.contains(request.getMethod());\n    }\n}\n')])])]),t("h3",{attrs:{id:"spring-security-httpsessioncsrftokenrepository"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-security-httpsessioncsrftokenrepository"}},[e._v("#")]),e._v(" Spring Security - HttpSessionCsrfTokenRepository")]),e._v(" "),t("blockquote",[t("p",[e._v("经过上面的分析，你再看Session的，是不是很简单? 我这边贴个代码，你眼睛扫一下即可。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('public final class HttpSessionCsrfTokenRepository implements CsrfTokenRepository {\n    private static final String DEFAULT_CSRF_PARAMETER_NAME = "_csrf";\n\n    private static final String DEFAULT_CSRF_HEADER_NAME = "X-CSRF-TOKEN";\n\n    private static final String DEFAULT_CSRF_TOKEN_ATTR_NAME = HttpSessionCsrfTokenRepository.class\n            .getName().concat(".CSRF_TOKEN");\n\n    private String parameterName = DEFAULT_CSRF_PARAMETER_NAME;\n\n    private String headerName = DEFAULT_CSRF_HEADER_NAME;\n\n    private String sessionAttributeName = DEFAULT_CSRF_TOKEN_ATTR_NAME;\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see org.springframework.security.web.csrf.CsrfTokenRepository#saveToken(org.\n     * springframework .security.web.csrf.CsrfToken,\n     * javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     */\n    public void saveToken(CsrfToken token, HttpServletRequest request,\n            HttpServletResponse response) {\n        if (token == null) {\n            HttpSession session = request.getSession(false);\n            if (session != null) {\n                session.removeAttribute(this.sessionAttributeName);\n            }\n        }\n        else {\n            HttpSession session = request.getSession();\n            session.setAttribute(this.sessionAttributeName, token);\n        }\n    }\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see\n     * org.springframework.security.web.csrf.CsrfTokenRepository#loadToken(javax.servlet\n     * .http.HttpServletRequest)\n     */\n    public CsrfToken loadToken(HttpServletRequest request) {\n        HttpSession session = request.getSession(false);\n        if (session == null) {\n            return null;\n        }\n        return (CsrfToken) session.getAttribute(this.sessionAttributeName);\n    }\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see org.springframework.security.web.csrf.CsrfTokenRepository#generateToken(javax.\n     * servlet .http.HttpServletRequest)\n     */\n    public CsrfToken generateToken(HttpServletRequest request) {\n        return new DefaultCsrfToken(this.headerName, this.parameterName,\n                createNewToken());\n    }\n}\n')])])]),t("h3",{attrs:{id:"spring-security-设置csrf不对会造成哪些错误呢"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-security-设置csrf不对会造成哪些错误呢"}},[e._v("#")]),e._v(" Spring Security - 设置Csrf不对会造成哪些错误呢?")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("403 - 用CSRF作为控制权限，引发权限问题")]),e._v(" "),t("p",[e._v("There was an unexpected error (type=Forbidden, status=403).\nInvalid CSRF Token 'null' was found on the request parameter '_csrf' or header 'X-XSRF-TOKEN'.")])]),e._v(" "),t("li",[t("p",[e._v("405 - 前置的参数绑定问题")]),e._v(" "),t("p",[e._v("POST method not supported。// 本质上还是参数绑定时，Csrf没有设置或者不正确。")])])]),e._v(" "),t("h2",{attrs:{id:"总结与展望"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结与展望"}},[e._v("#")]),e._v(" 总结与展望")]),e._v(" "),t("p",[e._v("可见，CSRF 是一种危害非常大的攻击，又很难以防范。目前几种防御策略虽然可以很大程度上抵御 CSRF\n的攻击，但并没有一种完美的解决方案。一些新的方案正在研究之中，比如对于每次请求都使用不同的动态口令，把 Referer 和 token\n方案结合起来，甚至尝试修改 HTTP 规范，但是这些新的方案尚不成熟，要正式投入使用并被业界广为接受还需时日。在这之前，我们只有充分重视\nCSRF，根据系统的实际情况选择最合适的策略，这样才能把 CSRF 的危害降到最低。")]),e._v(" "),t("h2",{attrs:{id:"参考文章"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[e._v("#")]),e._v(" 参考文章")]),e._v(" "),t("ul",[t("li",[e._v("https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/index.html")]),e._v(" "),t("li",[e._v("https://blog.csdn.net/panchang199266/article/details/83152587")]),e._v(" "),t("li",[e._v("https://www.freebuf.com/column/186939.html")]),e._v(" "),t("li",[e._v("https://blog.csdn.net/u013185616/article/details/70446392")]),e._v(" "),t("li",[e._v("https://blog.csdn.net/yiifaa/article/details/78459677")])])])}),[],!1,null,null,null);t.default=s.exports}}]);