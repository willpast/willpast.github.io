(window.webpackJsonp=window.webpackJsonp||[]).push([[409],{743:function(e,t,a){"use strict";a.r(t);var n=a(4),r=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"结构型-装饰-decorator"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结构型-装饰-decorator"}},[e._v("#")]),e._v(" 结构型 - 装饰(Decorator)")]),e._v(" "),t("blockquote",[t("p",[e._v("装饰者模式(decorator pattern): 动态地将责任附加到对象上, 若要扩展功能, 装饰者提供了比继承更有弹性的替代方案。")])]),e._v(" "),t("h2",{attrs:{id:"意图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#意图"}},[e._v("#")]),e._v(" 意图")]),e._v(" "),t("p",[e._v("为对象动态添加功能。")]),e._v(" "),t("h2",{attrs:{id:"类图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类图"}},[e._v("#")]),e._v(" 类图")]),e._v(" "),t("p",[e._v("装饰者(Decorator)和具体组件(ConcreteComponent)都继承自组件(Component)，具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/137c593d-0a9e-47b8-a9e6-b71f540b82dd.png",alt:"img"}})]),e._v(" "),t("h2",{attrs:{id:"实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[e._v("#")]),e._v(" 实现")]),e._v(" "),t("p",[e._v("设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。")]),e._v(" "),t("p",[e._v("下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被\nWhip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/c9cfd600-bc91-4f3a-9f99-b42f88a5bb24.jpg",alt:"img"}})]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public interface Beverage {\n    double cost();\n}\n\n\n\npublic class DarkRoast implements Beverage {\n    @Override\n    public double cost() {\n        return 1;\n    }\n}\n\n\n\npublic class HouseBlend implements Beverage {\n    @Override\n    public double cost() {\n        return 1;\n    }\n}\n\n\n\npublic abstract class CondimentDecorator implements Beverage {\n    protected Beverage beverage;\n}\n\n\n\npublic class Milk extends CondimentDecorator {\n\n    public Milk(Beverage beverage) {\n        this.beverage = beverage;\n    }\n\n    @Override\n    public double cost() {\n        return 1 + beverage.cost();\n    }\n}\n\n\n\npublic class Mocha extends CondimentDecorator {\n\n    public Mocha(Beverage beverage) {\n        this.beverage = beverage;\n    }\n\n    @Override\n    public double cost() {\n        return 1 + beverage.cost();\n    }\n}\n\n\n\npublic class Client {\n    public static void main(String[] args) {\n        Beverage beverage = new HouseBlend();\n        beverage = new Mocha(beverage);\n        beverage = new Milk(beverage);\n        System.out.println(beverage.cost());\n    }\n}\n\n\n\n3.0\n")])])]),t("h2",{attrs:{id:"设计原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计原则"}},[e._v("#")]),e._v(" 设计原则")]),e._v(" "),t("p",[e._v("类应该对扩展开放，对修改关闭: 也就是添加新功能时不需要修改代码。饮料可以动态添加新的配料，而不需要去修改饮料的代码。")]),e._v(" "),t("p",[e._v("不可能把所有的类设计成都满足这一原则，应当把该原则应用于最有可能发生改变的地方。")]),e._v(" "),t("h2",{attrs:{id:"jdk"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdk"}},[e._v("#")]),e._v(" JDK")]),e._v(" "),t("ul",[t("li",[e._v("java.io.BufferedInputStream(InputStream)")]),e._v(" "),t("li",[e._v("java.io.DataInputStream(InputStream)")]),e._v(" "),t("li",[e._v("java.io.BufferedOutputStream(OutputStream)")]),e._v(" "),t("li",[e._v("java.util.zip.ZipOutputStream(OutputStream)")]),e._v(" "),t("li",[e._v("java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap")])])])}),[],!1,null,null,null);t.default=r.exports}}]);