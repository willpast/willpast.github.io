(window.webpackJsonp=window.webpackJsonp||[]).push([[307],{637:function(t,n,e){"use strict";e.r(n);var o=e(4),s=Object(o.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"单元测试-mockito-详解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#单元测试-mockito-详解"}},[t._v("#")]),t._v(" 单元测试 - Mockito 详解")]),t._v(" "),n("blockquote",[n("p",[t._v("Mock通常是指，在测试一个对象A时，我们构造一些假的对象来模拟与A之间的交互，而这些Mock对象的行为是我们事先设定且符合预期。通过这些Mock对象来测试A在正常逻辑，异常逻辑或压力情况下工作是否正常。而Mockito是最流行的Java\nmock框架之一。")])]),t._v(" "),n("h2",{attrs:{id:"什么是-mock-测试"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是-mock-测试"}},[t._v("#")]),t._v(" 什么是 Mock 测试")]),t._v(" "),n("blockquote",[n("p",[t._v("Mock通常是指，在测试一个对象A时，我们构造一些假的对象来模拟与A之间的交互，而这些Mock对象的行为是我们事先设定且符合预期。通过这些Mock对象来测试A在正常逻辑，异常逻辑或压力情况下工作是否正常。")])]),t._v(" "),n("p",[t._v("Mock 测试就是在测试过程中，对于某些不容易构造（如 HttpServletRequest 必须在Servlet\n容器中才能构造出来）或者不容易获取比较复杂的对象（如 JDBC 中的ResultSet 对象），用一个虚拟的对象（Mock\n对象）来创建以便测试的测试方法。Mock\n最大的功能是帮你把单元测试的耦合分解开，如果你的代码对另一个类或者接口有依赖，它能够帮你模拟这些依赖，并帮你验证所调用的依赖的行为。")]),t._v(" "),n("p",[t._v("先来看看下面这个示例：")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/ut-dev-mock-4.png",alt:"img"}})]),t._v(" "),n("p",[t._v("从上图可以看出如果我们要对A进行测试，那么就要先把整个依赖树构建出来，也就是BCDE的实例。")]),t._v(" "),n("p",[t._v("一种替代方案就是使用mocks")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/ut-dev-mock-5.png",alt:"img"}})]),t._v(" "),n("p",[t._v("从图中可以清晰的看出, mock对象就是在调试期间用来作为真实对象的替代品。")]),t._v(" "),n("p",[t._v("mock测试就是在测试过程中，对那些不容易构建的对象用一个虚拟对象来代替测试的方法就叫mock测试。")]),t._v(" "),n("h2",{attrs:{id:"mock-适用在什么场景"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mock-适用在什么场景"}},[t._v("#")]),t._v(" Mock 适用在什么场景")]),t._v(" "),n("blockquote",[n("p",[t._v("在使用Mock的过程中，发现Mock是有一些通用性的，对于一些应用场景，是非常适合使用Mock的：")])]),t._v(" "),n("ul",[n("li",[t._v("真实对象具有不可确定的行为(产生不可预测的结果，如股票的行情)")]),t._v(" "),n("li",[t._v("真实对象很难被创建(比如具体的web容器)")]),t._v(" "),n("li",[t._v("真实对象的某些行为很难触发(比如网络错误)")]),t._v(" "),n("li",[t._v("真实情况令程序的运行速度很慢")]),t._v(" "),n("li",[t._v("真实对象有用户界面")]),t._v(" "),n("li",[t._v("测试需要询问真实对象它是如何被调用的(比如测试可能需要验证某个回调函数是否被调用了)")]),t._v(" "),n("li",[t._v("真实对象实际上并不存在(当需要和其他开发小组，或者新的硬件系统打交道的时候，这是一个普遍的问题)")])]),t._v(" "),n("p",[t._v("当然，也有一些不得不Mock的场景：")]),t._v(" "),n("ul",[n("li",[t._v("一些比较难构造的Object：这类Object通常有很多依赖，在单元测试中构造出这样类通常花费的成本太大。")]),t._v(" "),n("li",[t._v("执行操作的时间较长Object：有一些Object的操作费时，而被测对象依赖于这一个操作的执行结果，例如大文件写操作，数据的更新等等，出于测试的需求，通常将这类操作进行Mock。")]),t._v(" "),n("li",[t._v("异常逻辑：一些异常的逻辑往往在正常测试中是很难触发的，通过Mock可以人为的控制触发异常逻辑。")])]),t._v(" "),n("p",[t._v("在一些压力测试的场景下，也不得不使用Mock，例如在分布式系统测试中，通常需要测试一些单点（如namenode，jobtracker）在压力场景下的工作是否正常。而通常测试集群在正常逻辑下无法提供足够的压力（主要原因是受限于机器数量），这时候就需要应用Mock去满足。")]),t._v(" "),n("h2",{attrs:{id:"mockito"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mockito"}},[t._v("#")]),t._v(" Mockito")]),t._v(" "),n("blockquote",[n("p",[t._v("Mockito是最流行的Java mock框架之一.")])]),t._v(" "),n("h3",{attrs:{id:"官方资料"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#官方资料"}},[t._v("#")]),t._v(" 官方资料")]),t._v(" "),n("ul",[n("li",[t._v("Mockito 官方网站")])]),t._v(" "),n("p",[t._v("https://site.mockito.org/")]),t._v(" "),n("ul",[n("li",[t._v("PowerMockito Github")])]),t._v(" "),n("p",[t._v("https://github.com/powermock/powermock/")]),t._v(" "),n("h3",{attrs:{id:"maven包引入"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#maven包引入"}},[t._v("#")]),t._v(" Maven包引入")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v('<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>pdai.tech</groupId>\n    <artifactId>java-mockito</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <dependencies>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n            <scope>test</scope>\n        </dependency>\n        \x3c!-- https://mvnrepository.com/artifact/org.mockito/mockito-core --\x3e\n        <dependency>\n            <groupId>org.mockito</groupId>\n            <artifactId>mockito-core</artifactId>\n            <version>3.7.7</version>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n</project>\n')])])]),n("h3",{attrs:{id:"测试-hello-world"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#测试-hello-world"}},[t._v("#")]),t._v(" 测试:Hello World")]),t._v(" "),n("blockquote",[n("p",[t._v("本例子主要用来测试DemoService类，但是DemoService又依赖于DemoDao，这时候我们便可以mock出DemoDao的返回预期值，从而测试DemoService类。")])]),t._v(" "),n("p",[t._v("待测试类DemoService")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("package tech.pdai.mockito.service;\n\nimport tech.pdai.mockito.dao.DemoDao;\n\npublic class DemoService {\n\n    private DemoDao demoDao;\n\n    public DemoService(DemoDao demoDao) {\n        this.demoDao = demoDao;\n    }\n\n    public int getDemoStatus(){\n        return demoDao.getDemoStatus();\n    }\n}\n")])])]),n("p",[t._v("依赖DemoDao")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("package tech.pdai.mockito.dao;\n\nimport java.util.Random;\n\npublic class DemoDao {\n\n    public int getDemoStatus(){\n        return new Random().nextInt();\n    }\n}\n")])])]),n("p",[t._v("测试类")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("package tech.pdai.mockito;\n\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.mockito.Mockito;\nimport tech.pdai.mockito.dao.DemoDao;\nimport tech.pdai.mockito.service.DemoService;\n\n/**\n * Hello World Test.\n */\npublic class HelloWorldTest {\n\n    @Test\n    public void helloWorldTest() {\n        // mock DemoDao instance\n        DemoDao mockDemoDao = Mockito.mock(DemoDao.class);\n\n        // 使用 mockito 对 getDemoStatus 方法打桩\n        Mockito.when(mockDemoDao.getDemoStatus()).thenReturn(1);\n\n        // 调用 mock 对象的 getDemoStatus 方法，结果永远是 1\n        Assert.assertEquals(1, mockDemoDao.getDemoStatus());\n\n        // mock DemoService\n        DemoService mockDemoService = new DemoService(mockDemoDao);\n        Assert.assertEquals(1, mockDemoService.getDemoStatus() );\n    }\n}\n")])])]),n("p",[t._v("执行结果")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/dev-ut-mock-1.png",alt:"img"}})]),t._v(" "),n("h3",{attrs:{id:"测试-使用mock方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#测试-使用mock方法"}},[t._v("#")]),t._v(" 测试:使用mock方法")]),t._v(" "),n("p",[t._v("包含两块测试：一个是类测试，一个接口测试，具体如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v('package tech.pdai.mockito;\n\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport java.util.List;\nimport java.util.Random;\n\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\n/**\n * Mock Class Test.\n */\npublic class MockClassTest {\n\n    @Test\n    public void mockClassTest() {\n        Random mockRandom = mock(Random.class);\n\n        // 默认值: mock 对象的方法的返回值默认都是返回类型的默认值\n        System.out.println(mockRandom.nextBoolean()); // false\n        System.out.println(mockRandom.nextInt()); // 0\n        System.out.println(mockRandom.nextDouble()); // 0.0\n\n        // mock: 指定调用 nextInt 方法时，永远返回 100\n        when(mockRandom.nextInt()).thenReturn(100);\n        Assert.assertEquals(100, mockRandom.nextInt());\n        Assert.assertEquals(100, mockRandom.nextInt());\n    }\n\n    @Test\n    public void mockInterfaceTest() {\n        List mockList = mock(List.class);\n\n        // 接口的默认值：和类方法一致，都是默认返回值\n        Assert.assertEquals(0, mockList.size());\n        Assert.assertEquals(null, mockList.get(0));\n\n        // 注意：调用 mock 对象的写方法，是没有效果的\n        mockList.add("a");\n        Assert.assertEquals(0, mockList.size());      // 没有指定 size() 方法返回值，这里结果是默认值\n        Assert.assertEquals(null, mockList.get(0));   // 没有指定 get(0) 返回值，这里结果是默认值\n\n        // mock值测试\n        when(mockList.get(0)).thenReturn("a");          // 指定 get(0)时返回 a\n        Assert.assertEquals(0, mockList.size());        // 没有指定 size() 方法返回值，这里结果是默认值\n        Assert.assertEquals("a", mockList.get(0));      // 因为上面指定了 get(0) 返回 a，所以这里会返回 a\n        Assert.assertEquals(null, mockList.get(1));     // 没有指定 get(1) 返回值，这里结果是默认值\n    }\n}\n')])])]),n("p",[t._v("执行结果")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/dev-ut-mock-11.png",alt:"img"}})]),t._v(" "),n("h3",{attrs:{id:"测试-适用-mock注解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#测试-适用-mock注解"}},[t._v("#")]),t._v(" 测试:适用@Mock注解")]),t._v(" "),n("blockquote",[n("p",[t._v("@Mock 注解可以理解为对 mock 方法的一个替代。")])]),t._v(" "),n("p",[t._v("使用该注解时，要使用MockitoAnnotations.initMocks 方法，让注解生效, 比如放在@Before方法中初始化。")]),t._v(" "),n("p",[t._v("比较优雅优雅的写法是用MockitoJUnitRunner，它可以自动执行MockitoAnnotations.initMocks 方法。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("package tech.pdai.mockito;\n\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\n\nimport java.util.Random;\n\nimport static org.mockito.Mockito.when;\n\n/**\n * Mock Annotation\n */\n@RunWith(MockitoJUnitRunner.class)\npublic class MockAnnotationTest {\n\n    @Mock\n    private Random random;\n\n    @Test\n    public void test() {\n        when(random.nextInt()).thenReturn(100);\n        Assert.assertEquals(100, random.nextInt());\n    }\n}\n")])])]),n("h3",{attrs:{id:"测试-参数匹配"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#测试-参数匹配"}},[t._v("#")]),t._v(" 测试:参数匹配")]),t._v(" "),n("p",[t._v("如果参数匹配既申明了精确匹配，也声明了模糊匹配；又或者同一个值的精确匹配出现了两次，使用时会匹配符合匹配条件的最新声明的匹配。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v('package tech.pdai.mockito;\n\n\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\n\nimport java.util.List;\n\nimport static org.mockito.ArgumentMatchers.anyInt;\nimport static org.mockito.Mockito.when;\n\n\n/**\n * Mock Parameter Test.\n */\n@RunWith(MockitoJUnitRunner.class)\npublic class ParameterTest {\n\n    @Mock\n    private List<String> testList;\n\n    @Test\n    public void test01() {\n\n        // 精确匹配 0\n        when(testList.get(0)).thenReturn("a");\n        Assert.assertEquals("a", testList.get(0));\n\n        // 精确匹配 0\n        when(testList.get(0)).thenReturn("b");\n        Assert.assertEquals("b", testList.get(0));\n\n        // 模糊匹配\n        when(testList.get(anyInt())).thenReturn("c");\n        Assert.assertEquals("c", testList.get(0));\n        Assert.assertEquals("c", testList.get(1));\n\n    }\n}\n')])])]),n("p",[t._v("anyInt 只是用来匹配参数的工具之一，目前 mockito 有多种匹配函数，部分如下：")]),t._v(" "),n("table",[n("thead",[n("tr",[n("th",[t._v("函数名")]),t._v(" "),n("th",[t._v("匹配类型")])])]),t._v(" "),n("tbody",[n("tr",[n("td",[t._v("any()")]),t._v(" "),n("td",[t._v("所有对象类型")])]),t._v(" "),n("tr",[n("td",[t._v("anyInt()")]),t._v(" "),n("td",[t._v("基本类型 int、非 null 的 Integer 类型")])]),t._v(" "),n("tr",[n("td",[t._v("anyChar()")]),t._v(" "),n("td",[t._v("基本类型 char、非 null 的 Character 类型")])]),t._v(" "),n("tr",[n("td",[t._v("anyShort()")]),t._v(" "),n("td",[t._v("基本类型 short、非 null 的 Short 类型")])]),t._v(" "),n("tr",[n("td",[t._v("anyBoolean()")]),t._v(" "),n("td",[t._v("基本类型 boolean、非 null 的 Boolean 类型")])]),t._v(" "),n("tr",[n("td",[t._v("anyDouble()")]),t._v(" "),n("td",[t._v("基本类型 double、非 null 的 Double 类型")])]),t._v(" "),n("tr",[n("td",[t._v("anyFloat()")]),t._v(" "),n("td",[t._v("基本类型 float、非 null 的 Float 类型")])]),t._v(" "),n("tr",[n("td",[t._v("anyLong()")]),t._v(" "),n("td",[t._v("基本类型 long、非 null 的 Long 类型")])]),t._v(" "),n("tr",[n("td",[t._v("anyByte()")]),t._v(" "),n("td",[t._v("基本类型 byte、非 null 的 Byte 类型")])]),t._v(" "),n("tr",[n("td",[t._v("anyString()")]),t._v(" "),n("td",[t._v("String 类型(不能是 null)")])]),t._v(" "),n("tr",[n("td",[t._v("anyList()")]),t._v(" "),n("td",[n("code",[t._v("List<T>")]),t._v(" 类型(不能是 null)")])]),t._v(" "),n("tr",[n("td",[t._v("anyMap()")]),t._v(" "),n("td",[n("code",[t._v("Map<K, V>")]),t._v("类型(不能是 null)")])]),t._v(" "),n("tr",[n("td",[t._v("anyCollection()")]),t._v(" "),n("td",[n("code",[t._v("Collection<T>")]),t._v("类型(不能是 null)")])]),t._v(" "),n("tr",[n("td",[t._v("anySet()")]),t._v(" "),n("td",[n("code",[t._v("Set<T>")]),t._v("类型(不能是 null)")])]),t._v(" "),n("tr",[n("td",[t._v("any("),n("code",[t._v("Class<T>")]),t._v(" type)")]),t._v(" "),n("td",[t._v("type类型的对象(不能是 null)")])]),t._v(" "),n("tr",[n("td",[t._v("isNull()")]),t._v(" "),n("td",[t._v("null")])]),t._v(" "),n("tr",[n("td",[t._v("notNull()")]),t._v(" "),n("td",[t._v("非 null")])]),t._v(" "),n("tr",[n("td",[t._v("isNotNull()")]),t._v(" "),n("td",[t._v("非 null")])])])]),t._v(" "),n("h3",{attrs:{id:"测试-mock异常"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#测试-mock异常"}},[t._v("#")]),t._v(" 测试:Mock异常")]),t._v(" "),n("blockquote",[n("p",[t._v("Mockito 使用 thenThrow 让方法抛出异常")])]),t._v(" "),n("p",[t._v("如下代码中，包含两个例子：一个是单个异常，一个是多个异常。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v('package tech.pdai.mockito;\n\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport java.util.Random;\n\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\n/**\n * Exception Test.\n */\npublic class ThrowTest {\n\n    /**\n     * 例子1： thenThrow 用来让函数调用抛出异常.\n     */\n    @Test\n    public void throwTest1() {\n\n        Random mockRandom = mock(Random.class);\n        when(mockRandom.nextInt()).thenThrow(new RuntimeException("异常"));\n\n        try {\n            mockRandom.nextInt();\n            Assert.fail();  // 上面会抛出异常，所以不会走到这里\n        } catch (Exception ex) {\n            Assert.assertTrue(ex instanceof RuntimeException);\n            Assert.assertEquals("异常", ex.getMessage());\n        }\n    }\n\n    /**\n     * thenThrow 中可以指定多个异常。在调用时异常依次出现。若调用次数超过异常的数量，再次调用时抛出最后一个异常。\n     */\n    @Test\n    public void throwTest2() {\n\n        Random mockRandom = mock(Random.class);\n        when(mockRandom.nextInt()).thenThrow(new RuntimeException("异常1"), new RuntimeException("异常2"));\n\n        try {\n            mockRandom.nextInt();\n            Assert.fail();\n        } catch (Exception ex) {\n            Assert.assertTrue(ex instanceof RuntimeException);\n            Assert.assertEquals("异常1", ex.getMessage());\n        }\n\n        try {\n            mockRandom.nextInt();\n            Assert.fail();\n        } catch (Exception ex) {\n            Assert.assertTrue(ex instanceof RuntimeException);\n            Assert.assertEquals("异常2", ex.getMessage());\n        }\n    }\n}\n')])])]),n("p",[t._v("执行结果")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/dev-ut-mock-12.png",alt:"img"}})]),t._v(" "),n("blockquote",[n("p",[t._v("对应返回类型是 void 的函数，thenThrow 是无效的，要使用 doThrow。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v('package tech.pdai.mockito;\n\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\nimport org.mockito.junit.MockitoJUnitRunner;\n\nimport static org.mockito.Mockito.doThrow;\n\n/**\n * Do Throw for void return.\n */\n@RunWith(MockitoJUnitRunner.class)\npublic class DoThrowTest {\n\n    static class ExampleService {\n\n        public void hello() {\n            System.out.println("Hello");\n        }\n\n    }\n\n    @Mock\n    private ExampleService exampleService;\n\n    @Test\n    public void test() {\n\n        // 这种写法可以达到效果\n        doThrow(new RuntimeException("异常")).when(exampleService).hello();\n\n        try {\n            exampleService.hello();\n            Assert.fail();\n        } catch (RuntimeException ex) {\n            Assert.assertEquals("异常", ex.getMessage());\n        }\n\n    }\n}\n')])])]),n("p",[t._v("此外还有，可以查看官方文档")]),t._v(" "),n("ul",[n("li",[t._v("doAnswer(Answer)")]),t._v(" "),n("li",[t._v("doNothing()")]),t._v(" "),n("li",[t._v("doCallRealMethod()")])]),t._v(" "),n("h3",{attrs:{id:"测试-spy-和-spy-注解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#测试-spy-和-spy-注解"}},[t._v("#")]),t._v(" 测试:spy 和 @Spy 注解")]),t._v(" "),n("p",[t._v("spy 和 mock不同，不同点是：")]),t._v(" "),n("ul",[n("li",[t._v("spy 的参数是对象示例，mock 的参数是 class。")]),t._v(" "),n("li",[t._v("被 spy 的对象，调用其方法时默认会走真实方法。mock 对象不会。")])]),t._v(" "),n("p",[t._v("下面是一个对比：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("import org.junit.Assert;\nimport org.junit.Test;\nimport static org.mockito.Mockito.*;\n\n\nclass ExampleService {\n\n    int add(int a, int b) {\n        return a+b;\n    }\n\n}\n\npublic class MockitoDemo {\n\n    // 测试 spy\n    @Test\n    public void test_spy() {\n\n        ExampleService spyExampleService = spy(new ExampleService());\n\n        // 默认会走真实方法\n        Assert.assertEquals(3, spyExampleService.add(1, 2));\n\n        // 打桩后，不会走了\n        when(spyExampleService.add(1, 2)).thenReturn(10);\n        Assert.assertEquals(10, spyExampleService.add(1, 2));\n\n        // 但是参数比匹配的调用，依然走真实方法\n        Assert.assertEquals(3, spyExampleService.add(2, 1));\n\n    }\n\n    // 测试 mock\n    @Test\n    public void test_mock() {\n\n        ExampleService mockExampleService = mock(ExampleService.class);\n\n        // 默认返回结果是返回类型int的默认值\n        Assert.assertEquals(0, mockExampleService.add(1, 2));\n\n    }\n\n}\n")])])]),n("p",[t._v("spy 对应注解 @Spy，和 @Mock 是一样用的。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("import org.junit.Assert;\nimport org.junit.Test;\nimport org.mockito.MockitoAnnotations;\nimport org.mockito.Spy;\n\nimport static org.mockito.Mockito.*;\n\n\nclass ExampleService {\n\n    int add(int a, int b) {\n        return a+b;\n    }\n\n}\n\npublic class MockitoDemo {\n\n    @Spy\n    private ExampleService spyExampleService;\n\n    @Test\n    public void test_spy() {\n\n        MockitoAnnotations.initMocks(this);\n\n        Assert.assertEquals(3, spyExampleService.add(1, 2));\n\n        when(spyExampleService.add(1, 2)).thenReturn(10);\n        Assert.assertEquals(10, spyExampleService.add(1, 2));\n\n    }\n\n}\n")])])]),n("p",[t._v("对于@Spy，如果发现修饰的变量是 null，会自动调用类的无参构造函数来初始化。")]),t._v(" "),n("p",[t._v("所以下面两种写法是等价的：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("// 写法1\n@Spy\nprivate ExampleService spyExampleService;\n\n// 写法2\n@Spy\nprivate ExampleService spyExampleService = new ExampleService();\n")])])]),n("p",[t._v("如果没有无参构造函数，必须使用写法2。例子：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("import org.junit.Assert;\nimport org.junit.Test;\nimport org.mockito.MockitoAnnotations;\nimport org.mockito.Spy;\n\nclass ExampleService {\n\n    private int a;\n\n    public ExampleService(int a) {\n        this.a = a;\n    }\n\n    int add(int b) {\n        return a+b;\n    }\n\n}\n\npublic class MockitoDemo {\n\n    @Spy\n    private ExampleService spyExampleService = new ExampleService(1);\n\n    @Test\n    public void test_spy() {\n\n        MockitoAnnotations.initMocks(this);\n\n        Assert.assertEquals(3, spyExampleService.add(2));\n\n    }\n\n}\n")])])]),n("h3",{attrs:{id:"测试-测试隔离"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#测试-测试隔离"}},[t._v("#")]),t._v(" 测试:测试隔离")]),t._v(" "),n("blockquote",[n("p",[t._v("根据 JUnit 单测隔离 ，当 Mockito 和 JUnit 配合使用时，也会将非static变量或者非单例隔离开。")])]),t._v(" "),n("p",[t._v("比如使用 @Mock 修饰的 mock 对象在不同的单测中会被隔离开。")]),t._v(" "),n("p",[t._v("示例：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v('import org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\n\nimport static org.mockito.Mockito.*;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class MockitoDemo {\n\n    static class ExampleService {\n\n        public int add(int a, int b) {\n            return a+b;\n        }\n\n    }\n\n    @Mock\n    private ExampleService exampleService;\n\n    @Test\n    public void test01() {\n        System.out.println("---call test01---");\n\n        System.out.println("打桩前: " + exampleService.add(1, 2));\n\n        when(exampleService.add(1, 2)).thenReturn(100);\n\n        System.out.println("打桩后: " + exampleService.add(1, 2));\n    }\n\n    @Test\n    public void test02() {\n        System.out.println("---call test02---");\n\n        System.out.println("打桩前: " + exampleService.add(1, 2));\n\n        when(exampleService.add(1, 2)).thenReturn(100);\n\n        System.out.println("打桩后: " + exampleService.add(1, 2));\n    }\n\n}\n')])])]),n("p",[t._v("将两个单测一起运行，运行结果是：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("---call test01---\n打桩前: 0\n打桩后: 100\n---call test02---\n打桩前: 0\n打桩后: 100\n")])])]),n("p",[t._v("test01 先被执行，打桩前调用add(1, 2)的结果是0，打桩后是 100。")]),t._v(" "),n("p",[t._v("然后 test02 被执行，打桩前调用add(1, 2)的结果是0，而非 100，这证明了我们上面的说法。")]),t._v(" "),n("h3",{attrs:{id:"测试-结合powermock支持静态方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#测试-结合powermock支持静态方法"}},[t._v("#")]),t._v(" 测试:结合PowerMock支持静态方法")]),t._v(" "),n("blockquote",[n("p",[t._v("PowerMock 是一个增强库，用来增加 Mockito 、EasyMock 等测试库的功能。")])]),t._v(" "),n("p",[t._v("Mockito为什么不能mock静态方法?")]),t._v(" "),n("p",[t._v("因为Mockito使用继承的方式实现mock的，用CGLIB生成mock对象代替真实的对象进行执行，为了mock实例的方法，你可以在subclass中覆盖它，而static方法是不能被子类覆盖的，所以Mockito不能mock静态方法。")]),t._v(" "),n("p",[t._v("但PowerMock可以mock静态方法，因为它直接在bytecode上工作。")]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("Mockito 默认是不支持静态方法")])])]),t._v(" "),n("p",[t._v("比如我们在 ExampleService 类中定义静态方法 add：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("public class ExampleService {\n\n    public static int add(int a, int b) {\n        return a+b;\n    }\n\n}\n")])])]),n("p",[t._v("尝试给静态方法打桩，会报错：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("import org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\n\nimport static org.mockito.Mockito.*;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class MockitoDemo {\n\n    @Test\n    public void test() {\n\n        // 会报错\n        when(ExampleService.add(1, 2)).thenReturn(100);\n\n    }\n\n}\n")])])]),n("ul",[n("li",[n("strong",[t._v("可以用 Powermock 弥补 Mockito 缺失的静态方法 mock 功能")])])]),t._v(" "),n("p",[t._v("在 pom.xml\n中配置以下依赖：(版本的匹配问题可以参考：https://github.com/powermock/powermock/wiki/Mockito)")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("<properties>\n    <powermock.version>2.0.2</powermock.version>\n</properties>\n<dependencies>\n   <dependency>\n      <groupId>org.powermock</groupId>\n      <artifactId>powermock-module-junit4</artifactId>\n      <version>${powermock.version}</version>\n      <scope>test</scope>\n   </dependency>\n   <dependency>\n      <groupId>org.powermock</groupId>\n      <artifactId>powermock-api-mockito2</artifactId>\n      <version>${powermock.version}</version>\n      <scope>test</scope>\n   </dependency>\n</dependencies>\n")])])]),n("p",[t._v("示例：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("import org.junit.Assert;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.powermock.api.mockito.PowerMockito;\nimport org.powermock.core.classloader.annotations.PrepareForTest;\nimport org.powermock.modules.junit4.PowerMockRunner;\n\nimport static org.mockito.Mockito.*;\n\n@RunWith(PowerMockRunner.class)     // 这是必须的\n@PrepareForTest(ExampleService.class)  // 声明要处理 ExampleService\npublic class MockitoDemo {\n    @Test\n    public void test() {\n\n        PowerMockito.mockStatic(ExampleService.class);  // 这也是必须的\n\n        when(ExampleService.add(1, 2)).thenReturn(100);\n\n        Assert.assertEquals(100, ExampleService.add(1, 2));\n        Assert.assertEquals(0, ExampleService.add(2, 2));\n\n    }\n}\n")])])]),n("ul",[n("li",[n("strong",[t._v("PowerMockRunner 支持 Mockito 的 @Mock 等注解")])])]),t._v(" "),n("p",[t._v("上面我们用了 PowerMockRunner ，MockitoJUnitRunner 就不能用了。但不要担心， @Mock 等注解还能用。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("import org.junit.Assert;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.powermock.modules.junit4.PowerMockRunner;\n\nimport java.util.Random;\n\nimport static org.mockito.Mockito.*;\n\n@RunWith(PowerMockRunner.class)\npublic class MockitoDemo {\n\n    @Mock\n    private Random random;\n\n    @Test\n    public void test() {\n\n        when(random.nextInt()).thenReturn(1);\n        Assert.assertEquals(1,  random.nextInt());\n\n    }\n}\n")])])]),n("h2",{attrs:{id:"参考文章"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[t._v("#")]),t._v(" 参考文章")]),t._v(" "),n("ul",[n("li",[t._v("https://www.cnblogs.com/oldboyooxx/p/11147474")]),t._v(" "),n("li",[t._v("https://www.cnblogs.com/bodhitree/p/9456515")])])])}),[],!1,null,null,null);n.default=s.exports}}]);