(window.webpackJsonp=window.webpackJsonp||[]).push([[413],{745:function(a,t,e){"use strict";e.r(t);var n=e(4),r=Object(n.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"行为型-策略-strategy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#行为型-策略-strategy"}},[a._v("#")]),a._v(" 行为型 - 策略(Strategy)")]),a._v(" "),t("blockquote",[t("p",[a._v("策略模式(strategy pattern): 定义了算法族, 分别封闭起来, 让它们之间可以互相替换,\n此模式让算法的变化独立于使用算法的客户。")])]),a._v(" "),t("h2",{attrs:{id:"意图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#意图"}},[a._v("#")]),a._v(" 意图")]),a._v(" "),t("p",[a._v("定义一系列算法，封装每个算法，并使它们可以互换。")]),a._v(" "),t("p",[a._v("策略模式可以让算法独立于使用它的客户端。")]),a._v(" "),t("h2",{attrs:{id:"类图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类图"}},[a._v("#")]),a._v(" 类图")]),a._v(" "),t("ul",[t("li",[a._v("Strategy 接口定义了一个算法族，它们都具有 behavior() 方法。")]),a._v(" "),t("li",[a._v("Context 是使用到该算法族的类，其中的 doSomething() 方法会调用 behavior()，setStrategy(in Strategy) 方法可以动态地改变 strategy 对象，也就是说能动态地改变 Context 所使用的算法。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/1fc969e4-0e7c-441b-b53c-01950d2f2be5.png",alt:"img"}})]),a._v(" "),t("h2",{attrs:{id:"与状态模式的比较"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#与状态模式的比较"}},[a._v("#")]),a._v(" 与状态模式的比较")]),a._v(" "),t("p",[a._v("状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过\nContext 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State\n对象发生改变，注意必须要是在运行过程中。")]),a._v(" "),t("p",[a._v("状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context\n对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。")]),a._v(" "),t("h2",{attrs:{id:"实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[a._v("#")]),a._v(" 实现")]),a._v(" "),t("p",[a._v("设计一个鸭子，它可以动态地改变叫声。这里的算法族是鸭子的叫声行为。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v('public interface QuackBehavior {\n    void quack();\n}\n\n\n\npublic class Quack implements QuackBehavior {\n    @Override\n    public void quack() {\n        System.out.println("quack!");\n    }\n}\n\n\n\npublic class Squeak implements QuackBehavior{\n    @Override\n    public void quack() {\n        System.out.println("squeak!");\n    }\n}\n\n\n\npublic class Duck {\n    private QuackBehavior quackBehavior;\n\n    public void performQuack() {\n        if (quackBehavior != null) {\n            quackBehavior.quack();\n        }\n    }\n\n    public void setQuackBehavior(QuackBehavior quackBehavior) {\n        this.quackBehavior = quackBehavior;\n    }\n}\n\n\n\npublic class Client {\n    public static void main(String[] args) {\n        Duck duck = new Duck();\n        duck.setQuackBehavior(new Squeak());\n        duck.performQuack();\n        duck.setQuackBehavior(new Quack());\n        duck.performQuack();\n    }\n}\n\n\n\nsqueak!\nquack!\n')])])]),t("h2",{attrs:{id:"jdk"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdk"}},[a._v("#")]),a._v(" JDK")]),a._v(" "),t("ul",[t("li",[a._v("java.util.Comparator#compare()")]),a._v(" "),t("li",[a._v("javax.servlet.http.HttpServlet")]),a._v(" "),t("li",[a._v("javax.servlet.Filter#doFilter()")])])])}),[],!1,null,null,null);t.default=r.exports}}]);