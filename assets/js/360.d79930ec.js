(window.webpackJsonp=window.webpackJsonp||[]).push([[360],{691:function(e,t,s){"use strict";s.r(t);var r=s(4),n=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"分布式系统-分布式锁及实现方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分布式系统-分布式锁及实现方案"}},[e._v("#")]),e._v(" 分布式系统 - 分布式锁及实现方案")]),e._v(" "),t("blockquote",[t("p",[e._v("本文主要介绍分布式锁的概念和分布式锁的设计原则，以及常见的分布式锁的实现方式。")])]),e._v(" "),t("h2",{attrs:{id:"什么是分布式锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是分布式锁"}},[e._v("#")]),e._v(" 什么是分布式锁")]),e._v(" "),t("blockquote",[t("p",[e._v("要介绍分布式锁，首先要提到与分布式锁相对应的是线程锁、进程锁。")])]),e._v(" "),t("ul",[t("li",[t("p",[t("strong",[e._v("线程锁")]),e._v(" ：主要用来给方法、代码块加锁。当某个方法或代码使用锁，在同一时刻仅有一个线程执行该方法或该代码段。线程锁只在同一JVM中有效果，因为线程锁的实现在根本上是依靠线程之间共享内存实现的，比如synchronized是共享对象头，显示锁Lock是共享某个变量（state）。")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("进程锁")]),e._v(" ：为了控制同一操作系统中多个进程访问某个共享资源，因为进程具有独立性，各个进程无法访问其他进程的资源，因此无法通过synchronized等线程锁实现进程锁。")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("分布式锁")]),e._v(" ：当多个进程不在同一个系统中(比如分布式系统中控制共享资源访问)，用分布式锁控制多个进程对资源的访问。")])])]),e._v(" "),t("h2",{attrs:{id:"分布式锁的设计原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁的设计原则"}},[e._v("#")]),e._v(" 分布式锁的设计原则")]),e._v(" "),t("blockquote",[t("p",[e._v("分布式锁的最小设计原则："),t("strong",[e._v("安全性")]),e._v(" 和"),t("strong",[e._v("有效性")])])]),e._v(" "),t("p",[t("a",{attrs:{href:"https://redis.io/docs/reference/patterns/distributed-locks/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Redis的官网在新窗口打开"),t("OutboundLink")],1),e._v("上对使用分布式锁提出至少需要满足如下三个要求：")]),e._v(" "),t("ol",[t("li",[t("strong",[e._v("互斥")]),e._v(" （属于安全性）：在任何给定时刻，只有一个客户端可以持有锁。")]),e._v(" "),t("li",[t("strong",[e._v("无死锁")]),e._v(" （属于有效性）：即使锁定资源的客户端崩溃或被分区，也总是可以获得锁；通常通过超时机制实现。")]),e._v(" "),t("li",[t("strong",[e._v("容错性")]),e._v(" （属于有效性）：只要大多数 Redis 节点都启动，客户端就可以获取和释放锁。")])]),e._v(" "),t("p",[e._v("除此之外，分布式锁的设计中还可以/需要考虑：")]),e._v(" "),t("ol",[t("li",[e._v("加锁解锁的"),t("strong",[e._v("同源性")]),e._v(" ：A加的锁，不能被B解锁")]),e._v(" "),t("li",[e._v("获取锁是"),t("strong",[e._v("非阻塞")]),e._v(" 的：如果获取不到锁，不能无限期等待；")]),e._v(" "),t("li",[t("strong",[e._v("高性能")]),e._v(" ：加锁解锁是高性能的")])]),e._v(" "),t("h2",{attrs:{id:"分布式锁的实现方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁的实现方案"}},[e._v("#")]),e._v(" 分布式锁的实现方案")]),e._v(" "),t("blockquote",[t("p",[e._v("就体系的角度而言，谈谈常见的分布式锁的实现方案。")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("基于数据库实现分布式锁")]),e._v(" "),t("ul",[t("li",[e._v("基于数据库表（锁表，很少使用）")]),e._v(" "),t("li",[e._v("乐观锁(基于版本号)")]),e._v(" "),t("li",[e._v("悲观锁(基于排它锁)")])])]),e._v(" "),t("li",[t("strong",[e._v("基于 redis 实现分布式锁")]),e._v(" :\n"),t("ul",[t("li",[e._v("单个Redis实例：setnx(key,当前时间+过期时间) + Lua")]),e._v(" "),t("li",[e._v("Redis集群模式：Redlock")])])]),e._v(" "),t("li",[t("strong",[e._v("基于 zookeeper实现分布式锁")]),e._v(" "),t("ul",[t("li",[e._v("临时有序节点来实现的分布式锁,Curator")])])]),e._v(" "),t("li",[t("strong",[e._v("基于 Consul 实现分布式锁")])])]),e._v(" "),t("h2",{attrs:{id:"基于数据库如何实现分布式锁-有什么缺陷"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基于数据库如何实现分布式锁-有什么缺陷"}},[e._v("#")]),e._v(" 基于数据库如何实现分布式锁？有什么缺陷？")]),e._v(" "),t("blockquote",[t("p",[e._v("基于数据库如何实现分布式锁？有什么缺陷？")])]),e._v(" "),t("h3",{attrs:{id:"基于数据库表-锁表-很少使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基于数据库表-锁表-很少使用"}},[e._v("#")]),e._v(" 基于数据库表（锁表，很少使用）")]),e._v(" "),t("p",[e._v("最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。当我们想要获得锁的时候，就可以在该表中增加一条记录，想要释放锁的时候就删除这条记录。")]),e._v(" "),t("p",[e._v("为了更好的演示，我们先创建一张数据库表，参考如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("CREATE TABLE database_lock (\n\t`id` BIGINT NOT NULL AUTO_INCREMENT,\n\t`resource` int NOT NULL COMMENT '锁定的资源',\n\t`description` varchar(1024) NOT NULL DEFAULT \"\" COMMENT '描述',\n\tPRIMARY KEY (id),\n\tUNIQUE KEY uiq_idx_resource (resource)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='数据库分布式锁表';\n")])])]),t("p",[e._v("当我们想要获得锁时，可以插入一条数据：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("INSERT INTO database_lock(resource, description) VALUES (1, 'lock');\n")])])]),t("p",[e._v("当需要释放锁的时，可以删除这条数据：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("DELETE FROM database_lock WHERE resource=1;\n")])])]),t("h3",{attrs:{id:"基于悲观锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基于悲观锁"}},[e._v("#")]),e._v(" 基于悲观锁")]),e._v(" "),t("p",[t("strong",[e._v("悲观锁实现思路")]),e._v(" ？")]),e._v(" "),t("ol",[t("li",[e._v("在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。")]),e._v(" "),t("li",[e._v("如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。")]),e._v(" "),t("li",[e._v("如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。")]),e._v(" "),t("li",[e._v("其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。")])]),e._v(" "),t("p",[t("strong",[e._v("以MySQL InnoDB中使用悲观锁为例")]),e._v(" ？")]),e._v(" "),t("p",[e._v("要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set\nautocommit=0;")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("//0.开始事务\nbegin;/begin work;/start transaction; (三者选一就可以)\n//1.查询出商品信息\nselect status from t_goods where id=1 for update;\n//2.根据商品信息生成订单\ninsert into t_orders (id,goods_id) values (null,1);\n//3.修改商品status为2\nupdate t_goods set status=2;\n//4.提交事务\ncommit;/commit work;\n")])])]),t("p",[e._v("上面的查询语句中，我们使用了"),t("code",[e._v("select…for update")]),e._v("的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的\n那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。")]),e._v(" "),t("p",[e._v("上面我们提到，使用"),t("code",[e._v("select…for update")]),e._v("会把数据给锁住，不过我们需要注意一些锁的级别，MySQL\nInnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。")]),e._v(" "),t("h3",{attrs:{id:"基于乐观锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基于乐观锁"}},[e._v("#")]),e._v(" 基于乐观锁")]),e._v(" "),t("p",[e._v("乐观并发控制（又名“乐观锁”，Optimistic Concurrency\nControl，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。")]),e._v(" "),t("p",[t("strong",[e._v("以使用版本号实现乐观锁为例？")])]),e._v(" "),t("p",[e._v("使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("1.查询出商品信息\nselect (status,status,version) from t_goods where id=#{id}\n2.根据商品信息生成订单\n3.修改商品status为2\nupdate t_goods \nset status=2,version=version+1\nwhere id=#{id} and version=#{version};\n")])])]),t("p",[e._v("需要注意的是，乐观锁机制往往基于系统中数据存储逻辑，因此也具备一定的局限性。由于乐观锁机制是在我们的系统中实现的，对于来自外部系统的用户数据更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。在系统设计阶段，我们应该充分考虑到这些情况，并进行相应的调整（如将乐观锁策略在数据库存储过程中实现，对外只开放基于此存储过程的数据更新途径，而不是将数据库表直接对外公开）。")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("缺陷")])])]),e._v(" "),t("p",[e._v("对数据库依赖，开销问题，行锁变表锁问题，无法解决数据库单点和可重入的问题。")]),e._v(" "),t("h2",{attrs:{id:"基于redis如何实现分布式锁-有什么缺陷"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基于redis如何实现分布式锁-有什么缺陷"}},[e._v("#")]),e._v(" 基于redis如何实现分布式锁？有什么缺陷？")]),e._v(" "),t("blockquote",[t("p",[e._v("基于redis如何实现分布式锁？这里一定要看[Redis的官网在新窗口打开](https://redis.io/docs/reference/patterns/distributed-\nlocks/)的分布式锁的实现这篇文章。")])]),e._v(" "),t("h3",{attrs:{id:"set-nx-px-lua"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set-nx-px-lua"}},[e._v("#")]),e._v(" set NX PX + Lua")]),e._v(" "),t("p",[t("strong",[e._v("加锁")]),e._v(" ： set NX PX + 重试 + 重试间隔")]),e._v(" "),t("p",[e._v("向Redis发起如下命令: "),t("code",[e._v("SET productId:lock 0xx9p03001 NX PX 30000")]),e._v('\n其中，"productId"由自己定义，可以是与本次业务有关的id，"0xx9p03001"是一串随机值，必须保证全局唯一(原因在后文中会提到)，“NX"指的是当且仅当key(也就是案例中的"productId:lock”)在Redis中不存在时，返回执行成功，否则执行失败。"PX\n30000"指的是在30秒后，key将被自动删除。执行命令后返回成功，表明服务成功的获得了锁。')]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('@Override\npublic boolean lock(String key, long expire, int retryTimes, long retryDuration) {\n    // use JedisCommands instead of setIfAbsense\n    boolean result = setRedis(key, expire);\n\n    // retry if needed\n    while ((!result) && retryTimes-- > 0) {\n        try {\n            log.debug("lock failed, retrying..." + retryTimes);\n            Thread.sleep(retryDuration);\n        } catch (Exception e) {\n            return false;\n        }\n\n        // use JedisCommands instead of setIfAbsense\n        result = setRedis(key, expire);\n    }\n    return result;\n}\n\nprivate boolean setRedis(String key, long expire) {\n    try {\n        RedisCallback<String> redisCallback = connection -> {\n            JedisCommands commands = (JedisCommands) connection.getNativeConnection();\n            String uuid = SnowIDUtil.uniqueStr();\n            lockFlag.set(uuid);\n            return commands.set(key, uuid, NX, PX, expire); // 看这里\n        };\n        String result = redisTemplate.execute(redisCallback);\n        return !StringUtil.isEmpty(result);\n    } catch (Exception e) {\n        log.error("set redis occurred an exception", e);\n    }\n    return false;\n}\n')])])]),t("p",[t("strong",[e._v("解锁")]),e._v(" ：采用lua脚本")]),e._v(" "),t("p",[e._v("在删除key之前，一定要判断服务A持有的value与Redis内存储的value是否一致。如果贸然使用服务A持有的key来删除锁，则会误将服务B的锁释放掉。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('if redis.call("get", KEYS[1])==ARGV[1] then\n\treturn redis.call("del", KEYS[1])\nelse\n\treturn 0\nend\n')])])]),t("h3",{attrs:{id:"基于redlock实现分布式锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基于redlock实现分布式锁"}},[e._v("#")]),e._v(" 基于RedLock实现分布式锁")]),e._v(" "),t("blockquote",[t("p",[e._v("这是Redis作者推荐的分布式集群情况下的方式，请看这篇文章"),t("a",{attrs:{href:"http://antirez.com/news/101",target:"_blank",rel:"noopener noreferrer"}},[e._v("Is Redlock\nsafe?在新窗口打开"),t("OutboundLink")],1)])]),e._v(" "),t("p",[e._v("假设有两个服务A、B都希望获得锁，有一个包含了5个redis master的Redis Cluster，执行过程大致如下:")]),e._v(" "),t("ol",[t("li",[e._v("客户端获取当前时间戳，单位: 毫秒")]),e._v(" "),t("li",[e._v("服务A轮寻每个master节点，尝试创建锁。(这里锁的过期时间比较短，一般就几十毫秒) RedLock算法会尝试在大多数节点上分别创建锁，假如节点总数为n，那么大多数节点指的是n/2+1。")]),e._v(" "),t("li",[e._v("客户端计算成功建立完锁的时间，如果建锁时间小于超时时间，就可以判定锁创建成功。如果锁创建失败，则依次(遍历master节点)删除锁。")]),e._v(" "),t("li",[e._v("只要有其它服务创建过分布式锁，那么当前服务就必须轮寻尝试获取锁。")])]),e._v(" "),t("h3",{attrs:{id:"基于redis的客户端"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基于redis的客户端"}},[e._v("#")]),e._v(" 基于Redis的客户端")]),e._v(" "),t("blockquote",[t("p",[e._v("这里Redis的客户端（Jedis, Redisson,\nLettuce等）都是基于上述两类形式来实现分布式锁的，只是两类形式的封装以及一些优化（比如Redisson的watch dog)。")])]),e._v(" "),t("p",[e._v("以基于Redisson实现分布式锁为例（支持了 单实例、Redis哨兵、redis cluster、redis master-slave等各种部署架构）：")]),e._v(" "),t("p",[t("strong",[e._v("特色")]),e._v(" ？")]),e._v(" "),t("ol",[t("li",[e._v("redisson所有指令都通过lua脚本执行，保证了操作的原子性")]),e._v(" "),t("li",[e._v("redisson设置了watchdog看门狗，“看门狗”的逻辑保证了没有死锁发生")]),e._v(" "),t("li",[e._v("redisson支持Redlock的实现方式。")])]),e._v(" "),t("p",[t("strong",[e._v("过程")]),e._v(" ？")]),e._v(" "),t("ol",[t("li",[e._v("线程去获取锁，获取成功: 执行lua脚本，保存数据到redis数据库。")]),e._v(" "),t("li",[e._v("线程去获取锁，获取失败: 订阅了解锁消息，然后再尝试获取锁，获取成功后，执行lua脚本，保存数据到redis数据库。")])]),e._v(" "),t("p",[t("strong",[e._v("互斥")]),e._v(" ？")]),e._v(" "),t("p",[e._v("如果这个时候客户端B来尝试加锁，执行了同样的一段lua脚本。第一个if判断会执行“exists\nmyLock”，发现myLock这个锁key已经存在。接着第二个if判断，判断myLock锁key的hash数据结构中，是否包含客户端B的ID，但明显没有，那么客户端B会获取到pttl\nmyLock返回的一个数字，代表myLock这个锁key的剩余生存时间。此时客户端B会进入一个while循环，不听的尝试加锁。")]),e._v(" "),t("p",[t("strong",[e._v("watch dog自动延时机制")]),e._v(" ？")]),e._v(" "),t("p",[e._v("​客户端A加锁的锁key默认生存时间只有30秒，如果超过了30秒，客户端A还想一直持有这把锁，怎么办？其实只要客户端A一旦加锁成功，就会启动一个watch\ndog看门狗，它是一个后台线程，会每隔10秒检查一下，如果客户端A还持有锁key，那么就会不断的延长锁key的生存时间。")]),e._v(" "),t("p",[t("strong",[e._v("可重入")]),e._v(" ？")]),e._v(" "),t("p",[e._v("每次lock会调用incrby，每次unlock会减一。")]),e._v(" "),t("h3",{attrs:{id:"进一步理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进一步理解"}},[e._v("#")]),e._v(" 进一步理解")]),e._v(" "),t("ol",[t("li",[e._v("借助Redis实现分布式锁时，有一个共同的缺陷: 当获取锁被拒绝后，需要不断的循环，重新发送获取锁(创建key)的请求，直到请求成功。这就造成空转，浪费宝贵的CPU资源。")]),e._v(" "),t("li",[e._v("RedLock算法本身有争议，具体看这篇文章"),t("a",{attrs:{href:"https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("How to do distributed locking在新窗口打开"),t("OutboundLink")],1),e._v(" 以及作者的回复"),t("a",{attrs:{href:"http://antirez.com/news/101",target:"_blank",rel:"noopener noreferrer"}},[e._v("Is Redlock safe?在新窗口打开"),t("OutboundLink")],1)])]),e._v(" "),t("h2",{attrs:{id:"基于zookeeper如何实现分布式锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基于zookeeper如何实现分布式锁"}},[e._v("#")]),e._v(" 基于zookeeper如何实现分布式锁？")]),e._v(" "),t("p",[e._v("说几个核心点：")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("顺序节点")])])]),e._v(" "),t("p",[e._v("创建一个用于发号的节点“/test/lock”，然后以它为父亲节点的前缀为“/test/lock/seq-”依次发号：")]),e._v(" "),t("p",[t("img",{attrs:{src:"/images/zk/zk-1.png",alt:""}})]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("获得最小号得锁")])])]),e._v(" "),t("p",[e._v("由于序号的递增性，可以规定排号最小的那个获得锁。所以，每个线程在尝试占用锁之前，首先判断自己是排号是不是当前最小，如果是，则获取锁。")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("节点监听机制")])])]),e._v(" "),t("p",[e._v("每个线程抢占锁之前，先抢号创建自己的ZNode。同样，释放锁的时候，就需要删除抢号的Znode。抢号成功后，如果不是排号最小的节点，就处于等待通知的状态。等谁的通知呢？不需要其他人，只需要等前一个Znode\n的通知就可以了。当前一个Znode 删除的时候，就是轮到了自己占有锁的时候。第一个通知第二个、第二个通知第三个，击鼓传花似的依次向后。")]),e._v(" "),t("h2",{attrs:{id:"参考文章"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[e._v("#")]),e._v(" 参考文章")]),e._v(" "),t("ul",[t("li",[t("p",[t("a",{attrs:{href:"http://antirez.com/news/101",target:"_blank",rel:"noopener noreferrer"}},[e._v("Is Redlock safe?在新窗口打开"),t("OutboundLink")],1)])]),e._v(" "),t("li",[t("p",[e._v("https://juejin.im/post/6872001566111596552")])]),e._v(" "),t("li",[t("p",[e._v("https://juejin.im/post/6872886438325813256")])]),e._v(" "),t("li",[t("p",[e._v("https://juejin.im/post/6850418111700680712")])])])])}),[],!1,null,null,null);t.default=n.exports}}]);