(window.webpackJsonp=window.webpackJsonp||[]).push([[183],{514:function(a,t,r){"use strict";r.r(t);var v=r(4),e=Object(v.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"字符串匹配-overview"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字符串匹配-overview"}},[a._v("#")]),a._v(" 字符串匹配 - Overview")]),a._v(" "),t("blockquote",[t("p",[a._v("字符串匹配(String Matchiing)也称字符串搜索(String Searching)是字符串算法中重要的一种，是指从一个大字符串或文本中找到模式串出现的位置。")])]),a._v(" "),t("h2",{attrs:{id:"字符串匹配概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字符串匹配概念"}},[a._v("#")]),a._v(" 字符串匹配概念")]),a._v(" "),t("blockquote",[t("p",[a._v("字符串匹配问题的形式定义：")])]),a._v(" "),t("ul",[t("li",[a._v("文本（Text）是一个长度为 n 的数组 T[1..n]；")]),a._v(" "),t("li",[a._v("模式（Pattern）是一个长度为 m 且 m≤n 的数组 P[1..m]；")]),a._v(" "),t("li",[a._v("T 和 P 中的元素都属于有限的字母表 Σ 表；")]),a._v(" "),t("li",[a._v("如果 0≤s≤n-m，并且 T[s+1..s+m] = P[1..m]，即对 1≤j≤m，有 T[s+j] = P[j]，则说模式 P 在文本 T 中出现且位移为 s，且称 s 是一个有效位移（Valid Shift）。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/alg-domain-char-match-11.png",alt:"img"}})]),a._v(" "),t("p",[a._v("比如上图中，目标是找出所有在文本 T = abcabaabcabac 中模式 P = abaa 的所有出现。该模式在此文本中仅出现一次，即在位移 s = 3\n处，位移 s = 3 是有效位移。")]),a._v(" "),t("p",[a._v("字符串匹配算法通常分为两个步骤：预处理（Preprocessing）和匹配（Matching）。所以算法的总运行时间为预处理和匹配的时间的总和。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/alg-domain-char-match-12.png",alt:"img"}})]),a._v(" "),t("p",[a._v("上图描述了常见字符串匹配算法的预处理和匹配时间。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/alg-domain-char-1.gif",alt:"img"}})]),a._v(" "),t("h2",{attrs:{id:"字符串匹配算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字符串匹配算法"}},[a._v("#")]),a._v(" 字符串匹配算法")]),a._v(" "),t("blockquote",[t("p",[a._v("解决字符串匹配的算法包括："),t("code",[a._v("朴素算法（Naive Algorithm）")]),a._v(" 即暴力破解、"),t("code",[a._v("Rabin-Karp 算法")]),a._v("、"),t("code",[a._v("有限自动机算法（Finite Automation）")]),a._v("、 "),t("code",[a._v("Knuth-Morris-Pratt 算法（即 KMP Algorithm）")]),a._v("、"),t("code",[a._v("Boyer-Moore 算法")]),a._v("、"),t("code",[a._v("Simon 算法")]),a._v("、"),t("code",[a._v("Colussi 算法")]),a._v("、"),t("code",[a._v("Galil-Giancarlo 算法")]),a._v("、"),t("code",[a._v("Apostolico-Crochemore 算法")]),a._v("、"),t("code",[a._v("Horspool 算法")]),a._v("和 "),t("code",[a._v("Sunday 算法")]),a._v("等。")])]),a._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"/pages/alg-domain-char-match-bf"}},[a._v("朴素的字符串匹配算法（Naive String Matching Algorithm)")]),a._v(" "),t("ul",[t("li",[a._v("朴素的字符串匹配算法又称为"),t("strong",[a._v("暴力匹配算法")]),a._v(" （Brute Force Algorithm），最为简单的字符串匹配算法")])])]),a._v(" "),t("li",[t("a",{attrs:{href:"/pages/alg-domain-char-match-kmp"}},[a._v("Knuth-Morris-Pratt 字符串匹配算法（即 KMP 算法）")]),a._v(" "),t("ul",[t("li",[a._v("Knuth-Morris-Pratt算法（简称KMP）是最常用的字符串匹配算法之一")])])]),a._v(" "),t("li",[t("a",{attrs:{href:"/pages/alg-domain-char-match-bm"}},[a._v("Boyer-Moore 字符串匹配算法")]),a._v(" "),t("ul",[t("li",[a._v('各种文本编辑器的"查找"功能（Ctrl+F），大多采用Boyer-Moore算法，效率非常高')])])]),a._v(" "),t("li",[t("a",{attrs:{href:"/pages/alg-domain-char-match-st"}},[a._v("字符串匹配 - 文本预处理：后缀树（Suffix Tree）")]),a._v(" "),t("ul",[t("li",[a._v("上述字符串匹配算法(朴素的字符串匹配算法, KMP 算法, Boyer-Moore算法)均是通过对"),t("strong",[a._v("模式（Pattern）字符串进行预处理")]),a._v(" 的方式来加快搜索速度。对 Pattern 进行预处理的最优复杂度为 O(m)，其中 m 为 Pattern 字符串的长度。那么，有没有对文本（Text）进行预处理的算法呢？本文即将介绍一种"),t("strong",[a._v("对 Text 进行预处理")]),a._v(" 的字符串匹配算法：后缀树（Suffix Tree）")])])])])])}),[],!1,null,null,null);t.default=e.exports}}]);