(window.webpackJsonp=window.webpackJsonp||[]).push([[218],{549:function(t,a,_){"use strict";_.r(a);var s=_(4),v=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"mysql-性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql-性能优化"}},[t._v("#")]),t._v(" MySQL - 性能优化")]),t._v(" "),a("h2",{attrs:{id:"使用-explain-进行分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-explain-进行分析"}},[t._v("#")]),t._v(" 使用 Explain 进行分析")]),t._v(" "),a("p",[t._v("Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。")]),t._v(" "),a("p",[t._v("比较重要的字段有:")]),t._v(" "),a("ul",[a("li",[t._v("select_type : 查询类型，有简单查询、联合查询、子查询等")]),t._v(" "),a("li",[t._v("key : 使用的索引")]),t._v(" "),a("li",[t._v("rows : 扫描的行数")])]),t._v(" "),a("h2",{attrs:{id:"优化数据访问"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化数据访问"}},[t._v("#")]),t._v(" 优化数据访问")]),t._v(" "),a("h3",{attrs:{id:"_1-减少请求的数据量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-减少请求的数据量"}},[t._v("#")]),t._v(" 1. 减少请求的数据量")]),t._v(" "),a("ul",[a("li",[t._v("只返回必要的列: 最好不要使用 SELECT * 语句。")]),t._v(" "),a("li",[t._v("只返回必要的行: 使用 LIMIT 语句来限制返回的数据。")]),t._v(" "),a("li",[t._v("缓存重复查询的数据: 使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。")])]),t._v(" "),a("h3",{attrs:{id:"_2-减少服务器端扫描的行数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-减少服务器端扫描的行数"}},[t._v("#")]),t._v(" 2. 减少服务器端扫描的行数")]),t._v(" "),a("p",[t._v("最有效的方式是使用索引来覆盖查询。")]),t._v(" "),a("h2",{attrs:{id:"重构查询方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重构查询方式"}},[t._v("#")]),t._v(" 重构查询方式")]),t._v(" "),a("h3",{attrs:{id:"_1-切分大查询"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-切分大查询"}},[t._v("#")]),t._v(" 1. 切分大查询")]),t._v(" "),a("p",[t._v("一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('DELEFT FROM messages WHERE create < DATE_SUB(NOW(), INTERVAL 3 MONTH);\n\n\n\nrows_affected = 0\ndo {\n    rows_affected = do_query(\n    "DELETE FROM messages WHERE create  < DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000")\n} while rows_affected > 0\n')])])]),a("h3",{attrs:{id:"_2-分解大连接查询"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-分解大连接查询"}},[t._v("#")]),t._v(" 2. 分解大连接查询")]),t._v(" "),a("p",[t._v("将一个大连接查询分解成对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，这样做的好处有:")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。")])]),t._v(" "),a("li",[a("p",[t._v("分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。")])]),t._v(" "),a("li",[a("p",[t._v("减少锁竞争；")])]),t._v(" "),a("li",[a("p",[t._v("在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。")])]),t._v(" "),a("li",[a("p",[t._v("查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。")]),t._v(" "),a("p",[t._v("SELECT * FROM tab\nJOIN tag_post ON tag_post.tag_id=tag.id\nJOIN post ON tag_post.post_id=post.id\nWHERE tag.tag='mysql';")]),t._v(" "),a("p",[t._v("SELECT * FROM tag WHERE tag='mysql';\nSELECT * FROM tag_post WHERE tag_id=1234;\nSELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);")])])])])}),[],!1,null,null,null);a.default=v.exports}}]);