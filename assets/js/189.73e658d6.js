(window.webpackJsonp=window.webpackJsonp||[]).push([[189],{521:function(a,_,h){"use strict";h.r(_);var s=h(4),r=Object(s.a)({},(function(){var a=this,_=a._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"大数据处理-分治-hash-排序"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#大数据处理-分治-hash-排序"}},[a._v("#")]),a._v(" 大数据处理 - 分治/hash/排序")]),a._v(" "),_("blockquote",[_("p",[a._v("大数据处理思路: 分而治之/Hash映射 + Hash_map统计 + 堆/快速/归并排序。")])]),a._v(" "),_("h2",{attrs:{id:"思路简介"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#思路简介"}},[a._v("#")]),a._v(" 思路简介")]),a._v(" "),_("blockquote",[_("p",[a._v("分而治之/hash映射 + hash统计 + 堆/快速/归并排序，说白了，就是先映射，而后统计，最后排序:")])]),a._v(" "),_("ul",[_("li",[_("p",[_("code",[a._v("分而治之/hash映射")]),a._v(": 针对数据太大，内存受限，只能是: 把大文件化成(取模映射)小文件，即16字方针: 大而化小，各个击破，缩小规模，逐个解决")])]),a._v(" "),_("li",[_("p",[_("code",[a._v("hash_map统计")]),a._v(": 当大文件转化了小文件，那么我们便可以采用常规的hash_map(ip，value)来进行频率统计。")])]),a._v(" "),_("li",[_("p",[_("code",[a._v("堆/快速排序")]),a._v(": 统计完了之后，便进行排序(可采取堆排序)，得到次数最多的IP。")])])]),a._v(" "),_("h2",{attrs:{id:"案例分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#案例分析"}},[a._v("#")]),a._v(" 案例分析")]),a._v(" "),_("h3",{attrs:{id:"海量日志数据-提取出某日访问百度次数最多的那个ip"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#海量日志数据-提取出某日访问百度次数最多的那个ip"}},[a._v("#")]),a._v(" 海量日志数据，提取出某日访问百度次数最多的那个IP")]),a._v(" "),_("p",[a._v("分析:\n“首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法，比如%1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP(可以采用hash_map对那1000个文件中的所有IP进行频率统计，然后依次找出各个文件中频率最大的那个IP)及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。”")]),a._v(" "),_("p",[a._v("关于本题，还有几个问题，如下:")]),a._v(" "),_("ul",[_("li",[a._v("Hash取模是一种等价映射，不会存在同一个元素分散到不同小文件中的情况，即这里采用的是mod1000算法，那么相同的IP在hash取模后，只可能落在同一个文件中，不可能被分散的。因为如果两个IP相等，那么经过Hash(IP)之后的哈希值是相同的，将此哈希值取模(如模1000)，必定仍然相等。")]),a._v(" "),_("li",[a._v("那到底什么是hash映射呢? 简单来说，就是为了便于计算机在有限的内存中处理big数据，从而通过一种映射散列的方式让数据均匀分布在对应的内存位置(如大数据通过取余的方式映射成小树存放在内存中，或大文件映射成多个小文件)，而这个映射散列方式便是我们通常所说的hash函数，设计的好的hash函数能让数据均匀分布而减少冲突。尽管数据映射到了另外一些不同的位置，但数据还是原来的数据，只是代替和表示这些原始数据的形式发生了变化而已。")])]),a._v(" "),_("h3",{attrs:{id:"寻找热门查询-300万个查询字符串中统计最热门的10个查询"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#寻找热门查询-300万个查询字符串中统计最热门的10个查询"}},[a._v("#")]),a._v(" 寻找热门查询，300万个查询字符串中统计最热门的10个查询")]),a._v(" "),_("p",[a._v("原题:\n搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录(这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门)，请你统计最热门的10个查询串，要求使用的内存不能超过1G。")]),a._v(" "),_("p",[a._v("解答: 由上面第1题，我们知道，数据大则划为小的，如如一亿个Ip求Top\n10，可先%1000将ip分到1000个小文件中去，并保证一种ip只出现在一个文件中，再对每个小文件中的ip进行hashmap计数统计并按数量排序，最后归并或者最小堆依次处理每个小文件的top10以得到最后的结。")]),a._v(" "),_("p",[a._v("但如果数据规模比较小，能一次性装入内存呢?比如这第2题，虽然有一千万个Query，但是由于重复度比较高，因此事实上只有300万的Query，每个Query255Byte，因此我们可以考虑把他们都放进内存中去(300万个字符串假设没有重复，都是最大长度，那么最多占用内存3M*1K/4=0.75G。所以可以将所有字符串都存放在内存中进行处理)，而现在只是需要一个合适的数据结构，在这里，HashTable绝对是我们优先的选择。")]),a._v(" "),_("p",[a._v("所以我们放弃分而治之/hash映射的步骤，直接上hash统计，然后排序。So，针对此类典型的TOP K问题，采取的对策往往是: hashmap +\n堆。如下所示:")]),a._v(" "),_("ul",[_("li",[_("code",[a._v("hash_map统计")]),a._v(": 先对这批海量数据预处理。具体方法是: 维护一个Key为Query字串，Value为该Query出现次数的HashTable，即hash_map(Query，Value)，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。最终我们在O(N)的时间复杂度内用Hash表完成了统计； 堆排序: 第二步、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。即借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比。所以，我们最终的时间复杂度是: O(N) + N' * O(logK)，(N为1000万，N’为300万)。")])]),a._v(" "),_("p",[a._v("别忘了这篇文章中所述的堆排序思路:\n“维护k个元素的最小堆，即用容量为k的最小堆存储最先遍历到的k个数，并假设它们即是最大的k个数，建堆费时O(k)，并调整堆(费时O(logk))后，有k1>k2>...kmin(kmin设为小顶堆中最小元素)。继续遍历数列，每次遍历一个元素x，与堆顶元素比较，若x>kmin，则更新堆(x入堆，用时logk)，否则不更新堆。这样下来，总费时O(k*logk+(n-k)"),_("em",[a._v("logk)=O(n")]),a._v("\nlogk)。此方法得益于在堆中，查找等各项操作时间复杂度均为logk。”--第三章续、Top K算法问题的实现。\n当然，你也可以采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。")]),a._v(" "),_("h3",{attrs:{id:"有一个1g大小的一个文件-里面每一行是一个词-词的大小不超过16字节-内存限制大小是1m。返回频数最高的100个词。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#有一个1g大小的一个文件-里面每一行是一个词-词的大小不超过16字节-内存限制大小是1m。返回频数最高的100个词。"}},[a._v("#")]),a._v(" 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。")]),a._v(" "),_("ul",[_("li",[_("code",[a._v("分而治之/hash映射")]),a._v(": 顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件(记为x0,x1,...x4999)中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。")]),a._v(" "),_("li",[_("code",[a._v("hash_map统计")]),a._v(": 对每个小文件，采用trie树/hash_map等统计每个文件中出现的词以及相应的频率。")]),a._v(" "),_("li",[_("code",[a._v("堆/归并排序")]),a._v(": 取出出现频率最大的100个词(可以用含100个结点的最小堆)后，再把100个词及相应的频率存入文件，这样又得到了5000个文件。最后就是把这5000个文件进行归并(类似于归并排序)的过程了。")])]),a._v(" "),_("h3",{attrs:{id:"海量数据分布在100台电脑中-想个办法高效统计出这批数据的top10。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#海量数据分布在100台电脑中-想个办法高效统计出这批数据的top10。"}},[a._v("#")]),a._v(" 海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。")]),a._v(" "),_("p",[a._v("如果每个数据元素只出现一次，而且只出现在某一台机器中，那么可以采取以下步骤统计出现次数TOP10的数据元素:")]),a._v(" "),_("ul",[_("li",[_("code",[a._v("堆排序")]),a._v(": 在每台电脑上求出TOP10，可以采用包含10个元素的堆完成(TOP10小，用最大堆，TOP10大，用最小堆，比如求TOP10大，我们首先取前10个元素调整成最小堆，如果发现，然后扫描后面的数据，并与堆顶元素比较，如果比堆顶元素大，那么用该元素替换堆顶，然后再调整为最小堆。最后堆中的元素就是TOP10大)。 求出每台电脑上的TOP10后，然后把这100台电脑上的TOP10组合起来，共1000个数据，再利用上面类似的方法求出TOP10就可以了。")])]),a._v(" "),_("p",[a._v("但如果同一个元素重复出现在不同的电脑中呢，如下例子所述, 这个时候，你可以有两种方法:")]),a._v(" "),_("ul",[_("li",[a._v("遍历一遍所有数据，重新hash取摸，如此使得同一个元素只出现在单独的一台电脑中，然后采用上面所说的方法，统计每台电脑中各个元素的出现次数找出TOP10，继而组合100台电脑上的TOP10，找出最终的TOP10。")]),a._v(" "),_("li",[a._v("或者，暴力求解: 直接统计统计每台电脑中各个元素的出现次数，然后把同一个元素在不同机器中的出现次数相加，最终从所有数据中找出TOP10。")])]),a._v(" "),_("h3",{attrs:{id:"有10个文件-每个文件1g-每个文件的每一行存放的都是用户的query-每个文件的query都可能重复。要求你按照query的频度排序。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#有10个文件-每个文件1g-每个文件的每一行存放的都是用户的query-每个文件的query都可能重复。要求你按照query的频度排序。"}},[a._v("#")]),a._v(" 有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。")]),a._v(" "),_("p",[a._v("方案1:")]),a._v(" "),_("ul",[_("li",[_("code",[a._v("hash映射")]),a._v(": 顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件(记为a0,a1,..a9)中。这样新生成的文件每个的大小大约也1G(假设hash函数是随机的)。")]),a._v(" "),_("li",[_("code",[a._v("hash_map统计")]),a._v(": 找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。注: hash_map(query,query_count)是用来统计每个query的出现次数，不是存储他们的值，出现一次，则count+1。 堆/快速/归并排序: 利用快速/堆/归并排序按照出现次数进行排序，将排序好的query和对应的query_cout输出到文件中，这样得到了10个排好序的文件(记为)。最后，对这10个文件进行归并排序(内排序与外排序相结合)。根据此方案1，这里有一份实现: https://github.com/ooooola/sortquery/blob/master/querysort.py。")])]),a._v(" "),_("p",[a._v("方案2:\n一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。")]),a._v(" "),_("p",[a._v("方案3: 与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理(比如MapReduce)，最后再进行合并。")]),a._v(" "),_("h3",{attrs:{id:"给定a、b两个文件-各存放50亿个url-每个url各占64字节-内存限制是4g-让你找出a、b文件共同的url"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#给定a、b两个文件-各存放50亿个url-每个url各占64字节-内存限制是4g-让你找出a、b文件共同的url"}},[a._v("#")]),a._v(" 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url?")]),a._v(" "),_("p",[a._v("可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。")]),a._v(" "),_("p",[_("code",[a._v("分而治之/hash映射")]),a._v(":\n遍历文件a，对每个url求取，然后根据所取得的值将url分别存储到1000个小文件(记为，这里漏写个了a1)中。这样每个小文件的大约为300M。遍历文件b，采取和a相同的方式将url分别存储到1000小文件中(记为)。这样处理后，所有可能相同的url都在对应的小文件()中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。")]),a._v(" "),_("p",[_("code",[a._v("hash_set统计")]),a._v(":\n求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。")]),a._v(" "),_("h3",{attrs:{id:"怎么在海量数据中找出重复次数最多的一个"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#怎么在海量数据中找出重复次数最多的一个"}},[a._v("#")]),a._v(" 怎么在海量数据中找出重复次数最多的一个?")]),a._v(" "),_("p",[a._v("方案:\n先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求(具体参考前面的题)。")]),a._v(" "),_("h3",{attrs:{id:"上千万或上亿数据-有重复-统计其中出现次数最多的前n个数据。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#上千万或上亿数据-有重复-统计其中出现次数最多的前n个数据。"}},[a._v("#")]),a._v(" 上千万或上亿数据(有重复)，统计其中出现次数最多的前N个数据。")]),a._v(" "),_("p",[a._v("方案:\n上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后利用堆取出前N个出现次数最多的数据。")]),a._v(" "),_("h3",{attrs:{id:"一个文本文件-大约有一万行-每行一个词-要求统计出其中最频繁出现的前10个词-请给出思想-给出时间复杂度分析。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一个文本文件-大约有一万行-每行一个词-要求统计出其中最频繁出现的前10个词-请给出思想-给出时间复杂度分析。"}},[a._v("#")]),a._v(" 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。")]),a._v(" "),_("p",[a._v("方案1:\n如果文件比较大，无法一次性读入内存，可以采用hash取模的方法，将大文件分解为多个小文件，对于单个小文件利用hash_map统计出每个小文件中10个最常出现的词，然后再进行归并处理，找出最终的10个最常出现的词。")]),a._v(" "),_("p",[a._v("方案2:\n通过hash取模将大文件分解为多个小文件后，除了可以用hash_map统计出每个小文件中10个最常出现的词，也可以用trie树统计每个词出现的次数，时间复杂度是O(n\n"),_("em",[a._v("le)(le表示单词的平准长度)，最终同样找出出现最频繁的前10个词(可用堆来实现)，时间复杂度是O(n")]),a._v(" lg10)。")]),a._v(" "),_("h3",{attrs:{id:"一个文本文件-找出前10个经常出现的词-但这次文件比较长-说是上亿行或十亿行-总之无法一次读入内存-问最优解。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一个文本文件-找出前10个经常出现的词-但这次文件比较长-说是上亿行或十亿行-总之无法一次读入内存-问最优解。"}},[a._v("#")]),a._v(" 一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。")]),a._v(" "),_("p",[a._v("方案1:\n首先根据用hash并求模，将文件分解为多个小文件，对于单个文件利用上题的方法求出每个文件件中10个最常出现的词。然后再进行归并处理，找出最终的10个最常出现的词。")]),a._v(" "),_("h3",{attrs:{id:"_100w个数中找出最大的100个数。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_100w个数中找出最大的100个数。"}},[a._v("#")]),a._v(" 100w个数中找出最大的100个数。")]),a._v(" "),_("p",[a._v("方案1:\n采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w*100)。")]),a._v(" "),_("p",[a._v("方案2:\n采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100w*100)。")]),a._v(" "),_("p",[a._v("方案3: 在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100w*lg100)。")])])}),[],!1,null,null,null);_.default=r.exports}}]);