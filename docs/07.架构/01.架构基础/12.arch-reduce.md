---
title: 高并发：降级和熔断
date: 2024-06-04 16:35:08
permalink: /pages/arch-reduce/
categories:
  - 架构
  - 架构基础
tags:
  - 
author: 
  name: Cyan
  link: https://github.com/willpast
---
# 架构之高并发：降级和熔断

> 在高并发环境下，**服务之间的依赖关系导致调用失败，解决的方式通常是: 限流- >熔断->隔离->降级, 其目的是防止雪崩效应**。
 
## 为什么会有这个话题

> 服务之间的依赖关系导致

当用户请求 A、P、H、I 四个服务获取数据时，在正常流量下系统稳定运行，如果某天系统进来大量流量，其中服务 I 出现
CPU、内存占用过高等问题，结果导致服务 I 出现延迟、响应过慢，随着请求的持续增加，服务 I
承受不住压力导致内部错误或资源耗尽，一直不响应，此时更糟糕的是其他服务对 I 有依赖，那么这些依赖 I 的服务一直等待 I
的响应，也会出现请求堆积、资源占用，慢慢扩散到所有微服务，引发雪崩效应。

![img](https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/arch-x-reduce-1.png)

## 基本的容错模式

> 常见的容错模式主要包含以下几种方式

  * 主动超时：Http请求主动设置一个超时时间，超时就直接返回，不会造成服务堆积
  * 限流：限制最大并发数
  * 熔断：当错误数超过阈值时快速失败，不调用后端服务，同时隔一定时间放几个请求去重试后端服务是否能正常调用，如果成功则关闭熔断状态，失败则继续快速失败，直接返回。（此处有个重试，重试就是弹性恢复的能力）
  * 隔离：把每个依赖或调用的服务都隔离开来，防止级联失败引起整体服务不可用
  * 降级：服务失败或异常后，返回指定的默认信息

![img](https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/arch-x-reduce-2.png)

## 服务降级

>
> 由于爆炸性的流量冲击，对一些服务进行有策略的放弃，以此缓解系统压力，保证目前主要业务的正常运行。它主要是针对非正常情况下的应急服务措施：当此时一些业务服务无法执行时，给出一个统一的返回结果。

### 降级服务的特征

  * 原因：整体负荷超出整体负载承受能力。
  * 目的：保证重要或基本服务正常运行，非重要服务延迟使用或暂停使用
  * 大小：降低服务粒度，要考虑整体模块粒度的大小，将粒度控制在合适的范围内
  * 可控性：在服务粒度大小的基础上增加服务的可控性，后台服务开关的功能是一项必要配置（单机可配置文件，其他可领用数据库和缓存），可分为手动控制和自动控制。
  * 次序：一般从外围延伸服务开始降级，需要有一定的配置项，重要性低的优先降级，比如可以分组设置等级1-10，当服务需要降级到某一个级别时，进行相关配置

### 降级方式

  * 延迟服务：比如发表了评论，重要服务，比如在文章中显示正常，但是延迟给用户增加积分，只是放到一个缓存中，等服务平稳之后再执行。
  * 在粒度范围内关闭服务（片段降级或服务功能降级）：比如关闭相关文章的推荐，直接关闭推荐区
  * 页面异步请求降级：比如商品详情页上有推荐信息/配送至等异步加载的请求，如果这些信息响应慢或者后端服务有问题，可以进行降级；
  * 页面跳转（页面降级）：比如可以有相关文章推荐，但是更多的页面则直接跳转到某一个地址
  * 写降级：比如秒杀抢购，我们可以只进行Cache的更新，然后异步同步扣减库存到DB，保证最终一致性即可，此时可以将DB降级为Cache。
  * 读降级：比如多级缓存模式，如果后端服务有问题，可以降级为只读缓存，这种方式适用于对读一致性要求不高的场景。

### 降级预案

在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：

  * 一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；
  * 警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；
  * 错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；
  * 严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。

### 服务降级分类

  * 降级按照是否自动化可分为：自动开关降级（超时、失败次数、故障、限流）和人工开关降级（秒杀、电商大促等）。
  * 降级按照功能可分为：读服务降级、写服务降级。
  * 降级按照处于的系统层次可分为：多级降级。

### 自动降级分类

  * 超时降级：主要配置好超时时间和超时重试次数和机制，并使用异步机制探测回复情况
  * 失败次数降级：主要是一些不稳定的api，当失败调用次数达到一定阀值自动降级，同样要使用异步机制探测回复情况
  * 故障降级：比如要调用的远程服务挂掉了（网络故障、DNS故障、http服务返回错误的状态码、rpc服务抛出异常），则可以直接降级。降级后的处理方案有：默认值（比如库存服务挂了，返回默认现货）、兜底数据（比如广告挂了，返回提前准备好的一些静态页面）、缓存（之前暂存的一些缓存数据）
  * 限流降级: 当我们去秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时开发者会使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；降级后的处理方案可以是：排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）

### 服务降级需考虑的问题

  * 核心服务或非核心服务。
  * 是否支持降级，及其降级策略。
  * 业务放通场景，极其策略。

## 服务熔断

> 熔断这一概念来源于电子工程中的断路器（Circuit
> Breaker）。在互联网系统中，当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体的可用性，可以暂时切断对下游服务的调用。

### 相关概念

> 在学习服务熔断时，有必要区分下如下几个相关的概念。

  * 服务雪崩

多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C有调用其他的微服务，如果整个链路上某个微服务的调用响应式过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统雪崩，所谓的”雪崩效应”

  * 断路器

“断路器”本身是一种开关装置，当某个服务单元发生故障监控(类似熔断保险丝)，向调用方法返回一个符合预期的、可处理的备选响应(FallBack)，而不是长时间的等待或者抛出调用方法无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延。乃至雪崩。

  * 服务熔断

熔断机制是应对雪崩效应的一种微服务链路保护机制，当整个链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回”错误”的响应信息。

  * Hystrix

Hystrix是一个用于分布式系统的延迟和容错的开源库。在分布式系统里，许多依赖不可避免的调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整个服务失败，避免级联故障，以提高分布式系统的弹性。

### 熔断流程

> 上述概念中，我们知道熔断流程通常通过断路器（Curcuit Breaker）模式实现，那断路器模式的熔断流程是怎么样的呢？

#### 基本的断路器模式

基本的断路器（Curcuit Breaker）结构如下：

![img](https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/arch-x-reduce-3.png)

它有两个基本状态（close和open）和一个基本trip动作：

  * close状态下， client向supplier发起的服务请求， 直接无阻碍通过断路器， supplier的返回值接直接由断路器交回给client.
  * open状态下，client向supplier发起的服务请求后，断路器不会将请求转到supplier, 而是直接返回client, client和supplier之间的通路是断的
  * trip: 在close状态下，如果supplier持续超时报错， 达到规定的阀值后，断路器就发生trip, 之后断路器状态就会从close进入open.

#### 扩展的断路器模式

基本的断路器模式下，保证了断路器在open状态时，保护supplier不会被调用，
但我们还需要额外的措施可以在supplier恢复服务后，可以重置断路器。一种可行的办法是断路器定期探测supplier的服务是否恢复， 一但恢复，
就将状态设置成close。断路器进行重试时的状态为半开（half-open）状态。

![img](https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/arch-x-reduce-31.png)

### 服务熔断与服务降级比较

服务熔断对服务提供了proxy，防止服务不可能时，出现串联故障（cascading failure），导致雪崩效应。

**服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑** 。

  * 共性： 
    * 目的 -> 都是从可用性、可靠性出发，提高系统的容错能力。
    * 最终表现->使某一些应用不可达或不可用，来保证整体系统稳定。
    * 粒度 -> 一般都是服务级别，但也有细粒度的层面：如做到数据持久层、只许查询不许增删改等。
    * 自治 -> 对其自治性要求很高。都要求具有较高的自动处理机制。
  * 区别： 
    * 触发原因 -> 服务熔断通常是下级服务故障引起；服务降级通常为整体系统而考虑。
    * 管理目标 -> 熔断是每个微服务都需要的，是一个框架级的处理；而服务降级一般是关注业务，对业务进行考虑，抓住业务的层级，从而决定在哪一层上进行处理：比如在IO层，业务逻辑层，还是在外围进行处理。
    * 实现方式 -> 代码实现中的差异。

### 服务熔断中需考虑的设计

源自博主张善友的观点：

  * **异常处理** ：调用受熔断器保护的服务的时候，我们必须要处理当服务不可用时的异常情况。这些异常处理通常需要视具体的业务情况而定。比如，如果应用程序只是暂时的功能降级，可能需要切换到其它的可替换的服务上来执行相同的任务或者获取相同的数据，或者给用户报告错误然后提示他们稍后重试。

  * **异常的类型** ：请求失败的原因可能有很多种。一些原因可能会比其它原因更严重。比如，请求会失败可能是由于远程的服务崩溃，这可能需要花费数分钟来恢复；也可能是由于服务器暂时负载过重导致超时。熔断器应该能够检查错误的类型，从而根据具体的错误情况来调整策略。比如，可能需要很多次超时异常才可以断定需要切换到断开状态，而只需要几次错误提示就可以判断服务不可用而快速切换到断开状态。

  * **日志** ：熔断器应该能够记录所有失败的请求，以及一些可能会尝试成功的请求，使得的管理员能够监控使用熔断器保护的服务的执行情况。 测试服务是否可用：在断开状态下，熔断器可以采用定期的ping远程的服务或者资源，来判断是否服务是否恢复，而不是使用计时器来自动切换到半断开状态。这种ping操作可以模拟之前那些失败的请求，或者可以使用通过调用远程服务提供的检查服务是否可用的方法来判断。

  * **手动重置** ：在系统中对于失败操作的恢复时间是很难确定的，提供一个手动重置功能能够使得管理员可以手动的强制将熔断器切换到闭合状态。同样的，如果受熔断器保护的服务暂时不可用的话，管理员能够强制的将熔断器设置为断开状态。 并发问题：相同的熔断器有可能被大量并发请求同时访问。熔断器的实现不应该阻塞并发的请求或者增加每次请求调用的负担。 资源的差异性：使用单个熔断器时，一个资源如果​​有分布在多个地方就需要小心。比如，一个数据可能存储在多个磁盘分区上(shard)，某个分区可以正常访问，而另一个可能存在暂时性的问题。在这种情况下，不同的错误响应如果混为一谈，那么应用程序访问的这些存在问题的分区的失败的可能性就会高，而那些被认为是正常的分区，就有可能被阻塞。

  * **加快熔断器的熔断操作** :有时候，服务返回的错误信息足够让熔断器立即执行熔断操作并且保持一段时间。比如，如果从一个分布式资源返回的响应提示负载超重，那么应该等待几分钟后再重试。（HTTP协议定义了”HTTP 503 Service Unavailable”来表示请求的服务当前不可用，他可以包含其他信息比如，超时等）

  * **重复失败请求** ：当熔断器在断开状态的时候，熔断器可以记录每一次请求的细节，而不是仅仅返回失败信息，这样当远程服务恢复的时候，可以将这些失败的请求再重新请求一次。

### 服务熔断恢复需注意的问题

如果服务是幂等性的，则恢复重试不会有问题；而如果服务是非幂等性的，则重试会导致数据出现问题。

## 方案：Hystrix简介

> Spring Cloud Netflix
> Hystrix就是隔离措施的一种实现,可以设置在某种超时或者失败情形下断开依赖调用或者返回指定逻辑,从而提高分布式系统的稳定性.

### Hystrix设计原则

  * 防止单个服务的故障，耗尽整个系统服务的容器（比如tomcat）的线程资源，避免分布式环境里大量级联失败。通过第三方客户端访问（通常是通过网络）依赖服务出现失败、拒绝、超时或短路时执行回退逻辑

  * 用快速失败代替排队(每个依赖服务维护一个小的线程池或信号量，当线程池满或信号量满，会立即拒绝服务而不会排队等待)和优雅的服务降级；当依赖服务失效后又恢复正常，快速恢复

  * 提供接近实时的监控和警报，从而能够快速发现故障和修复。监控信息包括请求成功，失败（客户端抛出的异常），超时和线程拒绝。如果访问依赖服务的错误百分比超过阈值,断路器会跳闸，此时服务会在一段时间内停止对特定服务的所有请求

  * 将所有请求外部系统（或请求依赖服务）封装到HystrixCommand或HystrixObservableCommand对象中，然后这些请求在一个独立的线程中执行。使用隔离技术来限制任何一个依赖的失败对系统的影响。每个依赖服务维护一个小的线程池（或信号量），当线程池满或信号量满，会立即拒绝服务而不会排队等待

### Hystrix特性

  * 请求熔断： 当Hystrix Command请求后端服务失败数量超过一定比例(默认50%), 断路器会切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认5秒), 自动切换到半开路状态(HALF-OPEN).

这时会判断下一次请求的返回情况, 如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN).
Hystrix的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量,
并且断路器有自我检测并恢复的能力.

  * 服务降级：Fallback相当于是降级操作. 对于查询操作, 我们可以实现一个fallback方法, 当请求后端服务出现异常的时候, 可以使用fallback方法返回的值. fallback方法的返回值一般是设置的默认值或者来自缓存.告知后面的请求服务不可用了，不要再来了。

  * 依赖隔离(采用舱壁模式，Docker就是舱壁模式的一种)：在Hystrix中, 主要通过线程池来实现资源隔离. 通常在使用的时候我们会根据调用的远程服务划分出多个线程池.比如说，一个服务调用两外两个服务，你如果调用两个服务都用一个线程池，那么如果一个服务卡在哪里，资源没被释放

后面的请求又来了，导致后面的请求都卡在哪里等待，导致你依赖的A服务把你卡在哪里，耗尽了资源，也导致了你另外一个B服务也不可用了。这时如果依赖隔离，某一个服务调用A
B两个服务，如果这时我有100个线程可用，我给A服务分配50个，给B服务分配50个，这样就算A服务挂了，我的B服务依然可以用。

  * 请求缓存：比如一个请求过来请求我userId=1的数据，你后面的请求也过来请求同样的数据，这时我不会继续走原来的那条请求链路了，而是把第一次请求缓存过了，把第一次的请求结果返回给后面的请求。

  * 请求合并：我依赖于某一个服务，我要调用N次，比如说查数据库的时候，我发了N条请求发了N条SQL然后拿到一堆结果，这时候我们可以把多个请求合并成一个请求，发送一个查询多条数据的SQL的请求，这样我们只需查询一次数据库，提升了效率。

### Hystrix流程

Hystrix流程图如下：

![img](https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/arch-x-reduce-4.png)

Hystrix流程说明:

  * 1:每次调用创建一个新的HystrixCommand,把依赖调用封装在run()方法中.
  * 2:执行execute()/queue做同步或异步调用.
  * 4:判断熔断器(circuit-breaker)是否打开,如果打开跳到步骤8,进行降级策略,如果关闭进入步骤5.
  * 5:判断线程池/队列/信号量是否跑满，如果跑满进入降级步骤8,否则继续后续步骤6.
  * 6:调用HystrixCommand的run方法.运行依赖逻辑 
    * 6a:依赖逻辑调用超时,进入步骤8.
  * 7:判断逻辑是否调用成功 
    * 7a:返回成功调用结果
    * 7b:调用出错，进入步骤8.
  * 8:计算熔断器状态,所有的运行状态(成功, 失败, 拒绝,超时)上报给熔断器，用于统计从而判断熔断器状态.
  * 9:getFallback()降级逻辑. 
    * 以下四种情况将触发getFallback调用： 
      * (1):run()方法抛出非HystrixBadRequestException异常。
      * (2):run()方法调用超时
      * (3):熔断器开启拦截调用
      * (4):线程池/队列/信号量是否跑满
    * 9a:没有实现getFallback的Command将直接抛出异常
    * 9b:fallback降级逻辑调用成功直接返回
    * 9c:降级逻辑调用失败抛出异常
  * 10:返回执行成功结果

这里接着前面的Ribbon进行Hystrix集成。说白了你想对一个请求进行熔断，必然不能让客户直接去调用那个请求，你必然要要对别人的请求进行包装一层和拦截，才能做点手脚，比如进行熔断，所以说要在Ribbon上动手脚。因为它是请求发起的地方。
我们刚开始请求一个服务，为了负载均衡进行了拦截一次，现在我们要进行熔断，所以必须跟Ribbon集成一次，再进行请求拦截来熔断。

### Hystrix测试说明

![img](https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/arch-x-reduce-5.png)

## 方案：Sentinel简介

> Sentinel
> 是阿里中间件团队开源的，面向分布式服务架构的轻量级高可用流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来帮助用户保护服务的稳定性。

### Sentinel特征

  * 丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。
  * 完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。
  * 广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。
  * 完善的 SPI 扩展点：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。

Sentinel 的主要特性：

![img](https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/arch-x-reduce-6.png)

Sentinel 的开源生态：

![img](https://cdn.jsdelivr.net/gh/willpast/image/blog/ka_java/arch-x-reduce-7.png)

Sentinel 分为两个部分:

  * 核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。
  * 控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。

## 参考文章

- http://www.sohu.com/a/322823885_468627

- https://www.cnblogs.com/softidea/p/6346727.html

- https://blog.csdn.net/www1056481167/article/details/81157171

- https://blog.csdn.net/zhuyu19911016520/article/details/85346065

- https://www.cnblogs.com/chry/p/7278853.html

- [SpringCloud实战3-Hystrix请求熔断与服务降级在新窗口打开](https://www.cnblogs.com/huangjuncong/p/9026949.html)

- https://blog.csdn.net/www1056481167/article/details/81157171

- [高并发之服务降级与熔断在新窗口打开](https://suprisemf.github.io/2018/08/03/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8B%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E4%B8%8E%E7%86%94%E6%96%AD/)

- [谈谈我对服务熔断、服务降级的理解 专题在新窗口打开](https://www.cnblogs.com/softidea/p/6346727.html)


 