---
title: 树(Tree)
date: 2024-04-29 17:34:57
permalink: /pages/c052c6/
categories:
  - 数据结构
tags:
  - 
author: 
  name: Cyan
  link: https://github.com/willpast
---
## 【知识框架】

<img src="https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/ka-tree.png"  height="600px"> 

## 1 树
### 1.1 树的基本概念
#### 1.1.1 树的定义
**树**是由结点或顶点和边组成的(可能是非线性的)且不存在着任何环的一种数据结构。没有结点的树称为空(null或empty)树。一棵非空的树包括一个根结点，还(很可能)有多个附加结点，所有结点构成一个多级分层结构。

> A tree is a (possibly non-linear) data structure made up of nodes or vertices and edges without having any cycle. The tree with no nodes is called the null or empty tree. A tree that is not empty consists of a root node and potentially many levels of additional nodes that form a hierarchy.

注：本文将node一律译为"结点"(而不是"节点")，因为joint或connection是节点，而node是结点。关于"结点"与"节点"请自行搜索浙江大学陈水福教授的文章--"360度"解读如何正确应用"结点"与"节点"
#### 1.1.2 基本术语

**Root** | The top node in a tree. | **根** | 树的顶端结点  
:---|:---|:---|:---
**Child** | A node directly connected to another node when moving away from the Root. | **孩子** | 当远离根(Root)的时候，直接连接到另外一个结点的结点被称之为孩子(Child);   
**Parent** | The converse notion of a child. | **双亲** | 相应地，另外一个结点称为孩子(child)的双亲(parent)。  
**Siblings** | A group of nodes with the same parent. | **兄弟** | 具有同一个双亲(Parent)的孩子(Child)之间互称为兄弟(Sibling)。  
**Ancestor** | A node reachable by repeated proceeding from child to parent. | **祖先** | 结点的祖先(Ancestor)是从根（Root）到该结点所经分支(Branch)上的所有结点。  
**Descendant** | A node reachable by repeated proceeding from parent to child. | **子孙** | 反之，以某结点为根的子树中的任一结点都称为该结点的子孙(Ancestor)。  
**Leaf** | A node with no children. | **叶子（终端结点）** | 没有孩子的结点(也就是度为0的结点)称为叶子(Leaf)或终端结点。  
**Branch** | A node with at least one child. | **分支(非终端结点)** | 至少有一个孩子的结点称为分支(Branch)或非终端结点。  
**Degree** | The number of sub trees of a node. | **度** | 结点所拥有的子树个数称为结点的度(Degree)。  
**Edge** | The connection between one node and another. | **边** | 一个结点和另一个结点之间的连接被称之为边(Edge)。  
**Path** | A sequence of nodes and edges connecting a node with a descendant. | **路径** | 连接结点和其后代的结点之间的(结点,边)的序列。   
**Level** | The level of a node is defined by ０ + (the number of connections between the node and the root). | **层次** | 结点的层次(Level)从根(Root)开始定义起，根为第0层，根的孩子为第1层。以此类推，若某结点在第i层，那么其子树的根就在第i+1层。  
**Height of node** | The height of a node is the number of edges on the longest path between that node and a leaf. | **结点的高度** | 结点的高度是该结点和某个叶子之间存在的最长路径上的边的个数。   
**Height of tree** | The height of a tree is the height of its root node. | **树的高度** | 树的高度是其根结点的高度。
**Depth of node** | The depth of a node is the number of edges from the tree's root node to the node. | **结点的深度** | 结点的深度是从树的根结点到该结点的边的个数。（注：树的深度指的是树中结点的最大层次。）  
**Forest** | A forest is a set of n ≥ 0 disjoint trees. | **森林** | 森林是n(>=0)棵互不相交的树的集合。

[并查集](https://cloud.tencent.com/developer/article/1973225)：是合并和查询的集合

    合并：把两个不相交的集合合并为一个集合
    查询：查询两个元素是否在同一个集合中

    用一个元素代表集合,成为集合首领,判断是否在集合中,让元素存储首领来判断,合并需选出新的首领,将被合并的集合元素首领改成新的首领。

    另一种角度上说,并查集是将一个集合以树结构进行组合的数据结构

#### 1.1.3 树的性质
树具有如下最基本的性质：
* 树中的结点数等于所有结点的度数加1.
* 度为m的树中第i层上至多有m^{i-1}个结点（i>=1）
* 高度为h的m叉树至多有(m^h-1)/(m-1)个结点。
* 具有n个结点的m叉树的最小高度为[logm​^(n(m−1)+1)]。
### 1.2 树的分类

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-type.png)

根据一个结点最多有几个“叉”，即最多有几个子结点，我们可以对树进行分类。常用的是二叉树；超过“二叉”的树，一般统称为多叉树。

#### 1.2.1 无序树
树的任意结点的子结点没有顺序关系。
#### 1.2.1 有序树
树的任意结点的子结点有顺序关系。
#### 1.2.3 二叉树
二叉树(Binary Tree)是有序树，每个结点至多拥有两棵子树(即二叉树中不存在度大于2的结点)，并且，二叉树的子树有左右之分，其次序不能任意颠倒。
##### 1.2.3.1 斜树
所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。 
##### 1.2.3.2 完美二叉树
一个深度为k(>=-1)且有2^(k+1) - 1个结点的二叉树称为完美二叉树(PBT)。
> A Perfect Binary Tree(PBT) is a tree with all leaf nodes at the same depth.All internal nodes have degree 2.

注：国内的数据结构教材大多翻译为"满二叉树"。

<!-- ![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-bt-prefect.png) -->

##### 1.2.3.3 完满二叉树
所有非叶子结点的度都是2。只要你有孩子，你就必然是有两个孩子，这种二叉树叫做完满二叉树(FBT)。
> A Full Binary Tree(FBT) is a tree in which every node other than the leaves has two children.

注：Full Binary Tree又叫做Strictly Binary Tree。

<!-- ![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-bt-full.png) -->

##### 1.2.3.4 完全二叉树
叶子结点都在最底下两层，最后一层的叶子结点都靠左排列，并且除了最后一层，其他层的结点个数都要达到最大，这种二叉树叫做完全二叉树(CBT)。

> A Complete Binary Tree(CBT) is a binary tree in which every level, 
except possibly the last, is completely filled, and all nodes 
are as far left as possible.

完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。

<!-- ![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-bt-complete.png) -->

**完满(Full)二叉树 vs 完全(Complete)二叉树 vs 完美(Perfect)二叉树 总结**

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-bt-summary.png)

**完美二叉树** | Perfect Binary Tree |  Every node except the leaf nodes have two children and every level (last level too) is completely filled. **除了叶子结点之外的每一个结点都有两个孩子，每一层(当然包含最后一层)都被完全填充。**  
|:---|:---|:---|
**完全二叉树** | Complete Binary Tree | Every level except the last level is completely filled and all the nodes are left justified. **除了最后一层之外的其他每一层都被完全填充，并且所有结点都保持向左对齐。**  
**完满二叉树** | Full/Strictly Binary Tree | Every node except the leaf nodes have two children. **除了叶子结点之外的每一个结点都有两个孩子结点。**  
  
  * 完美(Perfect)二叉树一定是完全(Complete)二叉树，但完全(Complete)二叉树不一定是完美(Perfect)二叉树。
  * 完美(Perfect)二叉树一定是完满(Full)二叉树，但完满(Full)二叉树不一定是完美(Perfect)二叉树。
  * 完全(Complete)二叉树可能是完满(Full)二叉树，完满(Full)二叉树也可能是完全(Complete)二叉树。
  * 既是完全(Complete)二叉树又是完满(Full)二叉树也不一定就是完美(Perfect)二叉树。

##### 1.2.3.5 堆
堆(Heap)是一个完全二叉树，堆中每个结点的值都大于等于（或者小于等于）其左右子结点的值。将根结点最大的堆叫做最大堆或大根堆，根结点最小的堆叫做最小堆或小根堆。
* 最大堆的任何一个父结点的值，都大于或等于它左、右孩子结点的值。
* 最小堆的任何一个父结点的值，都小于或等于它左、右孩子结点的值。
##### 1.2.3.6 线索二叉树
在二叉树的结点上加上线索的二叉树称为线索二叉树(Threaded Binary Tree)，对二叉树以某种遍历方式（如先序、中序、后序）进行遍历，使其变为线索二叉树的过程称为对二叉树进行线索化。
##### 1.2.3.7 二叉查找树
二叉查找树(Binary Search Tree)的定义：二叉树中的任意一个结点，其左子树中的每个结点的值，都要小于这个结点的值，而右子树结点的值都大于这个结点的值。

注：二叉搜索树、二叉排序树、BST都是别名。
##### 1.2.3.18 平衡二叉树
平衡二叉树(Balancing Binary Tree)也叫自平衡二叉查找树（Self-Balancing Binary Search Tree），所以其本质也是一颗二叉查找树，不过为了限制左右子树的高度差，避免出现倾斜树等偏向于线性结构演化的情况，所以对二叉查找树中每个结点的左右子树作了限制，左右子树的高度差称之为平衡因子，树中每个结点的平衡因子绝对值不大于 1，此时二叉查找树称之为平衡二叉树。

经典常见的平衡二叉查找树是 AVL 树和红黑树。
##### 1.2.3.10 AVL树
AVL树是最先发明的自平衡二叉查找树。在AVL树中任何结点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。
##### 1.2.3.11 红黑树
红黑树(Red Black Tree)是一种含有红黑结点并能自平衡的二叉查找树。红黑树多用于搜索,插入,删除操作多的情况。
##### 1.2.3.12 伸展树
伸展树(Splay Tree)，也叫分裂树，是一种自平衡二叉查找树，它由丹尼尔·斯立特Daniel Sleator 和 罗伯特·恩卓·塔扬Robert Endre Tarjan 在1985年发明的。它会沿着从某个结点到树根之间的路径，通过一系列的旋转把这个结点搬移到树根去。

它的优势在于不需要记录用于平衡树的冗余信息，它能在O(log n)内完成插入、查找和删除操作。
##### 1.2.3.13 替罪羊树
替罪羊树(Scapegoat Tree)是一棵自平衡二叉查找树，由Arne Andersson提出。替罪羊树的主要思想就是将不平衡的树压成一个序列,然后暴力重构成一颗平衡的树。在替罪羊树上，插入或删除结点的平摊最坏时间复杂度是O(log n)，搜索结点的最坏时间复杂度是O(log n)。

#### 1.2.4 多叉树
在二叉树中，每个结点有数据项，最多有两个子结点。如果允许每个结点可以有更多的数据项和更多的子结点， 就是多叉树（multiway tree）。
##### 1.2.4.1 多路查找树
多路查找树（muiti-way search tree），其每一个结点的孩子树可以多于两个，且每一个结点处可以存储多个元素。
##### 1.2.4.2 B树 
B树(Balanced Tree)是一种自平衡的树,它是一种多路查找树（并不是二叉的），能够保证数据有序。B树通过重新组织结点，降低树的高度，并且减少 i/o 读写次数来提升效率。

注：B-树，B_树是其别名。
##### 1.2.4.3 B+树
B+树是B树的一种变形形式，B+树上的叶子结点存储关键字以及相应记录的地址，叶子结点以上各层作为索引使用。通常用于数据库和操作系统的文件系统中。
##### 1.2.4.4 B*树
B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针，将结点的最低利用率从1/2提高到2/3。

B*树分配新结点的概率比B+树要低，空间使用率更高。
##### 1.2.4.5 Tire树
Trie树称为字典树，又称单词查找树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。
### 1.3 树的存储结构
在介绍以下三种存储结构的过程中，我们都以下面这个树为例子。  
![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-struct.png)

#### 1.3.1 双亲表示法
我们假设以一组连续空间存储树的结点，同时**在每个结点中，附设一个指示器指示其双亲结点到链表中的位置**
。也就是说，每个结点除了知道自已是谁以外，还知道它的双亲在哪里。  
|data|parent|
|--|--|

其中data是数据域，存储结点的数据信息。而parent是指针域，存储该结点的双亲在数组中的下标。  

以下是我们的双亲表示法的结点结构定义代码。
```c
/*树的双亲表示法结点结构定义*/
#define MAX_TREE_SIZE 100
typedef int TElemType;  //树结点的数据类型，目前暂定为整型
/*结点结构*/
typedef struct PTNode{
    TElemType data; //结点数据
    int parent; //双亲位置
}PTNode;
/*树结构*/
typedef struct{
    PTNode nodes[MAX_TREE_SIZE];    //结点数组
    int r, n;   //根的位置和结点数
}PTree;

```  
这样的存储结构，我们可以根据结点的parent指针很容易找到它的双亲结点，所用的时间复杂度为0(1)，直到parent为-1时，表示找到了树结点的根。

可如果我们要知道结点的孩子是什么，对不起，请遍历整个结构才行。

#### 1.3.2 孩子表示法
具体办法是，**把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成-
一个线性表，采用顺序存储结构，存放进一个一维数组中** ，如下所示。  
![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-child.png)  

为此，设计两种结点结构，一个是孩子链表的孩子结点。  
|chlid|next|
|--|--|

其中child是数据域，用来存储某个结点在表头数组中的下标。next 是指针域，用来存储指向某结点的下一个孩子结点的指针。

另一个是表头数组的表头结点。  
|data|firstchild|
|--|--|

其中data是数据域，存储某结点的数据信息。firstchild 是头指针域，存储该结点的孩子链表的头指针。

以下是我们的孩子表示法的结构定义代码。
```c
/*树的孩子表示法结构定义*/
#define MAX_TREE_SIZE 100
/*孩子结点*/
typedef struct CTNode{
    int child;
    struct CTNode *next;
}*ChildPtr;
/*表头结点*/
typedef struct{
    TElemType data;
    ChildPtr firstchild;
}CTBox;
/*树结构*/
typedef struct{
    CTBox nodes[MAX_TREE_SIZE]; //结点数组
    int r, n;   //根的位置和结点数
}

```
这样的结构对于我们要查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可。对于遍历整棵树也是很方便的，对头结点的数组循环即可。  
但是，这也存在着问题，我如何知道某个结点的双亲是谁呢?比较麻烦，需要整棵树遍历才行，难道就不可以把双亲表示法和孩子表示法综合一下吗?
当然是可以，这个读者可自己尝试结合一下，在次不做赘述。
#### 1.3.3 孩子兄弟表示法
刚才我们分别从双亲的角度和从孩子的角度研究树的存储结构，如果我们从树结点的兄弟的角度又会如何呢?当然，对于树这样的层级结构来说，只研究结点的兄弟是不行的，我们观察后发现，**任意一棵树，
它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。 因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟** 。  
结点的结构如下：  
|data|firstchild|rightsib|
|--|--|--|

其中data是数据域，firstchild 为指针域，存储该结点的第一个孩子结点的存储地址，rightsib 是指针域，存储该结点的右兄弟结点的存储地址。  

这种表示法，给查找某个结点的某个孩子带来了方便。  

结构定义代码如下。
```c
/*树的孩子兄弟表示法结构定义*/
typedef struct CSNode{
    TElemtype data;
    struct CSNode *firstchild, *rightsib;
} CSNode, *CSTree;

```
于是通过这种结构，我们就把原来的树变成了这个样子：  
<img src="https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-struct1.png" width="400px" height="400px"> 

这不就是个二叉树么？  

没错，其实这个表示法的最大好处就是它把一棵复杂的树变成了一棵**二叉树** 。  

接下来，我们详细介绍二叉树。
## 2 二叉树
### 2.1二叉树的概念
#### 2.1.1 二叉树的定义
二叉树是另一种树形结构，其特点是每个结点至多只有两棵子树( 即二叉树中不存在度大于2的结点)，并且二叉树的子树有左右之分，其次序不能任意颠倒。  
与树相似，二叉树也以递归的形式定义。二叉树是n (n≥0) 个结点的有限集合:
* 或者为空二叉树，即n=0。
* 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。

二叉树是有序树，若将其左、右子树颠倒，则成为另一棵不同的二叉树。即使树中结点只有一棵子树，也要区分它是左子树还是右子树。二叉树的5种基本形态如图所示。  

<img src="https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-binary.png" width="500px" height="300px">

#### 2.1.2 二叉树的性质
* 任意一棵树，若结点数量为n,则边的数量为n−1。
* 非空二叉树上的叶子结点数等于度为2的结点数加1，即no​=n2 ​+ 1。
* 非空二叉树上第k层上至多有2^k−1个结点(k≥1)。
* 高度为h的二叉树至多有2^h-1个结点(h≥1)。
* 对完全二叉树按从上到下、从左到右的顺序依次编号1,2..∗,n,则有以下关系: 
     * i>1时，结点i的双亲的编号为i/2,即当i为偶数时， 它是双亲的左孩子;当i为奇数时，它是双亲的右孩子。
     * 当2i≤n时，结点i的左孩子编号为2i, 否则无左孩子。
     * 当2i+1≤n时，结点i的右孩子编号为2i+1，否则无右孩子。
     * 结点i所在层次(深度)为 {log2^​i}+1。
* 具有n个(n>0)结点的完全二叉树的高度为{log2^​n}+1。
#### 2.1.3 二叉树的存储结构
##### 2.1.3.1 顺序存储结构
二叉树的顺序存储是指用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素，即将完全二叉树上编号为i的结点元素存储在一维数组下标为i−1的分量中。
依据二叉树的性质，完全二叉树和满二叉树采用顺序存储比较合适，树中结点的序号可以唯一地反映结点之间的逻辑关系，这样既能最大可能地节省存储空间，又能利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系。  
但对于一般的二叉树，为了让数组下标能反映二叉树中结点之间的逻辑关系，只能添加一些并不存在的空结点，让其每个结点与完全二叉树上的结点相对照，再存储到一维数组的相应分量中。然而，在最坏情况下，一个高度为h且只有h个结点的单支树却需要占据近2h−1个存储单元。二叉树的顺序存储结构如图所示，其中0表示并不存在的空结点。  

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-struct-sq.png)
##### 2.1.3.2 链式存储结构
既然顺序存储适用性不强，我们就要考虑链式存储结构。**二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表**。

|lchild|data|rchild|
|--|--|--| 

其中data是数据域，lchild 和rchild都是指针域，分别存放指向左孩子和右孩子的指针。  

以下是我们的二叉链表的结点结构定义代码。
```c
/*二叉树的二叉链表结点构造定义*/
/*结点结构*/
typedef struct BiTNode{
    TElemType data; //结点数据
    struct BiTNode *lchild, *rchild;    //左右孩子指针
} BiTNode, *BiTree;

```
![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-struct-link.png)  

容易验证，**在含有n个结点的二叉链表中，含有n+1个空链域**。
### 2.2 遍历二叉树
二叉树的遍历(Traversing Binary Tree)是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。
#### 2.2.1 先序遍历(递归算法)
先序遍历(PreOrder) 的操作过程如下：  
>  若二叉树为空，则什么也不做，否则，  
>  1)访问根结点;  
>  2)先序遍历左子树;  
>  3)先序遍历右子树。

<img src="https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-travers-pre.png" width="300px" height="300px">

对应的递归算法如下:
```c
void PreOrder(BiTree T){
    if(T != NULL){
        visit(T);   //访问根结点
        PreOrder(T->lchild);    //递归遍历左子树
        PreOrder(T->rchild);    //递归遍历右子树
    }
}

```
先序遍历的顺序为：ABDGHCEIF
#### 2.2.2 中序遍历(递归算法)
中序遍历( InOrder)的操作过程如下：  
>  若二叉树为空，则什么也不做，否则，  
>  1)中序遍历左子树;  
>  2)访问根结点;  
>  3)中序遍历右子树。

<img src="https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-travers-in.png" width="300px" height="300px">

对应的递归算法如下:
```c
void InOrder(BiTree T){
    if(T != NULL){
        InOrder(T->lchild); //递归遍历左子树
        visit(T);   //访问根结点
        InOrder(T->rchild); //递归遍历右子树
    }
}

```
中序遍历的顺序为：GDHBAEICF
#### 2.2.3 后序遍历(递归算法)
后序遍历(PostOrder) 的操作过程如下：  
>  若二叉树为空，则什么也不做，否则，  
>  1)后序遍历左子树;  
>  2)后序遍历右子树;  
>  3)访问根结点。

<img src="https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-travers-post.png" width="300px" height="300px">

对应的递归算法如下:
```c
void PostOrder(BiTree T){
    if(T != NULL){
        PostOrder(T->lchild);   //递归遍历左子树
        PostOrder(T->rchild);   //递归遍历右子树
        visit(T);   //访问根结点
    }
}

```
后序遍历的顺序为：GHDBIECFA

三种遍历算法中,递归遍历左、右子树的顺序都是固定的，只是访问根结点的顺序不同。不管采用哪种遍历算法，每个结点都访问一次且仅访问一次，故时间复杂度都是O(n)。在递归遍历中，递归工作栈的栈深恰好为树的深度，所以在最坏情况下，二叉树是有n个结点且深度为n的单支树，遍历算法的空间复杂度为O(n)。
#### 2.2.4 遍历的非递归算法
我们以下图的树为例子。  
![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-binary-travers.png)

##### 2.2.4.1 中序遍历(非递归算法)
借助栈，我们来分析中序遍历的访问过程:
* 沿着根的左孩子，依次入栈，直到左孩子为空，说明已找到可以输出的结点，此时栈内元素依次为ABD。
* 栈顶元素出栈并访问:若其右孩子为空，继续执行步骤2;若其右孩子不空,将右子树转执行步骤1。

栈顶D出栈并访问，它是中序序列的第一个结点; D右孩子为空，栈顶B出栈并访问; B右孩子不空，将其右孩子E入栈，E左孩子为空，栈顶E出栈并访问;
E右孩子为空，栈顶A出栈并访问; A右孩子不空，将其右孩子C入栈，C左孩子为空，栈顶C出栈并访问。由此得到中序序列DBEAC。  
根据分析可以写出中序遍历的非递归算法如下:
```c
void InOrder2(BiTree T){
    InitStack(S);   //初始化栈S
    BiTree p = T;   //p是遍历指针
    while(p || !IsEmpty(S)){    //栈不空或p不空时循环
        if(p){
            Push(S, p); //当前结点入栈
            p = p->lchild;  //左孩子不空，一直向左走
        }else{
            Pop(S, p);  //栈顶元素出栈
            visit(p);   //访问出栈结点
            p = p->rchild;  //向右子树走，p赋值为当前结点的右孩子
        }
    }
}

``` 
##### 2.2.4.2 先序遍历(非递归算法)
先序遍历和中序遍历的基本思想是类似的，只需把访问结点操作放在入栈操作的前面。先序遍历的非递归算法如下:
```c
void PreOrder2(BiTree T){
    InitStack(S);   //初始化栈S
    BiTree p = T;   //p是遍历指针
    while(p || !IsEmpty(S)){    //栈不空或p不空时循环
        if(p){
            visit(p);   //访问出栈结点
            Push(S, p); //当前结点入栈
            p = p->lchild;  //左孩子不空，一直向左走
        }else{
            Pop(S, p);  //栈顶元素出栈
            p = p->rchild;  //向右子树走，p赋值为当前结点的右孩子
        }
    }
}

```  
##### 2.2.4.3 后序遍历(非递归算法)
后序遍历的非递归实现是三种遍历方法中最难的。因为在后序遍历中，要保证左孩了和右孩子都已被访问并且左孩子在右孩子前访问才能访问根结点，这就为流程的控制带来了难题。

算法思想:后序非递归遍历二叉树是先访问左子树，再访问右子树，最后访问根结点。
* 沿着根的左孩子，依次入栈，直到左孩子为空。此时栈内元素依次为ABD。
* 读栈顶元素:若其右孩子不空且未被访问过，将右子树转执行①;否则，栈顶元素出栈并访问。

栈顶D的右孩子为空，出栈并访问，它是后序序列的第一个结点;栈顶B的右孩子不空且未被访问过，E入栈，栈顶E的左右孩子均为空，出栈并访问;栈顶B的右孩子不空但已被访问，B出栈并访问;栈项A的右孩子不空且未被访问过，C入栈,栈项C的左右孩子均为空，出栈并访问;栈顶A的右孩子不空但已被访问，A出栈并访问。由此得到后序序列DEBCA。  
在上述思想的第②步中，必须分清返回时是从左子树返回的还是从右子树返回的，因此设定一个辅助指针r,指向最近访问过的结点。也可在结点中增加一个标志域，记录是否已被访问。

后序遍历的非递归算法如下:
```c
void PostOrder2(BiTree T){
    InitStack(S);
    p = T;
    r = NULL;
    while(p || !IsEmpty(S)){
        if(p){  //走到最左边
            push(S, p);
            p = p->lchild;
        }else{  //向右
            GetTop(S, p);   //读栈顶元素（非出栈）
            //若右子树存在，且未被访问过
            if(p->rchild && p->rchild != r){
                p = p->rchild;  //转向右
                push(S, p); //压入栈
                p = p->lchild;  //再走到最左
            }else{  //否则，弹出结点并访问
                pop(S, p);  //将结点弹出
                visit(p->data); //访问该结点
                r = p;  //记录最近访问过的结点
                p = NULL;
            }
        }
    }
}

```  
#### 2.2.5 层次遍历
下图为二叉树的层次遍历，即按照箭头所指方向，按照1,2,3, 4的层次顺序，对二叉树中的各个结点进行访问。  
![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-travers-level.png)

要进行层次遍历，需要借助一个队列。先将二叉树根结点入队，然后出队，访问出队结点，若它有左子树，则将左子树根结点入队;若它有右子树，则将右子树根结点入队。然后出队，访问出队结…如此反复，直至队列为空。  
二叉树的层次遍历算法如下:
```c
void LevelOrder(BiTree T){
    InitQueue(Q);   //初始化辅助队列
    BiTree p;
    EnQueue(Q, T);  //将根结点入队
    while(!IsEmpty(Q)){ //队列不空则循环
        DeQueue(Q, p);  //队头结点出队
        visit(p);   //访问出队结点
        if(p->lchild != NULL){
            EnQueue(Q, p->lchild);  //左子树不空，则左子树根结点入队
        }
        if(p->rchild != NULL){
            EnQueue(Q, p->rchild);  //右子树不空，则右子树根结点入队
        }
    }
}

``` 
#### 2.2.6 由遍历序列构造二叉树
**由二叉树的先序序列和中序序列可以唯一地确定一棵二叉树。**  
在先序遍历序列中,第一个结点一定是二叉树的根结点;而在中序遍历中,根结点必然将中序序列分割成两个子序列,前一个子序列是根结点的左子树的中序序列,后一个子序列是根结点的右子树的中序序列。根据这两个子序列,在先序序列中找到对应的左子序列和右子序列。在先序序列中,左子序列的第一个结点是左子树的根结点,右子序列的第一个结点是右子树的根结点。  
如此递归地进行下去,便能唯一地确定这棵二叉树  
同理,**由二叉树的后序序列和中序序列也可以唯一地确定一棵二叉树。**  
因为后序序列的最后一个结点就如同先序序列的第一个结点,可以将中序序列分割成两个子序列,然后采用类似的方法递归地进行划分,进而得到一棵二叉树。  
**由二叉树的层序序列和中序序列也可以唯一地确定一棵二叉树。**  
要注意的是,若只知道二叉树的先序序列和后序序列,则无法唯一确定一棵二叉树。  
例如,求先序序列( ABCDEFGH)和中序序列( BCAEDGHFI）所确定的二叉树  
首先,由先序序列可知A为二叉树的根结点。中序序列中A之前的BC为左子树的中序序列,EDGHFI为右子树的中序序列。然后由先序序列可知B是左子树的根结点,D是右子树的根结点。以此类推,就能将剩下的结点继续分解下去,最后得到的二叉树如图(c)所示。  
![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-travers-seq.png)
### 2.3 线索二叉树
#### 2.3.1 线索二叉树原理
遍历二叉树是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到几种遍历序列，使得该序列中的每个结点(第一个和最后一个结点除外)都有一个直接前驱和直接后继。  
传统的二叉链表存储仅能体现一种父子关系，不能直接得到结点在遍历中的前驱或后继。  

<img src="https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-binary-xs1.png" width="500px" height="200px">

首先我们要来看看这空指针有多少个呢?对于一个有n个结点的二叉链表，每个结点有指向左右孩子的两个指针域，所以一共是2n个指针域。而n个结点的二叉树一共有n-1条分支线数，也就是说，其实是存在2n- (n-1) =n+1个空指针域。

由此设想能否利用这些空指针来存放指向其前驱或后继的指针?这样就可以像遍历单链表那样方便地遍历二叉树。引入线索二叉树正是为了加快查找结点前驱和后继的速度。  
**我们把这种指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树(Threaded Binary Tree)。**

其结点结构如下所示：  
|lchild|ltag|data|rtag|rchild|
|-|-|-|-|-|

其中 
* ltag为0时指向该结点的左孩子，为1时指向该结点的前驱。
* rtag为0时指向该结点的右孩子，为1时指向该结点的后继。

因此对于上图的二叉链表图可以修改为下图的样子。  

<img src="https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-binary-xs2.png" width="500px" height="200px">

#### 2.3.2 线索二叉树的结构实现
二叉树的线索存储结构代码如下：
```c
typedef struct ThreadNode{
    ElemType data;  //数据元素
    struct ThreadNode *lchild, *rchild; //左、右孩子指针
    int ltag, rtag; //左、右线索标志
}ThreadNode, *ThreadTree;

``` 
#### 2.3.3 二叉树的线索化
二叉树的线索化是将二叉链表中的空指针改为指向前驱或后继的线索。而前驱或后继的信息只有在遍历时才能得到，**因此线索化的实质就是遍历一次二叉树，线索化的过程就是在遍历的过程中修改空指针的过程。**

##### 2.3.3.1 中序线索化
以中序线索二叉树的建立为例。附设指针pre指向刚刚访问过的结点，指针p指向正在访问的结点，即pre指向p的前驱。在中序遍历的过程中，检查p的左指针是否为空，若为空就将它指向pre;检查pre的右指针是否为空，若为空就将它指向p，如下图所示。 

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-binary-xs3.png)  

通过中序遍历对二叉树线索化的递归算法如下:
```c
void InThread(ThreadTree p, ThreadTree pre){
    if(p != NULL){
        InThread(p->lchild, pre);   //递归，线索化左子树
        if(p->lchild == NULL){  //左子树为空，建立前驱线索
            p->lchild = pre;
            p->ltag = 1;
        }
        if(pre != NULL && pre->rchild == NULL){
            pre->rchild = p;    //建立前驱结点的后继线索
            pre->rtag = 1;
        }
        pre = p;    //标记当前结点成为刚刚访问过的结点
        InThread(p->rchild, pre);   //递归，线索化右子树
    }
}

``` 
你会发现，除了中间的代码，和二叉树中序遍历的递归代码几乎完全一样。只不过将本是访问结点的功能改成了线索化的功能。

通过中序遍历建立中序线索二叉树的主过程算法如下:
```c
void CreateInThread(ThreadTree T){
    ThreadTree pre = NULL;
    if(T != NULL){
        InThread(T, pre);   //线索化二叉树
        pre->rchild = NULL; //处理遍历的最后一个结点
        pre->rtag = 1;
    }
}
```
为了方便,可以在二叉树的线索链表上也添加一个头结点，令其lchild域的指针指向二叉树的根结点，其rchild域的指针指向中序遍历时访问的最后一个结点;令二叉树中序序列中的第一个结点的lchild域指针和最后一个结点的rchild域指针均指向头结点。这好比为二叉树建立了一个双向线索链表，方便从前往后或从后往前对线索二叉树进行遍历。
遍历的代码如下：
```c
/*T指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍
的最后一个结点。中序遍历二叉线索链表表示的二叉树T*/
void InOrderTraverse_Thr(BiThrTree T){
    BiThrTree p;
    p = T->lchild;  //p指向根结点
    //空树或遍历结束时，p==T（最后一个结点指向根结点）
    while(p != T){  
        //当ltag==0时循环到中序序列第一个结点
        while(p->ltag == 0){    
            p = p->lchild;  //p指向p的左子树
        }
        visit(p);   //访问该结点
        //后继线索为1且不是指向头指针
        while(p->rtag == 1 && p->rchild != T){  
            p = p->rchild;  //p指向p的后继
            visit(p);   //访问该结点
        }
        //p进至其右子树根，开始对右子树根进行遍历
        p = p->rchild;  
    }
}

``` 
从这段代码也可以看出，它等于是一个链表的扫描,所以时间复杂度为0(n)。  
由于它充分利用了空指针域的空间(这等于节省了空间)，又保证了创建时的一次遍历就可以终生受用前驱后继的信息(这意味着节省了时间)。所以在实际问题中，如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。

##### 2.3.3.2 先序和后序线索化
上面给出了建立中序线索二叉树的代码，建立先序线索二叉树和后序线索二叉树的代码类似，只需变动线索化改造的代码段与调用线索化左右子树递归函数的位置。  
以图(a)的二叉树为例，其先序序列为ABCDF，后序序列为CDBFA，可得出其先序和后序线索二叉树分别如图(b)和(c)所示：  

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-binary-xs4.png)  

如何在先序线索二叉树中找结点的后继?如果有左孩子，则左孩子就是其后继;如果无左孩子但有右孩子，则右孩子就是其后继;如果为叶结点，则右链域直接指示了结点的后继。  
在后序线索二叉树中找结点的后继较为复杂，可分3种情况:①若结点x是二叉树的根，则其后继为空;②若结点x是其双亲的右孩子，或是其双亲的左孩子且其双亲没有右子树，则其后继即为双亲;③若结点x是其双亲的左孩子，且其双亲有右子树，则其后继为双亲的右子树上按后序遍历列出的第一个结点。图(
c)中找结点B的后继无法通过链域找到，可见在后序线索二叉树上找后继时需知道结点双亲，即需采用带标志域的三叉链表作为存储结构。

### 2.4 二叉查找树
#### 2.4.1 二叉查找树的定义
二叉查找树（Binary Search Tree），又称二叉查找树，亦称二叉排序树（Binary Sort Tree），是具有下列特性的二叉树:
* 若左子树非空，则左子树上所有结点的值均小于根结点的值。
* 若右子树非空，则右子树上所有结点的值均大于根结点的值。
* 左、右子树也分别是一棵二叉查找树。

根据二叉查找树的定义，左子树结点值<根结点值<右子树结点值，所以对二叉查找树进行中序遍历，可以得到一个递增的有序序列。例如，下图所示二叉查找树的中序遍历序列为123468。  

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-bst.png)

构造一个二叉树的结构：
```c
/*二叉树的二叉链表结点结构定义*/
typedef struct BiTNode
{
    int data;   //结点数据
    struct BiTNode *lchild, *rchild;    //左右孩子指针
} BiTNode, *BiTree;

```
#### 2.4.2 二叉查找树的查找
```c
/*
递归查找二叉查找树T中是否存在key
指针f指向T的双亲，其初始调用值为NULL
若查找成功，则指针p指向该数据元素结点，并返回TRUE
否则指针p指向查找路径上访问的最后一个结点并返回FALSE
*/
bool SearchBST(BiTree T, int key, BiTree f, BiTree *p){
    if(!T){
        *p = f;
        return FALSE;
    }else if(key == T->data){
        //查找成功
        *p = T;
        return TRUE;
    }else if(key < T->data){
        return SearchBST(T->lchild, key, T, p); //在左子树继续查找
    }else{
        return SearchBST(T->rchild, key, T, p); //在右子树继续查找
    }
}

```
#### 2.4.3 二叉查找树的插入
有了二叉查找树的查找函数，那么所谓的二叉查找树的插入，其实也就是将关键字放到树中的合适位置而已。
```c
/*
当二叉查找树T中不存在关键字等于key的数据元素时
插入key并返回TRUE，否则返回FALSE
*/
bool InsertBST(BiTree *T, int key){
    BiTree p, s;
    if(!SearchBST(*T, key, NULL, &p)){
        //查找不成功
        s = (BiTree)malloc(sizeof(BiTNode));
        s->data = key;
        s->lchild = s->rchild = NULL;
        if(!p){
            *T = s; //插入s为新的根结点
        }else if(key < p->data){
            p->lchild = s;  //插入s为左孩子
        }else{
            p->rchild = s;  //插入s为右孩子
        }
        return TRUE;
        }else{
            return FALSE;   //树种已有关键字相同的结点，不再插入
        }
}

```
有了二叉查找树的插入代码，我们要实现二叉查找树的构建就非常容易了，几个例子：
```c
int i;
int a[10] = {62, 88, 58, 47, 35, 73, 51, 99, 37, 93};
BiTree T = NULL;
for(i = 0; i<10; i++){
    InsertBST(&T, a[i]);
}

```
上面的代码就可以创建一棵下图这样的树。

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-bst-insert.png)

#### 2.4.4 二叉查找树的删除
二叉查找树的查找和插入都很简单，但是删除操作就要复杂一些，此时要删除的结点有三种情况：
* 叶子结点；
* 仅有左或右子树的结点；
* 左右子树都有的结点；

前两种情况都很简单，第一种只需删除该结点不需要做其他操作；第二种删除后需让被删除结点的直接后继接替它的位置；**复杂就复杂在第三种，此时我们需要遍历得到被删除结点的直接前驱或者直接后继来接替它的位置，然后再删除**
。  
第三种情况如下图所示：  

<img src="https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-bst-delete.png" width="500px" height="500px">

代码如下：
```c
/*
若二叉查找树T中存在关键字等于key的数据元素时，则删除该数据元素结点，
并返回TRUE;否则返回FALSE
*/
bool DeleteBST(BiTree *T, int key){
    if(!*T){
        return FALSE; 
    }else{
        if(key == (*T)->data){
            //找到关键字等于key的数据元素
            return Delete(T);
        }else if(key < (*T) -> data){
            return DeleteBST((*T) -> lchild, key);
        }else{
            return DeleteBST((*T) -> rchild, key);
        }
    }
}

/*从二叉查找树中删除结点p，并重接它的左或右子树。*/
bool Delete(BiTree *p){
    BiTree q, s;
    if(p->rchild == NULL){
        //右子树为空则只需重接它的左子树
        q = *p;
        *p = (*p)->lchild;
        free(q);
    }else if((*p)->lchild == NULL){
        //左子树为空则只需重接它的右子树
        q = *p;
        *p = (*p)->rchild;
        free(q);
    }else{
        //左右子树均不空
        q = *p;
        s = (*p)->lchild;   //先转左
        while(s->rchild){//然后向右到尽头，找待删结点的前驱
            q = s;
            s = s->rchild;
        }
        //此时s指向被删结点的直接前驱，p指向s的父母结点
        p->data = s->data;  //被删除结点的值替换成它的直接前驱的值
        if(q != *p){
            q->rchild = s->lchild;  //重接q的右子树
        }else{
            q->lchild = s->lchild;  //重接q的左子树
        }
        pree(s);
    }
    return TRUE;
}

```
#### 2.4.5 小结(引出平衡二叉树)
二叉查找树的优点明显，插入删除的时间性能比较好。而对于二叉查找树的查找，走的就是从根结点到要查找的结点的路径，其比较次数等于给定值的结点在二叉查找树的层数。极端情况，最少为1次，即根结点就是要找的结点，最多也不会超过树的深度。也就是说，**二叉查找树的查找性能取决于二叉查找树的形状**。可问题就在于，二叉查找树的形状是不确定的。  
例如 {62,88,58,47,35,73,51,99,37,93}这样的数组，我们可以构建如下左图的二叉查找树。但如果数组元素的次序是从小到大有序，如{35,37,47,51,58,62,73,88,93,99},则二叉查找树就成了极端的右斜树，如下面右图的二叉查找树：  

<img src="https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-bst1.png" width="500px" height="200px">

也就是说，我们希望二叉查找树是比较平衡的，即其深度与完全二叉树相同，那么查找的时间复杂也就为O(logn)，近似于折半查找。不平衡的最坏情况就是像上面右图的斜树，查找时间复杂度为O(n)，这等同于顺序查找。

因此，如果我们希望对一个集合按二叉查找树查找，最好是把它构建成一棵**平衡的二叉查找树** 。二叉树越平衡，查找性能越好。
### 2.5 平衡二叉树
#### 2.5.1 平衡二叉树的定义
**平衡二叉树**全称叫做平衡二叉查找树(Self-Balancing Binary Search Tree 或 Height-Balanced Binary Search Tree)是一种二叉查找树， 英文：Balanced Binary Tree(BBT)，简称 AVL树。
> AVL 是两位俄罗斯数学家 G.M. Adelson-Velsky 和 E.M. Landis 名称的缩写，他们在1962年共同发明一种解决平衡二叉树的算法，为了纪念他们，将 平衡二叉树 称为AVL树。
> AVL树本质上是一颗二叉查找树，但是它又具有以下特点：
> * 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，
> * 左右两个子树 也都是一棵平衡二叉树。

我们**将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF(Balance Factor)** ，那么平衡二叉树上所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。 

自平衡是指，在对平衡二叉树执行插入或删除结点操作后，可能会导致树中某个结点的平衡因子绝对值超过 ，即平衡二叉树变得“不平衡”，为了恢复该结点左右子树的平衡，此时需要对结点执行旋转操作。

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-bbst.png)

可以看到 AVL 树具有以下特点：
* 每个结点的平衡因子只可能是 -1、0、1（如果绝对值超过 1，则认为是失衡）
* 每个结点的左右子树高度差不超过 1
* 搜索、插入、删除的时间复杂度是 O(logn)

#### 2.5.2 平衡二叉树的查找
在平衡二叉树上进行查找的过程与二叉查找树的相同。因此，在查找过程中，与给定值进行比较的关键字个数不超过树的深度。假设以Nh表示深度为h的平衡树中含有的最少结点数。显然，有N0=0，N1=1，N2=2，并且有Nh=Nh-1+Nh-2+1。可以证明，含有n个结点的平衡二叉树跟属于的最大深度为O(log2n)，因此平衡二叉树的平均查找长度为O(log2n)。
#### 2.5.3 平衡二叉树的插入
二叉查找树保证平衡的基本思想如下：每当在二叉查找树中插入(或删除)一个结点时，首先检查其插入路径上的结点是否因为此次操作而导致了不平衡。若导致了不平衡，则先找到插入路径上离插入结点最近的平衡因子的绝对值大于1的结点A，再对以A为根的子树，在保持二叉查找树特性的前提下，调整各结点的位置关系，使之重新达到平衡。  
**注意:每次调整的对象都是最小不平衡子树，即以插入路径上离插入结点最近的平衡因子的绝对值大于1的结点作为根的子树。下图中的虚线框内为最小不平衡子树。**  

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-bbt-insert.png)

平衡二叉树的插入过程的前半部分与二叉查找树相同，但在新结点插入后，若造成查找路径上的某个结点不再平衡，则需要做出相应的调整。可将调整的规律归纳为下列4种情况：
##### 2.5.3.1 LL平衡旋转
LL平衡旋转(右单旋转)。由于在结点A的左孩子(L)的左子树(L)上插入了新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要一次向右的旋转操作。将A的左孩子B向右上旋转代替A成为根结点，将A结点向右下旋转成为B的右子树的根结点，而B的原右子树则作为A结点的左子树。  
如下图所示，结点旁的数值代表结点的平衡因子，而用方块表示相应结点的子树，下方数值代表该子树的高度。  

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-bbtll.png)
##### 2.5.3.2 RR平衡旋转
RR平衡旋转(左单旋转)。由于在结点A的右孩子的右子树上插入了 新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要一次向左的旋转操作。将A的右孩子B向左上旋转代替A成为根结点，将A结点向左下旋转成为B的左子树的根结点，而B的原左子树则作为A结点的右子树。  
![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-bbtrr.png)

##### 2.5.3.3 LR平衡旋转
LR平衡旋转(先左后右双旋转)。由于在A的左孩子(L)的右子树®上插入新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置（即进行一次**RR平衡旋转(左单旋转)** ），然后再把该C结点向右上旋转提升到A结点的位置（即进行一次**LL平衡旋转(右单旋转)** ）。

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-bbtlr.png)
##### 2.5.3.4 RL平衡旋转
RL平衡旋转(先右后左双旋转)。由于在A的右孩子®的左子树(L)上插入新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。先将A结点的右孩子B的左子树的根结点C向右上旋转提升到B结点的位置（即进行一次**LL平衡旋转(右单旋转)** ），然后再把该C结点向左上旋转提升到A结点的位置（即进行一次**RR平衡旋转(左单旋转)** ）。

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-bbtrl.png)  

**注意: LR和RL旋转时，新结点究竟是插入C的左子树还是插入C的右子树不影响旋转过程，而上图中是以插入C的左子树中为例。**

举个例子：  
假设关键字序列为15,3, 7, 10, 9, 8，通过该序列生成平衡二叉树的过程如下图所示。

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-bbt2.png)

二叉查找树还有另外的平衡算法，如红黑树(Red Black Tree)等，与平衡二叉树(AVL树)相比各有优势。
### 2.6 红黑树
#### 2.6.1 红黑树的简介
红黑树是一种自平衡的二叉查找树（Self-balancing Binary Search Tree），是一种高效的查找树。它是由 Rudolf Bayer 于1972年发明，在当时被称为平衡二叉 B 树(symmetric binary B-trees)。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的红黑树。

对于二叉查找树，如果插入的数据是随机的，那么它就是接近平衡的二叉树，平衡的二叉树，它的操作效率（查询，插入，删除）效率较高，时间复杂度是O（logN）。但是可能会出现一种极端的情况，那就是插入的数据是有序的（递增或者递减），那么所有的结点都会在根结点的右侧或左侧，此时，二叉查找树就变为了一个链表，它的操作效率就降低了，时间复杂度为O(N)，所以可以认为二叉查找树的时间复杂度介于O（logN）和O(N)之间，视情况而定。那么为了应对这种极端情况，红黑树就出现了，它是具备了某些特性的二叉查找树，能解决非平衡树问题。

红黑树是一种接近平衡的二叉树（说它是接近平衡因为它并没有像AVL树的平衡因子的概念，它只是靠着满足红黑结点的5条性质来维持一种接近平衡的结构，进而提升整体的性能，并没有严格的卡定某个平衡因子来维持绝对平衡），它的左右子树高差有可能大于 1，所以红黑树不是严格意义上的平衡二叉树(AVL)，但对之进行平衡的代价较低， 其平均统计性能要强于 AVL 。

**红黑树应用比较广泛**：
* Java 中的 TreeMap，JDK 1.8 中的 HashMap、C++ STL 中的 map 均是基于红黑树结构实现的。map和set都是用红黑树实现的。
* 著名的linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块。
* epoll在内核中的实现，用红黑树管理事件块
* nginx中，用红黑树管理timer等

#### 2.6.2 红黑树的特性
首先，红黑树是一个二叉查找树，它在每个结点增加了一个存储位记录结点的颜色，可以是RED,也可以是BLACK；通过任意一条从根到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的二倍，因而近似平衡（最短路径就是全黑结点，最长路径就是一个红结点一个黑结点，当从根结点到叶子结点的路径上黑色结点相同时，最长路径刚好是最短路径的两倍）。
它同时满足以下**5个特性**：
1) 结点是红色或黑色
2) 根是黑色
3) 叶子结点（外部结点，空结点）都是黑色，这里的叶子结点指的是最底层的空结点（外部结点），下图中的那些null结点才是叶子结点，null结点的父结点在红黑树里不将其看作叶子结点
4) 每个红色结点的父子结点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色结点）
5) 对于每个结点，从该点至 nil（树尾端，java 中为 null 的结点)的任何路径都包含所相同个数的黑色结点

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-demo.png)

**红黑树的效率**：
* 红黑树的查找，插入和删除操作，时间复杂度都是O(logN)。
* 红黑树查找操作时，它和普通的相对平衡的二叉查找树的效率相同，都是通过相同的方式来查找的，没有用到红黑树特有的特性。
* 但如果插入的时候是有序数据，那么红黑树的查询效率就比二叉查找树要高了，因为此时二叉查找树不是平衡树，它的时间复杂度O(N)。
* 插入和删除操作时，由于红黑树的每次操作平均要旋转一次和变换颜色，所以它比普通的二叉查找树效率要低一点，不过时间复杂度仍然是O(logN)。总之，红黑树的优点就是对有序数据的查询操作不会慢到O(logN)的时间复杂度。
#### 2.6.3 红黑树的等价变换
![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-trans.png)

根据上面的性质，可以画出这样一棵红黑树。接下来对红黑树做等价变换，即将所有的红色结点上升一层与它的父结点放在同一行，这就很像一棵 4 阶 B 树，转换效果如下图所示。

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-trans1.png)

可以得出结论：
* 红黑树与 4 阶 B 树（2-3-4 树）具有等价性
* 黑色结点与红色子结点融合在一起，形成 1 个 B 树结点
* 红黑树的黑色结点个数与 4 阶 B 树的结点总个数相等
* 在所有的B树结点中，永远是黑色结点是父结点，红色结点是子结点。黑色结点在中间，红色结点在两边。

我们可以利用四阶B树与红黑树等价的性质，以红黑树转换成B树之后的结点情况来进行一个分类：

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-trans2.png)

#### 2.6.4 红黑树的基本操作
当我们对一棵平衡二叉查找树进行插入、删除的时候，很可能会让这棵树变得失衡（最坏可能导致所有祖先结点失衡，但是父结点和非祖先结点都不可能失衡），为了达到平衡，需要对树进行旋转。而红黑树能够达到自平衡，靠的也就是左旋、右旋和变色。

旋转操作是局部的。当一侧子树的结点少了，向另一侧“借”一些结点；当一侧子树的结点多了，则“租”一些结点给另一侧。

为了更清楚地讲解这部分内容，先声明几个概念：

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-node-definition.png)

* N - node：当前结点
* P - parent：父结点
* S - sibling：兄弟结点
* U - uncle：叔父结点（P 的兄弟结点）
* G - grand：祖父结点（P 的父结点）

##### 2.6.4.1 左旋
左旋指的是以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-left.png)


不考虑结点颜色，可以看到左旋只影响旋转结点和其右子树的结构，把右子树的结点往左子树移动。

##### 2.6.4.2 右旋
右旋指的是以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-right.png)

不考虑结点颜色，可以看到右旋只影响旋转结点和其左子树的结构，把左子树的结点往右子树移动。
##### 2.6.4.3 变色
**变色**指的是结点的颜色由红变黑或由黑变红。

将左旋、右旋和变色结合起来，得到一套变换规则：

* 变色：如果当前结点的父结点和叔父结点是红色，那么：
    * 把父结点和叔父结点变为黑色
    * 把祖父结点变为红色
    * 把指针定义到祖父结点

* 左旋：当前结点是右子树，且父结点是红色，叔父结点是黑色，对它的父结点左旋

* 右旋：当前结点是左子树，且父结点是红色，叔父结点是黑色，那么：
    * 把父结点变为黑色
    * 把祖父结点变为红色
    * 对祖父结点右旋

##### 2.6.4.4 红黑树的搜索
由于红黑树本来就是平衡二叉查找树，并且搜索也不会破坏树的平衡，所以搜索算法也与平衡二叉查找树一致：

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-search.png)

具体步骤：
1) 从根结点开始检索，把根结点设置为当前结点；
2) 若当前结点为空，返回 nil。
3) 若当前结点不为空，比较当前结点 key 与搜索 key 的大小；
4) 若当前结点 key 等于搜索 key，那么该 key 就是搜索目标，返回当前结点。
5) 若当前结点 key 大于搜索 key，把当前结点的左子结点设置为当前结点，重复步骤 2；
6) 若当前结点 key 小于搜索 key，把当前结点的右子结点设置为当前结点，重复步骤 2；
##### 2.6.4.5 红黑树的插入
红黑树插入操作分为下面两步：

**1) 定位插入的位置**

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-insert.png)

具体步骤：
1) 从根结点开始检索；
2) 若根结点为空，那么插入结点设为根结点，结束。
3) 若根结点不为空，那么把根结点设为当前结点；
4) 若当前结点为 nil，返回当前结点的父结点，结束。
5) 若当前结点 key 等于搜索 key，那么该 key 所在结点就是插入结点，更新结点的值，结束。
6) 若当前结点 key 大于搜索 key，把当前结点的左子结点设置为当前结点，重复步骤 4；
7) 若当前结点 key 小于搜索 key，把当前结点的右子结点设置为当前结点，重复步骤 4；

**2) 插入后实现自平衡**

建议新添加的结点默认为红色，因此这样能够让红黑树的性质尽快满足。不过如果添加的结点是根结点，设为黑色即可。

总结一下红黑树插入可能出现的所有场景。

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-insert-scene.png)

* **场景 1：红黑树为空树**
    
    红黑树的性质2：根结点必须是黑色。
    
    **处理**：直接把插入结点设成黑色并作为根结点。

* **场景 2：插入结点的 key 已存在**

    二叉查找树中不能插入相同元素，既然结点的 key 已经存在，红黑树也已平衡，无需重复插入。

    **处理**：将插入结点设为将要替换结点的颜色；更新当前结点的值为插入结点的值。

* **场景 3：插入结点的父结点为黑色**

    插入的结点默认是红色的，当它的父结点是黑色时，并不会破坏平衡。

    **处理**：直接插入。

* **场景 4：插入结点的父结点为红色**

    如果插入结点的父结点为红色，那么父结点不可能为根结点，所以插入结点总是存在祖父结点。这点很重要，后续的旋转操作需要祖父结点的参与。

* **场景 4.1：存在叔父结点，且为红色**
    
    由红黑树性质 4 可知：红色结点不能连续。那么此时该插入子树的红黑层数的情况是：黑-红-红。显然最简单的处理方式就是将其改为：红-黑-红。

    ![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-insert-4-1.png)

    **处理**：将父结点和叔父结点变为黑色；将祖父结点变为红色；将祖父结点设置为当前插入结点

* **场景 4.2：叔父结点不存在或为黑色，插入结点的父结点是祖父结点的左子结点**
    
    这种场景下，叔父结点所在的子树的黑色结点就比父结点所在子树的多，不满足红黑树的性质 5。

* **场景 4.2.1：插入结点是左子树**
        
    ![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-insert-4-2-1.png)
        
     **处理**：将父结点变为黑色；将祖父结点变为红色；将祖父结点右旋

* **场景 4.2.2：插入结点是左子树**
            
    这种场景显然可以转换为 4.2.1。

    ![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-insert-4-2-2.png)

    **处理**：将父结点进行左旋；将父结点设为插入结点，得到场景 4.2.1；进行场景 4.2.1 的处理

* **场景 4.3：叔父结点不存在或为黑色，插入结点的父结点是祖父结点的右子结点**
        
    相当于场景 4.2 的方向反转，直接看图。
        
* **场景 4.3.1：插入结点是左子树**
            
    ![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-insert-4-3-1.png)

    **处理**：将父结点变为黑色；将祖父结点变为红色；对祖父结点进行左旋

* **场景 4.3.2：插入结点是右子树**

    ![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-insert-4-3-2.png)

    **处理**：将父结点进行右旋；将父结点设置为插入结点，得到场景 4.3.1；进行场景 4.3.1 的处理

下面举个例子，往一棵红黑树中插入元素，**整棵树的变换**如下图所示：

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-insert-example.png)

##### 2.6.4.6 红黑树的删除

红黑树删除操作也分为两步：

**1) 定位删除的位置**

定位删除位置可以复用红黑树搜索的操作。

如果不存在目标结点，忽略本次操作；如果找到目标结点，删除后进行自平衡处理。

**2) 删除后实现自平衡**

二叉查找树删除的时候可能出现三种场景：

* 场景一：若删除结点无子结点，直接删除即可；

* 场景二：若删除结点只有一个子结点，用子结点替换删除结点；

* 场景三：若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点。

具体应用，可以借助这张图理解：
![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-delete-example.png)

我们可以发现，另外两种二叉树的删除场景都可以通过相互转换变为场景一。

在场景二情况下：删除结点用其唯一的子结点替换，子结点替换为删除结点后，可以认为删除的是子结点，若子结点又有两个子结点，那么相当于转换为场景三，一直自顶向下转换，总是能转换为场景一。

在场景三情况下：删除结点用后继结点，如果后继结点有右子结点，那么相当于转换为场景二，否则转为场景一。

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-delete-situation.png)

综上所述，**删除的结点可以看作删除替换结点，且替换结点最后总是在树末。**

下面总结一下红黑树删除可能出现的所有场景。

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-delete-all.png)

为了方面理解，我们先约定一下结点的叫法：

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-delete-node-definition.png)

* R - 替换结点
* P - 替换结点的父结点
* S - 替换结点的兄弟结点
* SL - 兄弟结点的左子结点
* SR - 兄弟结点的右子结点
* 灰色 - 结点颜色可能是红色，也可能是黑色

**注意**：R 是即将被替换到删除结点的位置的替换结点，在删除前，它还在原来所在位置参与树的子平衡，平衡后再替换到删除结点的位置，才算删除完成。

* **场景 1：替换结点为红色**

    我们把替换结点换到了删除结点的位置时，由于替换结点为红色，删除也了不会影响红黑树的平衡，只要把替换结点的颜色变为删除的结点的颜色即可重新平衡。

    **处理**：替换结点颜色变为删除结点的颜色。

* **场景 2：替换结点为黑色**

    当替换结点是黑色时，就必须进行自平衡处理了，我们可以通过区分替换结点是其父结点的左子结点还是右子结点，来做不同的旋转，使树重新平衡。

* **场景 2.1：替换结点是左子树**

* **场景 2.1.1：替换结点的兄弟结点为红色**

    若兄弟结点是红结点，那么根据红黑树性质 4，兄弟结点的父结点和子结点肯定为黑色，按照下图方式处理，得到删除场景 2.1.2.3。

    ![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-delete-2-1-1.png)

    **处理**：将兄弟结点变为黑色；将父结点变为红色；对父结点进行左旋，得到场景 2.1.2.3；进行场景 2.1.2.3 的处理

* **场景 2.1.2：替换结点的兄弟结点为黑色**

    当兄弟结点为黑时，其父结点和子结点的具体颜色也无法确定，此时又得考虑多种子场景。

* **场景 2.1.2.1：替换结点的兄弟结点的右子结点为红色，左子结点任意颜色**

    即将删除的左子树的一个黑色结点，显然左子树的黑色结点少 1 了，然而右子结点又是红色，那么我们直接向右子树“借”个红结点来补充黑结点，并进行旋转处理。如图所示：

    ![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-delete-2-1-2-1.png)

    **处理**：将兄弟结点的颜色变为父结点的颜色；将父结点变为黑色；将兄弟结点的右子结点变为黑色；对父结点进行左旋

* **场景 2.1.2.2：替换结点的兄弟结点的右子结点为黑色，左子结点为红色**
    兄弟结点所在的子树有红结点，又可以向兄弟子树“借”个红结点过来，这就转换回了场景 2.1.2.1。如图所示：

    ![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-delete-2-1-2-2.png)

    **处理**：将兄弟结点变为红色；将兄弟结点的左子结点变为黑色；对兄弟结点进行右旋，得到场景 2.1.2.1；进行场景 2.1.2.1 的处理

* **场景 2.1.2.3：替换结点的兄弟结点的子结点都为黑色**

    兄弟子树没有红结点可以“借”了，再向父结点“借”。如果父结点是黑色，为了让父结点在所在的子树中保证平衡（替换结点即将删除，少了一个黑色结点，子树也需要少一个）先把兄弟结点变为红色，再让父结点成为新的替换结点。

    ![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-delete-2-1-2-3.png)

    **处理**：
     * 如果父结点为黑色：将兄弟结点变为红色；将父结点作为新的替换结点；重新进行删除结点的场景处理
     * 如果父结点为红色：替换结点的父结点和替换结点的兄弟结点颜色交换；删除结点和替换结点的值交换后，删除替换结点

* **场景 2.2：替换结点是右子树**

    实际上是场景 2.1 的镜像操作。

* **场景 2.2.1：替换结点的兄弟结点为红色**

    ![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-delete-2-2-1.png)

    **处理**：将兄弟结点变为黑色；将父结点变为红色；对父结点进行右旋，得到场景 2.2.2.3；进行场景 2.2.2.3 的处理

* **场景 2.2.2：替换结点的兄弟结点为黑色**

* **场景 2.2.2.1：替换结点的兄弟结点的左子结点为红色，右子结点任意颜色**

    ![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-delete-2-2-2-1.png)

    **处理**：将兄弟结点的颜色变为父结点的颜色；将父结点变为黑色；将兄弟结点的左子结点变为黑色；对父结点进行右旋

* **场景 2.2.2.2：替换结点的兄弟结点的左子结点为黑色，右子结点为红色**

    ![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-delete-2-2-2-2.png)

    **处理**：将兄弟结点变为红色；将兄弟结点的右子结点设为黑色；对兄弟结点进行左旋，得到场景 2.2.2.1；进行场景 2.2.2.1 的处理

* **场景 2.2.2.3：替换结点的兄弟结点的子结点都为黑色**

    ![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-rbt-delete-2-2-2-3.png)

    **处理**：
     * 如果父结点为黑色：将兄弟结点变为红色；将父结点作为新的替换结点；重新进行删除结点的场景处理
     * 如果父结点为红色：替换结点的父结点和替换结点的兄弟结点颜色交换；删除结点和替换结点的值交换后，删除替换结点

### 2.7 哈夫曼树和哈夫曼编码
#### 2.7.1 哈夫曼树的定义
在许多应用中，树中结点常常被赋予一个表示某种意义的数值，称为该结点的**权**
。从树的根到任意结点的路径长度(经过的边数)与该结点上权值的乘积，称为该结点的**带权路径长度**
。树中所有叶结点的带权路径长度之和称为该树的**带权路径长度** ，记为
<center>
  ![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-hfmf.png)
</center>

​式中，wi​是第i个叶结点所带的权值，li​是该叶结点到根结点的路径长度。  
在含有n个带权叶结点的二叉树中，其中带权路径长度(WPL)最小的二叉树称为**哈夫曼树** ，也称**最优二叉树**。
例如，下图中的3棵二叉树都有4个叶子结点a, b,c,d,分别带权7,5,2,4，它们的带权路径长度分别为  
![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-hfm.png)  
(a). WPL = 7x2 + 5x2 + 2x2 + 4x2 = 36。  
(b). WPL = 4x2 + 7x3 + 5x3 + 2x1 = 46。  
(c). WPL = 7x1 + 5x2 + 2x3 + 4x3 = 35。  
其中，图c树的WPL最小。可以验证，它恰好为哈夫曼树。

#### 2.7.2 哈夫曼树的构造
> 步骤：
> 1) 先把有权值的叶子结点按照从大到小（从小到大也可以）的顺序排列成一个有序序列。
> 2) 取最后两个最小权值的结点作为一个新结点的两个子结点，注意相对较小的是左孩子。
> 3) 用第2步构造的新结点替掉它的两个子结点，插入有序序列中，保持从大到小排列。
> 4) 重复步骤2到步骤3，直到根结点出现。

看图就清晰了，如下图所示：

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-hfm1.png)
#### 2.7.3 哈夫曼编码
哈夫曼当前研究这种最优树的目的是为了解决当年远距离通信(主要是电报)的数据传输的最优化问题。  
**哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码。**  
比如我们有一段文字内容为“BADCADFEED”要网络传输给别人，显然用二进制的数字(0和1)来表示是很自然的想法。我们现在这段文字只有六个字母ABCDEF，那么我们可以用相应的二进制数据表示，如下表所示：  
|字母|A|B|C|D|E|F|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|二进制字符|000|001|010|011|100|101|

这样按照固定长度编码编码后就是“001000011010000011101100100011”，对方接收时可以按照3位一分来译码。如果一篇文章很长，这样的二进制串也将非常的可怕。而且事实上，不管是英文、中文或是其他语言，字母或汉字的出现频率是不相同的。  
假设六个字母的频率为A 27,B 8,C 15,D 15,E 30,F 5,合起来正好是  
100%。那就意味着，我们完全可以重新按照哈夫曼树来规划它们。  
下图左图为构造哈夫曼树的过程的权值显示。右图为将权值左分支改为0，右分支改为1后的哈夫曼树。  

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-hfmlr.png)

这棵哈夫曼树的WPL为:WPL=2∗(15+27+30)+3∗15+4∗(5+8)=241  
此时，我们对这六个字母用其从树根到叶子所经过路径的0或1来编码，可以得到如下表所示这样的定义。  
|字母|A|B|C|D|E|F|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|二进制字符|01|1001|101|00|11|1001|

若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。  
我们将文字内容为“ BADCADFEED”再次编码，对比可以看到结果串变小了。
* 原编码二进制串: 000011000011101100100011 (共 30个字符)
* 新编码二进制串: 10100101010111100(共25个字符)

也就是说，我们的数据被压缩了，节约了大约17%的存储或传输成本。

**注意**:0和1究竟是表示左子树还是右子树没有明确规定。左、右孩子结点的顺序是任意的，所以构造出的哈夫曼树并不唯一，但各哈夫曼树的带权路径长度WPL相同且为最优。此外，如有若干权值相同的结点，则构造出的哈夫曼树更可能不同，但WPL必然相同且是最优的。

#### 2.7.4 哈夫曼树和哈夫曼编码代码实现
##### 2.7.4.1 存储结构
```c
//哈夫曼树结点
typedef struct
{
    int weight;//权值
    int parent, lchild, rchild;
}HTNode,*HTTree;

//哈夫曼编码
typedef struct
{
    char ch;//结点名称
    char code[10];//结点的编码
}CodeNode,*HuffmanCode;

```
##### 2.7.4.2 哈夫曼树初始化
```c
//哈夫曼树的初始化,m表示哈夫曼树总的结点个数
void InitHuffmanTree(HTTree *HT, int m)
{
    *HT=(HTTree)malloc(m * sizeof(HTNode));//为哈夫曼树结点申请空间

    //哈夫曼树结点的初始化
    for (int i = 0; i < m; i++)
    {
        (*HT)[i].weight = 0;
        (*HT)[i].parent = -1;
        (*HT)[i].lchild = -1;
        (*HT)[i].rchild = -1;
    }
}

```
##### 2.7.4.3 哈夫曼树创建
```c
//哈夫曼树挑选2个最小权值的结点
//从n个结点中选取2个最小的结点,将其下标保存到min1,min2
void SelectMin(HTTree *HT, int n, int *min1, int *min2)
{
    //临时结点，保存没有父结点的结点
    typedef struct
    {
        int LocWeight;
        int loc;//结点原始的下标
    }TempNode,*TempTree;

    int i, j=0;
    int m1, m2;
    m1 = m2 = 0;

    TempTree temptree = (TempTree)malloc(n * sizeof(TempNode));

    //将无父结点的结点存入temptree
    for (i = 0; i < n; i++)
    {
        if ((*HT)[i].parent == -1 && (*HT)[i].weight != 0)
        {
            temptree[j].LocWeight = (*HT)[i].weight;
            temptree[j].loc = i;
            j++;
        }
    }

    //选择权值最小的结点
    for (i = 0; i < j; i++)
    {
        if (temptree[i].LocWeight < temptree[m1].LocWeight)//不取等号，让其选择前面最小的结点
            m1 = i;
    }

    //选择权值次小的结点
    for (i = 0; i < j; i++)
    {
        if (m1 == m2)
            m2++;//当m1在第一个位置时，m2后移一位
        if (i != m1 && temptree[i].LocWeight <= temptree[m2].LocWeight)
            m2 = i;
    }
    *min1 = temptree[m1].loc;
    *min2 = temptree[m2].loc;
}

//由n个结点创建HuffmanTree
void CreateHuffmanTree(HTTree *HT, int weigh[],int n)
{
    int total = 2 * n - 1;//HuffmanTree中总的结点个数
    int i, min1, min2;

    InitHuffmanTree(HT, total);

    for (i = 0; i < n; i++)
        (*HT)[i].weight = weigh[i];

    //每次选择两个权值最小的结点合并
    for (i = n; i < total; i++)
    {
        SelectMin(HT, i, &min1, &min2);
        (*HT)[min1].parent = i;
        (*HT)[min2].parent = i;
        (*HT)[i].lchild = min1;
        (*HT)[i].rchild = min2;
        (*HT)[i].weight = (*HT)[min1].weight + (*HT)[min2].weight;
    }

}

```

##### 2.7.4.4 哈夫曼编码的创建
注意：这里采用的方法是从叶子结点向根结点遍历的方式，保存哈夫曼编码，在实现时要注意字符的赋值问题。

```c
//HuffmanCode的创建
void CreateHuffmanCode(HTTree *HT, HuffmanCode *HC, char codename[], int n)
{
    int i, start,par,c;
    char *cd = (char *)malloc(n * sizeof(char ));
    cd[n-1] = '\0';//临时存储编码

    (*HC) = (HuffmanCode)malloc(n * sizeof(CodeNode));

    //为每个结点创建HuffmanCode
    for (i = 0; i < n; i++)
    {
        (*HC)[i].ch = codename[i];
        start = n - 1;
        c = i;

        //从叶子结点向上查找到根
        while ((par = (*HT)[c].parent) >= 0)
        {
            --start;

            //看c是父结点的左子树还是右子树
            if ((*HT)[par].lchild == c)
                cd[start] = '0';
            else
                cd[start] = '1';
            c = par;
        }

        int g = 0;
        for (int l = start; l < n; l++)
            (*HC)[i].code[g++] = cd[l];
    }
    free(cd);
}

```
##### 2.7.4.5 哈夫曼编码的输出
```c
void OutPutHuffmanCode(HuffmanCode *HC, int n)
{

    for (int i = 0; i < n; i++)
        printf("%c: %s\n", (*HC)[i].ch, (*HC)[i].code);

}

```
##### 2.7.4.6 运行结果
执行代码：
```c
int main()
{
    int n = 6;
    char codename[6] = { 'a','b','c','d','e','f' };
    int weigh[6] = { 45,13,12,16,9,5 };

    HTTree HT;
    HuffmanCode HC;

    CreateHuffmanTree(&HT, weigh, n);
    CreateHuffmanCode(&HT, &HC, codename, n);
    OutPutHuffmanCode(&HC, n);

    return 0;
}

```

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-hfmcode.png)

运行结果：
```c
a: 0
b: 101
c: 100
d: 111
e: 1101
f: 1100
```

### 2.8 树、森林与二叉树的转化
在讲树的存储结构时，我们提到了树的孩子兄弟法可以将一棵树用二叉链表进行存储，所以借助二叉链表，树和二叉树可以相互进行转换。从物理结构来看，它们的二叉链表也是相同的，只是解释不太一样而已。
因此，只要我们设定一定的规则，用二叉树来表示树，甚至表示森林都是可以的，森林与二叉树也可以互相进行转换。
#### 2.8.1 树转换为二叉树
树转换为二叉树的规则:每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟，这个规则又称“左孩子右兄弟”。由于根结点没有兄弟，所以对应的二叉树没有右子树。
树转换成二叉树的画法:
* 在兄弟结点之间加一连线;
* 对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉;
* 以树根为轴心，顺时针旋转45°。  

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-trans1.png)

#### 2.8.2 森林转化为二叉树
森林是由若干棵树组成的，所以完全可以理解为,森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作。  
森林转换成二叉树的画法:
* 将森林中的每棵树转换成相应的二叉树;
* 每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线;
* 以第一棵树的根为轴心顺时针旋转45°。

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-trans2.png)

至于二叉树转换为树或者二叉树转换为森林只不过是上面步骤的逆过程，在此不做赘述。
### 2.9 树和森林的遍历
#### 2.9.1 树的遍历
树的遍历是指用某种方式访问树中的每个结点，且仅访问一次。主要有两种方式:
* 先根遍历。若树非空，先访问根结点，再依次遍历根结点的每棵子树，遍历子树时仍遵循先根后子树的规则。其遍历序列与这棵树相应二叉树的先序序列相同。
* 后根遍历。若树非空，先依次遍历根结点的每棵子树，再访问根结点，遍历子树时仍遵循先子树后根的规则。其遍历序列与这棵树相应二叉树的中序序列相同。

另外，树也有层次遍历，与二叉树的层次遍历思想基本相同，即按层序依次访问各结点。
#### 2.9.2 森林的遍历
按照森林和树相互递归的定义，可得到森林的两种遍历方法。
* 先序遍历森林。若森林为非空，则按如下规则进行遍历:  
  * 访问森林中第一棵树的根结点。  
  * 先序遍历第一棵树中根结点的子树森林。  
  * 先序遍历除去第一棵树之后剩余的树构成的森林。

* 后序遍历森林。森林为非空时，按如下规则进行遍历:  
  * 后序遍历森林中第一棵树的根结点的子树森林。  
  * 访问第一棵树的根结点。  
  * 后序遍历除去第一棵树之后剩余的树构成的森林。

下图的森林的先序遍历序列为ABCDEFGHI，后序遍历序列为BCDAFEHIG。 

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-travers-forest.png)  

当森林转换成二叉树时，其第一棵树的子树森林转换成左子树，剩余树的森林转换成右子树，可知森林的先序和后序遍历即为其对应二叉树的先序和中序遍历。
## 3 多叉树
### 3.1 多叉树的概念
#### 3.1.1 多叉树的定义
多叉树（Multiway Tree）也称为有向树或者无序树，它是一类特殊的树形结构，每个结点可以拥有任意个子结点，即不同于二叉树的两个子结点。
#### 3.1.2 多叉树的应用
由于多叉树可以表示任意结构的树形数据，因此在计算机科学中有着广泛的应用，包括但不限于以下领域：
* 文件系统：文件夹和文件可以被视为一棵树，文件夹为根结点，文件为叶子结点。
* 数据库系统：数据库中的索引可以使用多叉树实现，例如B+树就是一棵多叉树。
* 人工智能：深度学习中的神经网络本质上就是一种多叉树结构。
* 操作系统：进程和线程之间的关系可以用多叉树表示。

### 3.2 多路查找树
#### 3.2.1 多路查找树的定义
**多路查找树(Muitl-way Search Tree)，其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素**。由于它是查找树，所有元素之间存在某种特定的排序关系。  
在这里，每一个结点可以存储多少个元素，以及它的孩子数的多少是非常关键的。常见的有4种特殊形式：2-3树、2-3-4树、B树和B+树。这里主要介绍B树和B+树，因为2-3树、2-3-4树都是B树的特例。  
如下图所示是一颗2-3树：  
![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-mst.png)  

### 3.3 B树
#### 3.3.1 B树的定义
B树(Balanced Tree)一种平衡的多路查找树，B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示。B树是所有结点的平衡因子均等于0的多路平衡查找树，这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成，可以拥有多于2个子结点。

**B树结构：有序数组+平衡多叉树**

#### 3.3.2 B树的特性
* 定义任意非叶子结点最多只有M个儿子；且M>2
* 根结点的儿子数为[2, M]
* 除根结点以外的非叶子结点的儿子数为[M/2, M]
* 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
* 非叶子结点的关键字个数=指向儿子的指针个数-1
* 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]
* 非叶子结点的指针：P[1], P[2], …, P[M]，其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树
* 所有叶子结点位于同一层

如下图为一个M=3的B树示例：

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-bt-m3.png)  

对上图的说明:

* B树的阶：结点的最多子结点个数。比如 2-3 树的阶是 3，2-3-4 树的阶是 4
* B树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询 关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点
* 关键字集合分布在整颗树中, 即叶子结点和非叶子结点都存放数据
* 搜索有可能在非叶子结点结束
* 其搜索性能等价于在关键字全集内做一次二分查找 

#### 3.3.3 B树与磁盘存取
**B树中的大部分操作所需的磁盘存取次数与B树的高度成正比。**

我们的外存，比如硬盘， 是将所有的信息分割成相等大小的页面，每次硬盘读写的都是一个或多个完整的页面，对于一个硬盘来说，一页的长度可能是211到214个字节。  
在一个典型的B树应用中，要处理的硬盘数据量很大，因此无法一次全部装入内存。因此我们会对B树进行调整，使得B树的阶数(或结点的元素)与硬盘存储的页面大小相匹配。比如说一棵B树的阶为1001
(即1个结点包含1000个关键字)，高度为2，它可以储存超过10亿个关键字，我们只要让根结点持久地保留在内存中，那么在这棵树上，寻找某一个关键字至多需要两次硬盘的读取即可。  
通过这种方式，在有限内存的情况下，每一次磁盘的访问我们都可以获得最大数量的数据。由于B树每结点可以具有比二叉树多得多的元素，所以与二叉树的操作不同，它们减少了必须访问结点和数据块的数量，从而提高了性能。可以说，B树的数据结构就是为内外存的数据交互准备的。

#### 3.3.4 B树的查找

在B树上进行查找与二叉查找树很相似，只是每个结点都是多个关键字的有序表，在每个结点上所做的不是两路分支决定，而是根据该结点的子树所做的多路分支决定。  
B树的查找包含两个基本操作：①在B树中找结点；②在结点内找关键字。由于B树常存储在磁盘上，因此前一个查找操作是在磁盘上进行的，而后一个查找操作是在内存中进行的，即在找到目标结点后，先将结点信息读入内存，然后在结点内采用顺序查找法或折半查找法。  
在B树上查找到某个结点后，先在有序表中进行查找，若找到则查找成功，否则按照对应的指针信息到所指的子树中去查找。  
![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-bt-search.png)  

例如，在上图中查找关键字42，首先从根结点开始，根结点只有一个关键字，且42>22，若存在，必在关键字22的右边子树上，右孩子结点有两个关键字，而36<42<45，则若存在，必在36和45中间的子树上，在该子结点中查到关键字42，查找成功。若查找到叶结点时（对应指针为空指针），则说明树中没有对应的关键字，查找失败。

#### 3.3.5 B树的插入

与二叉查找树的插入操作相比，B树的插入操作要复杂得多。在二叉査找树中，仅需査找到需插入的终端结点的位置。但是，在B树中找到插入的位置后，并不能简单地将其添加到终端结点中，因为此时可能会导致整棵树不再满足B树定义中的要求。将关键字key插入B树的过程如下：

  1. 定位。利用前述的B树査找算法，找出插入该关键字的最低层中的某个非叶结点(在B树中查找key时,会找到表示查找失败的叶结点,这样就确定了最底层非叶结点的插入位置。注意：插入位置一定是最低层中的某个非叶结点)。
  2. 插入。在B树中，每个非失败结点的关键字个数都在区间[⌈m/2⌉−1,m−1]内。插入后的结点关键字个数小于m，可以直接插入；插入后检查被插入结点内关键字的个数，当插入后的结点关键字个数大于m−1时，必须对结点进行分裂。

分裂的方法是：取一个新结点，在插入key后的原结点，从中间位置⌈m/2⌉将其中的关键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置⌈m/2⌉的结点插入原结点的父结点。若此时导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止,进而导致B树高度增1。  
对于m=3的B树，所有结点中最多有m−1=2个关键字，若某结点中已有两个关键字，则结点已满，如下图a所示。插入一个关键字60后，结点内的关键字个数超过了m−1，如图b所示，此时必须进行结点分裂，分裂的结果如图c所示。  
![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-bt-insert.png)  

**通俗点讲，B树的插入，结点不溢出时好说，直接插入；如果结点溢出那就分裂，并把中间结点合并到父结点。**

#### 3.3.6 B树的删除

B树中的删除操作与插入操作类似，但要更复杂一些，即要使得删除后的结点中的关键字个数≥⌈m/2⌉−1，因此将涉及结点的“合并”问题。

  1. **当被删关键字 k k k不在终端结点(最低层非叶结点)中时**，可以用k的前驱(或后继)k′来替替代k，然后在相应的结点中删除k′，关键字k′必定落在某个终端结点中，则转换成了被删关键字在终端结点中的情形。在下图的B树中，删除关键字80，用其前驱78替代，然后在终端结点中删除78。因此只需讨论删除终端结点中关键字的情形。  
![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-bt-delete.png)  

  2. **当被删关键字在终端结点(最低层非叶结点)中时** ，有下列三种情况:  
**① 直接删除关键字** 。若被删除关键字所在结点的关键字个数≥⌈m/2⌉，表明删除该关键字后仍满足B树的定义，则直接删去该关键字。  
**② 兄弟够借** 。若被删除关键字所在结点删除前的关键字个数=⌈m/2⌉−1，且与此结点相邻的右(或左)兄弟结点的关键字个数≥⌈m/2⌉，则需要调整该结点、右(或左)兄弟结点及其双亲结点(父子换位法)，以达到新的平衡。在图(a)中删除B树的关键字65，右兄弟关键字个数≥⌈m/2⌉=2，将71取代原65的位置，将74调整到71的位置。  
![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-bt-delete1.png)  

**③ 兄弟不够借** 。若被删除关键字所在结点删除前的关键字个数=⌈m/2⌉−1，且此时与该结点相邻的左、右兄弟结点的关键字个数均=⌈m/2⌉−1，则将关键字删除后与左(或右)兄弟结点及双亲结点中的关键字进行合并。在图(b)中删除B树的关键字5，它及其右兄弟结点的关键字个数=⌈m/2⌉−1=1，故在5删除后将60合并到65结点中。  
在合并过程中，双亲结点中的关键字个数会减1。若其双亲结点是根结点且关键字个数减少至0 (根结点关键字个数为1时，有2棵子树)，则直接将根结点删除，合并后的新结点成为根；若双亲结点不是根结点，且关键字个数减少到⌈m/2⌉−2，则又要与它自己的兄弟结点进行调整或合并操作，并重复上述步骤，直至符合B树的要求为止。

**其实通俗点讲，B树的删除，删除结点无非就是多留少补的情况，多留不必多说；少补复杂点：当兄弟够借时，就向左旋转一次（即往左挪一个位置，重构根结点关键字的前驱和后继）；当兄弟不够借时就拆根结点，合并到兄弟结点，合并拆分要始终保证B树平衡，理清了就很容易理解。**

### 3.4 B+树
#### 3.4.1 B+树的定义
B+树是B-树的变体，也是一种多路查找树
B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找。

**B+树结构：有序数组链表+平衡多叉树**
#### 3.4.2 B+树的特性
* 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的
* 不可能在非叶子结点命中
* 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层
* 更适合文件索引系统。因为增删文件（结点）时，效率更高，因为B+树的叶子结点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率

如下图为一个M=3的B+树示例：

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-bt-m3+.png)  

对上图的说明:

* B+树的搜索与B树也基本相同，区别是 B+树只有达到叶子结点才命中（B 树可以在非叶子结点命中），其性 能也等价于在关键字全集做一次二分查找
* 所有关键字都出现在叶子结点的链表中（即数据只能在叶子结点【也叫稠密索引】），且链表中的关键字(数据) 恰好是有序的。
* 不可能在非叶子结点命中
* 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层
* 更适合文件索引系统
* B树和 B+树各有自己的应用场景，不能说 B+树完全比 B 树好，反之亦然

#### 3.4.3 B+树的优点
* 层级更低，IO 次数更少
* 每次都需要查询到叶子结点，查询性能稳定
* 叶子结点形成有序链表，范围查询方便
* B+树还有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持。这是数据库选用B+树的最主要原因。

#### 3.4.4 B+树与B树的差异
m阶的B+树与m阶的B树的主要差异如下：
* 有n棵子树的结点中包含有n个关键字;
* 所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接;
* 所有分支结点可以看成是索引，结点中仅含有其子树中的最大(或最小)关键字。
* 在B+树中，每个结点(非根内部结点)的关键字个数n的范围是⌈m/2⌉≤n≤m(根结点：1≤n≤m)；在B树中，每个结点(非根内部结点)的关键字个数n范围是⌈m/2⌉−1≤n≤m−1 (根结点:1≤n≤m−1)。  

下图所示为一棵4阶B+树：  
![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-bt-m4.png)  

B+树的结构特别适合带有范围的查找。比如查找我们学校18~22岁的学生人数，我们可以通过从根结点出发找到第一个18岁的学生，然后再在叶子结点按顺序查找到符合范围的所有记录。
B+树的插入、删除过程也都与B树类似，只不过插入和删除的元素都是在叶子结点上进行而已。  
![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-bt-diff.png)  

### 3.5 B*树
#### 3.5.1 B*树的定义
B*树是B+树的变体，在 B+树的非根和非叶子结点再增加指向兄弟的指针。B*树将结点的最低利用率从1/2提高到2/3。

#### 3.5.2 B*树的特性
B*树如下图所示：

![图片描述](https://cdn.jsdelivr.net/gh/willpast/image/blog/ds_algo/tree-bt-m3*.png)  

B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）；

* **B+树的分裂**：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；
* **B*树的分裂**：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；

所以，B*树分配新结点的概率比B+树要低，空间使用率更高。

### 3.6 Trie树
#### 3.6.1 Trie树的定义
Trie树称为字典树，又称单词查找树，Trie树，是一种树形结构。
Trie树是一棵有根树，每个节点包含以下字段:
* 指向子节点的指针数组 children
* 布尔字段 isEnd，表示该节点是否为字符串的结尾

它的Key都为字符串，能做到高效查询和插入，时间复杂度为O(k)，k为字符串长度，缺点是如果大量字符串没有共同前缀时很耗内存。
它的核心思想就是通过最大限度地减少无谓的字符串比较，使得查询高效率，即「用空间换时间」，再利用共同前缀来提高查询效率。

典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。

Trie 树中的每个节点都可以用一个结构体来存储。
```c
struct node{
    bool isEnd; // 结束标记
    int children[MAXC]; // 儿子们的“指针”，MAXC表示字符集的大小
}Trie[MAXN]; // MAXN表示Trie树的节点数

```

#### 3.6.2 Trie树的特性
* 根结点不包含字符，除根结点外每一个结点都只包含一个字符；
* 从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的字符串；
* 每个结点的所有子结点包含的字符都不相同。

#### 3.6.3 Trie树的查找
从根开始查找，两种情况：

* 子节点存在：沿着指针移动到子节点，继续搜索下一个字符
* 子节点不存在：说明字典树中不包含该字符串，返回 false
* 重复上述步骤，直到返回 false 或搜索完字符串的最后一个字符
* 若搜到了字符串的末尾，且字符串末尾对应节点的 isEnd 为 true ，则说明字典树中存在该字符串
#### 3.6.4 Trie树的插入
从字典树的根开始插入字符串。对于当前字符对应的子节点，有两种情况：
* 子节点存在：沿着指针移动到子节点，继续处理下一个字符
* 子节点不存在：创建一个新的子节点，记录在children数组的对应位置上，然后沿着指针移动到子节点，继续搜索下一个字符
* 重复上述步骤直到处理字符串最后一个字符，然后将当前节点标记为字符串的结尾，即将当前节点的 isEnd 置为 true

#### 3.6.5 Trie树的删除
从根开始删除，每次删除一个节点，两种情况：

* 若当前累计删除字符长度小于字符串长度。递归删除子节点之后，将当前节点删除
* 若当前累计删除字符长度等于字符串长度。将当前节点的 isEnd 置为 false
* 重复上述步骤直至删除完所有节点，判断当前节点对应的 isEnd ​是否为​ false ，若是则说明删除成功，否则删除失败
#### 3.6.6 运行结果
执行代码：  
```cpp
#include<iostream>
#include<vector>

using namespace std;

class Trie {
private:
    vector<Trie*> children;// 孩子节点
    bool isEnd;// 完整字符串标志位

public:
    // 构造函数
    Trie(){
        children.resize(26, nullptr);// 假设trie存储仅包含26个小写字母的字符串
        isEnd = false;
    }

    // 插入操作
    void insert(string word) {
        Trie* node = this;
        for (char ch : word) {
            ch -= 'a';
            if (node->children[ch] == nullptr) {
                node->children[ch] = new Trie();
            }
            node = node->children[ch];
        }
        node->isEnd = true;
    }

    // 查询操作
    bool search(string word) {
        Trie* node = this;
        for (char ch : word) {
            ch -= 'a';
            if (node->children[ch] == nullptr) {
                return false;
            }
            node = node->children[ch];
        }
        return node != nullptr && node->isEnd;
    }

    // 删除操作
    bool del(Trie* node, string word, int d){
        node = this;
        if(d == word.length()){
            node->isEnd = false;
        }else{
            char ch = word[d];
            ch -= 'a';
            if(node->children[ch] != nullptr){
                del(node->children[ch], word, d+1);
                node->children[ch] = nullptr;
            }
        }
        return !node->isEnd;
    }
    
};

int main(){
    Trie* trie = new Trie();
    trie->insert("to");
    trie->insert("in");
    trie->insert("tea");
    trie->insert("ted");
    trie->insert("ten");
    trie->insert("inn");
    cout << "search \"to\": " << trie->search("to") << endl;
    cout << "search \"in\": " << trie->search("in") << endl;
    cout << "search \"inn\": " << trie->search("inn") << endl;
    cout << "delete \"ted\": " << trie->del(trie, "ted", 0) << endl;
    cout << "delete \"tea\": " << trie->del(trie, "tea", 0) << endl;
    cout << "search \"ted\": " << trie->search("ted") << endl;
    cout << "search \"tea\": " << trie->search("tea") << endl;
    system("pause");
    return 0;
}
```
运行结果：

```cpp
search "to": 1
search "in": 1
search "inn": 1
delete "ted": 1
delete "tea": 1
search "ted": 0
search "tea": 0
```


## 参考文章

- [数据结构知识详细梳理](https://blog.csdn.net/Real_Fool_/article/details/115044709)